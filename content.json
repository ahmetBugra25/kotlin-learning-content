{
  "version": "1.0.0",
  "lastUpdate": "2025-01-06T10:00:00Z",
  "categories": [
    {
      "categoryId": 1,
      "categoryTitle": "Kotlin Programlama Dili",
      "categoryDescription": "Kotlin dilinin temel ve ileri seviye özellikleri",
      "order": 1,
      "sections": [
        {
        "sectionId": 101,
        "sectionTitle": "Kotlin'e Giriş",
        "sectionDescription": "Bu bölümde Kotlin programlama dilinin ne olduğu ve hangi alanlarda kullanıldığı hakkında temel bilgiler verilmektedir.",
        "order": 1,
        "topics": [
            {
            "topicId": 1001,
            "title": "Kotlin Nedir",
            "summary": "Kotlin, JetBrains tarafından geliştirilen, modern, güvenli ve okunabilirliği yüksek bir programlama dilidir. JVM üzerinde çalışır ve Java ile %100 uyumludur. Null safety, kısa söz dizimi ve fonksiyonel programlama desteği sayesinde hataları azaltır ve geliştirme sürecini hızlandırır. Günümüzde Android uygulama geliştirmenin resmi dili olarak kabul edilmektedir.",
            "content": "## Kotlin Nedir?\n\nKotlin, JetBrains tarafından geliştirilmiş modern bir programlama dilidir.\n\n- Java ile %100 uyumludur\n- Null safety ile hataları azaltır\n- Daha az kod ile daha fazla iş yapılmasını sağlar\n\nAndroid geliştirme başta olmak üzere backend, web ve multiplatform projelerde kullanılır.",
            "difficulty": "easy",
            "order": 1,
            "codeExamples": [
                {
                "title": "Basit Kotlin Kodu",
                "code": "fun main() {\n    println(\"Hello Kotlin\")\n}",
                "explanation": "Kotlin'de ana fonksiyon fun anahtar kelimesi ile tanımlanır ve println ile konsola çıktı verilir."
                }
            ],
            "keyPoints": [
                "JetBrains tarafından geliştirilmiştir",
                "Java ile %100 uyumludur",
                "Null safety özelliği vardır",
                "Android'in resmi dilidir"
            ],
            "questions": []
            },
            {
            "topicId": 1002,
            "title": "Kotlin Nerelerde Kullanılır",
            "summary": "Kotlin, başta Android mobil uygulama geliştirme olmak üzere birçok alanda kullanılır. Backend tarafında (Spring Boot, Ktor), masaüstü uygulamalarda, web geliştirmede (Kotlin/JS) ve çoklu platform projelerinde (Kotlin Multiplatform) tercih edilir. Java ile uyumlu olması sayesinde mevcut Java projelerine kolayca entegre edilebilir.",
            "content": "",
            "difficulty": "easy",
            "order": 2,
            "codeExamples": [],
            "keyPoints": [
                "Android uygulama geliştirme",
                "Backend (Spring Boot, Ktor)",
                "Web (Kotlin/JS)",
                "Multiplatform projeler",
                "Mevcut Java projeleri"
            ],
            "questions": []
            }
        ],
        "sectionMixedQuestions": []
        },
        {
          "sectionId": 102,
          "sectionTitle": "Değişkenler ve Veri Tipleri",
          "sectionDescription": "",
          "order": 2,
          "topics": [
            {
            "topicId": 1101,
            "title": "var ve val",
            "summary": "Kotlin'de değişken tanımlamak için var ve val anahtar kelimeleri kullanılır. var ile tanımlanan değişkenlerin değeri sonradan değiştirilebilirken, val ile tanımlanan değişkenler yalnızca bir kez atanabilir. Güvenli ve okunabilir kod yazımı için mümkün olduğunca val kullanılması önerilir.",
            "content": "## var ve val\n\nKotlin'de değişken tanımlamak için iki temel anahtar kelime bulunur:\n\n- **val (value)**: Değeri sonradan değiştirilemeyen, immutable değişkenlerdir.\n- **var (variable)**: Değeri sonradan değiştirilebilen, mutable değişkenlerdir.\n\nKotlin'de best practice olarak, değişmeyecek değerler için **val**, gerçekten değişmesi gereken durumlarda **var** kullanılması önerilir. Bu yaklaşım hem kod güvenliğini artırır hem de hataları azaltır.\n\nÖnemli bir detay olarak; val ile tanımlanan bir referans değiştirilemez ancak eğer referans bir mutable nesne tutuyorsa, nesnenin içeriği değiştirilebilir.",
            "difficulty": "easy",
            "order": 1,
            "codeExamples": [
                {
                "title": "Temel var ve val Kullanımı",
                "code": "val name = \"Ahmet\"\nvar age = 25\n\nage = 26      // Geçerli\n// name = \"Mehmet\"  // HATA",
                "explanation": "val ile tanımlanan name değişkeni yeniden atanamaz. var ile tanımlanan age değişkeni ise güncellenebilir."
                },
                {
                "title": "val ve Mutable Nesne",
                "code": "val numbers = mutableListOf(1, 2, 3)\nnumbers.add(4)\n\nprintln(numbers)",
                "explanation": "numbers referansı val olsa bile, mutable bir liste tuttuğu için listenin içeriği değiştirilebilir."
                }
            ],
            "keyPoints": [
                "val değiştirilemez (immutable)",
                "var değiştirilebilir (mutable)",
                "Varsayılan olarak val tercih edilmelidir",
                "val referansı değişmez, içeriği mutable olabilir",
                "Daha güvenli ve okunabilir kod için val kullanımı önerilir"
            ],
            "questions": [
                {
                "questionId": 110101,
                "question": "Kotlin'de değeri sonradan değiştirilemeyen değişken hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "var",
                    "val",
                    "let",
                    "const"
                ],
                "correctAnswerIndex": 1,
                "explanation": "val anahtar kelimesi ile tanımlanan değişkenler immutable'dır ve bir kez atandıktan sonra değiştirilemez.",
                "tags": ["val", "var", "basics"]
                },
                {
                "questionId": 110102,
                "question": "Aşağıdakilerden hangisi var için doğrudur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "Bir kez atanır ve değiştirilemez",
                    "Sadece sınıf içinde kullanılır",
                    "Değeri sonradan değiştirilebilir",
                    "Sadece sabit değerler için kullanılır"
                ],
                "correctAnswerIndex": 2,
                "explanation": "var ile tanımlanan değişkenlerin değeri program çalışırken değiştirilebilir.",
                "tags": ["var", "basics"]
                },
                {
                "questionId": 110103,
                "question": "Aşağıdaki kodda hangi satır hata verir?",
                "questionType": "multiple_choice",
                "code": "val x = 10\nvar y = 20\nx = 15\ny = 25",
                "difficulty": "medium",
                "options": [
                    "Satır 1",
                    "Satır 2",
                    "Satır 3",
                    "Satır 4"
                ],
                "correctAnswerIndex": 2,
                "explanation": "x değişkeni val ile tanımlandığı için yeniden değer atanamaz. Bu nedenle Satır 3 compile-time hatası verir.",
                "tags": ["val", "compile-error"]
                },
                {
                "questionId": 110104,
                "question": "Aşağıdakilerden hangisi Kotlin best practice'lerine daha uygundur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Her zaman var kullanmak",
                    "Değişmeyecek değerler için val kullanmak",
                    "Sadece global değişkenlerde val kullanmak",
                    "val ve var arasında fark yoktur"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Değişmeyecek değerler için val kullanmak kod güvenliğini ve okunabilirliği artırır.",
                "tags": ["best-practice", "val"]
                },
                {
                "questionId": 110105,
                "question": "val ile tanımlanan mutable bir liste için aşağıdakilerden hangisi doğrudur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Listeye eleman eklenemez",
                    "Liste referansı değiştirilebilir",
                    "Listenin içeriği değiştirilebilir",
                    "Compile-time hatası oluşur"
                ],
                "correctAnswerIndex": 2,
                "explanation": "val referansı değiştirilemez ancak mutable bir nesne tutuyorsa, nesnenin içeriği değiştirilebilir.",
                "tags": ["val", "collections", "mutable"]
                }
            ]
            },
            {
            "topicId": 1102,
            "title": "Int ve Long",
            "summary": "Kotlin'de Int ve Long, tam sayı (integer) değerleri temsil eden veri tipleridir. Int 32-bit, Long ise 64-bit bellek alanı kullanır. Daha büyük sayılarla çalışılması gereken durumlarda Long tercih edilir. Kotlin'de sayı taşmalarını önlemek ve performansı korumak için uygun veri tipi seçilmelidir.",
            "content": "## Int ve Long\n\nKotlin'de tam sayılar için en sık kullanılan veri tipleri **Int** ve **Long**'dur.\n\n- **Int**: 32-bit signed tam sayı tipidir. -2,147,483,648 ile 2,147,483,647 arasında değer alabilir.\n- **Long**: 64-bit signed tam sayı tipidir. Çok daha büyük sayılarla çalışmak için kullanılır.\n\nKotlin'de sayısal sabitler varsayılan olarak **Int** kabul edilir. Bir sayının Long olduğunu belirtmek için sonuna **L** veya **l** eklenmelidir.\n\nDoğru veri tipini seçmek hem bellek kullanımı hem de uygulama performansı açısından önemlidir.",
            "difficulty": "easy",
            "order": 2,
            "codeExamples": [
                {
                "title": "Int ve Long Tanımlama",
                "code": "val age: Int = 25\nval distance: Long = 1_000_000L",
                "explanation": "Int 32-bit, Long 64-bit veri tipidir. Long değerlerde L takısı kullanılır."
                },
                {
                "title": "Varsayılan Int Davranışı",
                "code": "val number = 100\nval bigNumber = 10000000000L",
                "explanation": "Kotlin'de sayısal sabitler varsayılan olarak Int kabul edilir. Daha büyük değerler için Long kullanılır."
                }
            ],
            "keyPoints": [
                "Int 32-bit tam sayı tipidir",
                "Long 64-bit tam sayı tipidir",
                "Varsayılan tam sayı tipi Int'tir",
                "Long değerler L takısı ile belirtilir",
                "Büyük sayılar için Long tercih edilmelidir"
            ],
            "questions": [
                {
                "questionId": 110201,
                "question": "Kotlin'de varsayılan tam sayı veri tipi hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "Long",
                    "Short",
                    "Int",
                    "Byte"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Kotlin'de sayısal sabitler varsayılan olarak Int veri tipi kabul edilir.",
                "tags": ["int", "basics"]
                },
                {
                "questionId": 110202,
                "question": "Aşağıdakilerden hangisi Long tipinde bir değerdir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "100",
                    "5000",
                    "9999999999L",
                    "42"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Long değerler L takısı ile belirtilir.",
                "tags": ["long", "basics"]
                },
                {
                "questionId": 110203,
                "question": "Int veri tipinin maksimum değeri yaklaşık olarak hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "2 milyar",
                    "4 milyar",
                    "9 kentilyon",
                    "Sınırsız"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Int 32-bit olduğu için maksimum değeri yaklaşık 2.1 milyardır.",
                "tags": ["int", "range"]
                },
                {
                "questionId": 110204,
                "question": "Aşağıdaki kodlardan hangisi compile-time hatası verir?",
                "questionType": "multiple_choice",
                "code": "val number: Int = 10000000000",
                "difficulty": "medium",
                "options": [
                    "Kod hata vermez",
                    "Runtime hatası verir",
                    "Compile-time hatası verir",
                    "Long'a otomatik dönüşür"
                ],
                "correctAnswerIndex": 2,
                "explanation": "10000000000 Int aralığını aştığı için compile-time hatası oluşur.",
                "tags": ["int", "error"]
                },
                {
                "questionId": 110205,
                "question": "Aşağıdakilerden hangisi Int yerine Long kullanılmasını gerektirir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Kullanıcı yaşı",
                    "Ürün adedi",
                    "Dosya boyutu (byte)",
                    "Sınıf öğrenci sayısı"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Dosya boyutları çok büyük olabileceği için Long kullanımı daha uygundur.",
                "tags": ["long", "use-case"]
                }
            ]
            },
            {
              "topicId": 1103,
              "title": "Float ve Double",
              "summary": "Float ve Double, Kotlin'de ondalıklı (virgüllü) sayıları temsil eden veri tipleridir. Float 32-bit, Double ise 64-bit hassasiyete sahiptir. Kotlin'de ondalıklı sayılar varsayılan olarak Double kabul edilir. Daha yüksek hassasiyet gereken durumlarda Double tercih edilir.",
              "content": "## Float ve Double\n\nKotlin'de ondalıklı sayılarla çalışmak için **Float** ve **Double** veri tipleri kullanılır.\n\n- **Float**: 32-bit hassasiyete sahiptir. Daha az bellek kullanır ancak doğruluk düşüktür.\n- **Double**: 64-bit hassasiyete sahiptir. Daha yüksek doğruluk sunar ve Kotlin'de varsayılan ondalıklı sayı tipidir.\n\nFloat değerler tanımlanırken sonuna **F** veya **f** eklenmelidir. Aksi halde Kotlin bu değeri Double olarak kabul eder.\n\nFinansal hesaplamalar, ölçümler ve hassas sonuçlar gerektiren işlemlerde genellikle Double tercih edilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Float ve Double Tanımlama",
                  "code": "val piDouble: Double = 3.14159\nval piFloat: Float = 3.14F",
                  "explanation": "Float değerlerde F takısı zorunludur. Aksi halde değer Double kabul edilir."
                },
                {
                  "title": "Varsayılan Double Davranışı",
                  "code": "val number = 2.5\nval preciseNumber = 2.5F",
                  "explanation": "Ondalıklı sayılar varsayılan olarak Double tipindedir."
                }
              ],
              "keyPoints": [
                "Float 32-bit hassasiyete sahiptir",
                "Double 64-bit hassasiyete sahiptir",
                "Varsayılan ondalıklı sayı tipi Double'dır",
                "Float değerler F takısı ile belirtilir",
                "Hassas hesaplamalar için Double tercih edilir"
              ],
              "questions": [
                {
                  "questionId": 110301,
                  "question": "Kotlin'de varsayılan ondalıklı sayı veri tipi hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Float",
                    "Double",
                    "Int",
                    "Long"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de ondalıklı sayılar varsayılan olarak Double kabul edilir.",
                  "tags": ["double", "basics"]
                },
                {
                  "questionId": 110302,
                  "question": "Aşağıdakilerden hangisi Float tipinde bir değerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "3.14",
                    "2.5",
                    "1.0",
                    "3.14F"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Float değerler F veya f takısı ile belirtilir.",
                  "tags": ["float", "basics"]
                },
                {
                  "questionId": 110303,
                  "question": "Float ve Double arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Float daha hassastır",
                    "Double daha az bellek kullanır",
                    "Double daha yüksek hassasiyet sunar",
                    "Aralarında fark yoktur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Double 64-bit olduğu için Float'a göre daha yüksek hassasiyet sunar.",
                  "tags": ["precision", "comparison"]
                },
                {
                  "questionId": 110304,
                  "question": "Aşağıdaki kodlardan hangisi compile-time hatası verir?",
                  "questionType": "multiple_choice",
                  "code": "val value: Float = 2.5",
                  "difficulty": "medium",
                  "options": [
                    "Kod hata vermez",
                    "Runtime hatası verir",
                    "Compile-time hatası verir",
                    "Otomatik Float'a dönüşür"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "2.5 varsayılan olarak Double olduğu için Float'a atanamaz. F takısı gereklidir.",
                  "tags": ["float", "error"]
                },
                {
                  "questionId": 110305,
                  "question": "Aşağıdaki kullanım senaryolarından hangisinde Double tercih edilmelidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Ekran parlaklığı değeri",
                    "Sıcaklık ölçümü",
                    "Para hesaplamaları",
                    "Sayaç artışı"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Para ve hassas hesaplamalarda Double tercih edilir (daha doğrusu BigDecimal ama Float kullanılmamalıdır).",
                  "tags": ["double", "use-case"]
                }
              ]
            },
            {
              "topicId": 1104,
              "title": "String",
              "summary": "String, Kotlin'de metinsel ifadeleri temsil eden veri tipidir. Karakter dizilerinden oluşur ve immutable (değiştirilemez) yapıdadır. Kotlin'de String'ler güçlü fonksiyonlar, string interpolation ve çok satırlı yazım desteği sunar.",
              "content": "## String\n\nKotlin'de **String**, metin verilerini temsil eder ve **immutable** bir veri tipidir. Yani bir String oluşturulduktan sonra içeriği değiştirilemez.\n\nKotlin String'leri birçok hazır fonksiyon ile birlikte gelir. Ayrıca **string interpolation** sayesinde değişkenler doğrudan metin içinde kullanılabilir.\n\nKotlin'de String oluşturmanın iki temel yolu vardır:\n\n- Çift tırnak (\" \") ile tek satırlı String\n- Üç tırnak (\"\"\" \"\"\") ile çok satırlı String\n\nString işlemleri güvenli, okunabilir ve performanslı bir şekilde yapılabilir.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "String Tanımlama",
                  "code": "val name: String = \"Ahmet\"\nval city = \"Erzurum\"",
                  "explanation": "String değerler çift tırnak içinde tanımlanır. Kotlin type inference sayesinde türü otomatik belirler."
                },
                {
                  "title": "String Interpolation",
                  "code": "val age = 25\nval message = \"Yaşım $age\"\nval result = \"5 + 3 = ${5 + 3}\"",
                  "explanation": "$ işareti ile değişkenler, ${} ile ifadeler String içine gömülebilir."
                },
                {
                  "title": "Çok Satırlı String",
                  "code": "val text = \"\"\"\n    Kotlin öğreniyorum\n    Android geliştiriyorum\n\"\"\".trimIndent()",
                  "explanation": "Üç tırnak kullanılarak çok satırlı String tanımlanabilir."
                }
              ],
              "keyPoints": [
                "String immutable bir veri tipidir",
                "Metinsel veriler için kullanılır",
                "String interpolation desteklenir",
                "Çok satırlı String yazımı mümkündür",
                "Birçok hazır fonksiyon içerir (length, contains, substring)"
              ],
              "questions": [
                {
                  "questionId": 110401,
                  "question": "Kotlin'de String veri tipi hangi özelliğe sahiptir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Mutable",
                    "Immutable",
                    "Sadece okunur",
                    "Null olabilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de String immutable'dır, yani oluşturulduktan sonra değiştirilemez.",
                  "tags": ["string", "basics"]
                },
                {
                  "questionId": 110402,
                  "question": "String interpolation için hangi sembol kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "#",
                    "$",
                    "%",
                    "&"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de $ sembolü ile String interpolation yapılır.",
                  "tags": ["string", "interpolation"]
                },
                {
                  "questionId": 110403,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val name = \"Ali\"\nprintln(\"Merhaba $name\")",
                  "difficulty": "easy",
                  "options": [
                    "Merhaba name",
                    "Merhaba $name",
                    "Merhaba Ali",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "$name ifadesi String içine gömülür ve değeri yazdırılır.",
                  "tags": ["string", "output"]
                },
                {
                  "questionId": 110404,
                  "question": "Çok satırlı String tanımlamak için hangi yapı kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "\" \"",
                    "''' '''",
                    "\"\"\" \"\"\"",
                    "` `"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de üç tırnak (\"\"\" \"\"\") çok satırlı String tanımlamak için kullanılır.",
                  "tags": ["string", "multiline"]
                },
                {
                  "questionId": 110405,
                  "question": "Aşağıdakilerden hangisi String fonksiyonu değildir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "length",
                    "contains",
                    "substring",
                    "add"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "String sınıfında add() fonksiyonu yoktur.",
                  "tags": ["string", "functions"]
                }
              ]
            },
            {
              "topicId": 1105,
              "title": "Boolean",
              "summary": "Boolean, Kotlin'de mantıksal (doğru/yanlış) değerleri temsil eden veri tipidir. Sadece true veya false değerlerini alabilir ve genellikle koşul ifadelerinde, karşılaştırmalarda ve kontrol yapılarında kullanılır.",
              "content": "## Boolean\n\nKotlin'de **Boolean** veri tipi, mantıksal ifadeleri temsil eder ve yalnızca iki değer alabilir: **true** veya **false**.\n\nBoolean'lar genellikle **if**, **when**, **while** gibi kontrol yapılarında ve karşılaştırma işlemlerinde kullanılır. Ayrıca mantıksal operatörlerle (&&, ||, !) birlikte güçlü kontrol mekanizmaları sağlar.\n\nBoolean ifadeler, uygulamanın akışını kontrol etmek için temel yapı taşlarından biridir.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Boolean Tanımlama",
                  "code": "val isActive: Boolean = true\nval isAdmin = false",
                  "explanation": "Boolean değişkenler true veya false değerlerini alabilir."
                },
                {
                  "title": "Karşılaştırma Sonucu Boolean",
                  "code": "val age = 18\nval isAdult = age >= 18",
                  "explanation": "Karşılaştırma işlemleri Boolean sonuç döner."
                },
                {
                  "title": "Mantıksal Operatörler",
                  "code": "val hasAccount = true\nval isLoggedIn = false\n\nval canAccess = hasAccount && isLoggedIn",
                  "explanation": "&& (AND), || (OR) ve ! (NOT) operatörleri Boolean işlemlerinde kullanılır."
                }
              ],
              "keyPoints": [
                "Boolean sadece true veya false değerlerini alır",
                "Kontrol yapılarının temelini oluşturur",
                "Karşılaştırma işlemleri Boolean döner",
                "Mantıksal operatörlerle birlikte kullanılır",
                "Uygulama akışını kontrol etmek için kritiktir"
              ],
              "questions": [
                {
                  "questionId": 110501,
                  "question": "Boolean veri tipi hangi değerleri alabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "1 ve 0",
                    "true ve false",
                    "Evet ve Hayır",
                    "On ve Off"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Boolean veri tipi sadece true ve false değerlerini alabilir.",
                  "tags": ["boolean", "basics"]
                },
                {
                  "questionId": 110502,
                  "question": "Aşağıdaki karşılaştırmalardan hangisi Boolean döner?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "5 + 3",
                    "10 * 2",
                    "8 > 3",
                    "7 - 4"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Karşılaştırma işlemleri Boolean (true/false) döner.",
                  "tags": ["boolean", "comparison"]
                },
                {
                  "questionId": 110503,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val isOpen = true\nval isAdmin = false\nprintln(isOpen && isAdmin)",
                  "difficulty": "medium",
                  "options": [
                    "true",
                    "false",
                    "Compile-time hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "&& operatörü AND işlemi yapar. true && false sonucu false olur.",
                  "tags": ["boolean", "operators"]
                },
                {
                  "questionId": 110504,
                  "question": "Mantıksal OR işlemi hangi operatör ile yapılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "&&",
                    "||",
                    "!",
                    "=="
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "|| operatörü mantıksal OR (veya) işlemi yapar.",
                  "tags": ["boolean", "operators"]
                },
                {
                  "questionId": 110505,
                  "question": "Aşağıdakilerden hangisi Boolean operatörü değildir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "&&",
                    "||",
                    "!",
                    "+"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "+ operatörü aritmetik işlemler içindir, Boolean işlemi yapmaz.",
                  "tags": ["boolean", "operators"]
                }
              ]
            },
            {
              "topicId": 1106,
              "title": "Tip Dönüşümleri",
              "summary": "Tip dönüşümleri, bir veri tipinin başka bir veri tipine çevrilmesi işlemidir. Kotlin'de veri kaybını ve hataları önlemek için otomatik dönüşümler yerine açık (explicit) tip dönüşümleri kullanılır.",
              "content": "## Tip Dönüşümleri\n\nKotlin'de veri tipleri arasında **otomatik dönüşüm yapılmaz**. Bu, özellikle Java'dan gelen geliştiriciler için önemli bir farktır.\n\nKotlin, güvenliği artırmak için dönüşümlerin **açıkça belirtilmesini (explicit conversion)** ister. Bunun için her veri tipinin sağladığı dönüşüm fonksiyonları kullanılır.\n\nEn sık kullanılan dönüşüm fonksiyonları:\n- toInt()\n- toLong()\n- toFloat()\n- toDouble()\n- toString()\n- toBoolean()\n\nBu yaklaşım, runtime hatalarını azaltır ve kodun daha okunabilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 6,
              "codeExamples": [
                {
                  "title": "Sayısal Tip Dönüşümü",
                  "code": "val number: Int = 10\nval longNumber: Long = number.toLong()",
                  "explanation": "Int tipi doğrudan Long'a atanamaz, toLong() fonksiyonu kullanılmalıdır."
                },
                {
                  "title": "String'den Sayıya Dönüşüm",
                  "code": "val text = \"123\"\nval value = text.toInt()",
                  "explanation": "String içeriği sayıya uygunsa toInt() ile dönüştürülebilir."
                },
                {
                  "title": "Hatalı Dönüşüm Örneği",
                  "code": "val text = \"abc\"\n// val number = text.toInt() // Runtime hatası",
                  "explanation": "Sayısal olmayan bir String, toInt() ile dönüştürülürse runtime hatası oluşur."
                },
                {
                  "title": "Güvenli Dönüşüm",
                  "code": "val text = \"abc\"\nval number = text.toIntOrNull()",
                  "explanation": "toIntOrNull() dönüşüm başarısız olursa null döner ve uygulama çökmez."
                }
              ],
              "keyPoints": [
                "Kotlin'de otomatik tip dönüşümü yoktur",
                "Dönüşümler explicit olarak yapılır",
                "toInt(), toDouble() gibi fonksiyonlar kullanılır",
                "Hatalı dönüşümler runtime hatası oluşturur",
                "toIntOrNull() gibi güvenli fonksiyonlar tercih edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 110601,
                  "question": "Kotlin'de Int bir değişken doğrudan Long'a atanabilir mi?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet, otomatik dönüşür",
                    "Hayır, toLong() kullanılmalıdır",
                    "Sadece val ile tanımlanırsa",
                    "Sadece var ile tanımlanırsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin otomatik tip dönüşümüne izin vermez. Açık dönüşüm gerekir.",
                  "tags": ["type-conversion", "basics"]
                },
                {
                  "questionId": 110602,
                  "question": "Aşağıdakilerden hangisi güvenli tip dönüşümü sağlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "toInt()",
                    "toLong()",
                    "toIntOrNull()",
                    "toDouble()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "toIntOrNull() dönüşüm başarısız olursa null döner.",
                  "tags": ["type-conversion", "null-safety"]
                },
                {
                  "questionId": 110603,
                  "question": "Aşağıdaki kod çalıştırıldığında ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val text = \"abc\"\nval number = text.toInt()\nprintln(number)",
                  "difficulty": "medium",
                  "options": [
                    "0 yazdırır",
                    "null yazdırır",
                    "Compile-time hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Sayısal olmayan bir String toInt() ile dönüştürülürse runtime hatası oluşur.",
                  "tags": ["type-conversion", "runtime"]
                },
                {
                  "questionId": 110604,
                  "question": "Aşağıdakilerden hangisi String'e dönüşüm yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "toInt()",
                    "toFloat()",
                    "toString()",
                    "toBoolean()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "toString() metodu değeri String'e çevirir.",
                  "tags": ["type-conversion", "string"]
                },
                {
                  "questionId": 110605,
                  "question": "Kotlin'de neden otomatik tip dönüşümü yoktur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performans düşüklüğü",
                    "Derleyici hatası",
                    "Kod güvenliğini artırmak",
                    "Java ile uyumsuzluk"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Açık tip dönüşümü, veri kaybını ve beklenmeyen hataları önler.",
                  "tags": ["type-conversion", "best-practices"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 12001,
            "question": "Kotlin'de değiştirilemeyen (immutable) değişken tanımlamak için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "var",
              "val",
              "let",
              "const"
            ],
            "correctAnswerIndex": 1,
            "explanation": "val ile tanımlanan değişkenler immutable'dır ve bir kez değer atandıktan sonra değiştirilemez.",
            "tags": ["val", "var"]
          },
          {
            "questionId": 12002,
            "question": "Aşağıdaki kodlardan hangisi derleme (compile-time) hatası verir?",
            "questionType": "multiple_choice",
            "code": "val number = 10\nnumber = 20",
            "difficulty": "easy",
            "options": [
              "Kod hatasız çalışır",
              "Runtime hatası verir",
              "Compile-time hatası verir",
              "Sadece uyarı verir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "val ile tanımlanan değişkenlere yeniden değer atanamaz. Bu nedenle compile-time hatası oluşur.",
            "tags": ["val", "compile-error"]
          },
          {
            "questionId": 12003,
            "question": "Kotlin'de aşağıdaki tam sayı tiplerinden hangisi daha fazla bellek kullanır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Int",
              "Short",
              "Long",
              "Byte"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Long 64-bit, Int ise 32-bit bellek kullanır. Bu nedenle Long daha fazla bellek tüketir.",
            "tags": ["int", "long"]
          },
          {
            "questionId": 12004,
            "question": "Aşağıdaki ifadelerden hangisi Double veri tipine aittir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "10",
              "10L",
              "10.5",
              "true"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Ondalıklı (kesirli) sayılar varsayılan olarak Double tipindedir.",
            "tags": ["double", "float"]
          },
          {
            "questionId": 12005,
            "question": "Kotlin'de Float tipinde bir sayı tanımlamak için hangi kullanım doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "val x = 10.5",
              "val x = 10.5D",
              "val x = 10.5F",
              "val x = Float(10.5)"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de Float tanımlamak için sayı sonuna 'F' eklenmelidir.",
            "tags": ["float", "double"]
          },
          {
            "questionId": 12006,
            "question": "Kotlin'de String birleştirme için hangi yöntem kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "+ operatörü",
              "$ operatörü",
              "& operatörü",
              "% operatörü"
            ],
            "correctAnswerIndex": 0,
            "explanation": "String'ler + operatörü ile birleştirilebilir. Ayrıca string template de kullanılabilir.",
            "tags": ["string"]
          },
          {
            "questionId": 12007,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val name = \"Ahmet\"\nprintln(\"Merhaba $name\")",
            "difficulty": "easy",
            "options": [
              "Merhaba name",
              "Merhaba $name",
              "Merhaba Ahmet",
              "Compile hatası"
            ],
            "correctAnswerIndex": 2,
            "explanation": "String template sayesinde $name ifadesi değişkenin değeriyle değiştirilir.",
            "tags": ["string", "template"]
          },
          {
            "questionId": 12008,
            "question": "Kotlin'de Boolean veri tipi hangi değerleri alabilir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "0 ve 1",
              "\"true\" ve \"false\"",
              "true ve false",
              "yes ve no"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Boolean veri tipi yalnızca true veya false değerlerini alır.",
            "tags": ["boolean"]
          },
          {
            "questionId": 12009,
            "question": "Aşağıdaki dönüşümlerden hangisi Kotlin'de doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "val x: Int = \"10\"",
              "val x = 10.toString()",
              "val x: String = 10",
              "val x = Int(\"10\")"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de tip dönüşümleri açık yapılır. toString() doğru bir kullanımdır.",
            "tags": ["type-conversion"]
          },
          {
            "questionId": 12010,
            "question": "Kotlin'de neden otomatik (implicit) tip dönüşümü yoktur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Performansı düşürdüğü için",
              "Okunabilirliği azalttığı için",
              "Tip güvenliğini artırmak için",
              "Sadece Java uyumluluğu için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin, tip güvenliğini artırmak ve olası hataları önlemek için implicit type casting yapmaz.",
            "tags": ["type-safety", "conversion"]
          }
        ]
        },
        {
          "sectionId": 103,
          "sectionTitle": "Kontrol Yapıları",
          "sectionDescription": "",
          "order": 3,
          "topics": [
            {
              "topicId": 1201,
              "title": "if / else",
              "summary": "if / else yapıları, Kotlin'de koşullu durumları kontrol etmek için kullanılır. Belirli bir şart sağlandığında çalışacak kod bloklarını tanımlamaya olanak tanır ve uygulama akışını yönlendirmek için temel bir kontrol mekanizmasıdır.",
              "content": "## if / else\n\nKotlin'de **if / else**, belirli koşullara göre kodun çalışıp çalışmayacağını kontrol etmek için kullanılır.\n\nKoşul ifadesi her zaman **Boolean** (true / false) olmalıdır. Kotlin'de if yapısı sadece bir kontrol mekanizması değil, aynı zamanda **bir ifade (expression)** olarak da kullanılabilir. Bu sayede if bloğu bir değer döndürebilir.\n\nBu özellik, Kotlin kodlarını daha kısa ve okunabilir hale getirir.\n\nif / else yapıları tek başına veya iç içe (nested) şekilde kullanılabilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit if Kullanımı",
                  "code": "val age = 20\n\nif (age >= 18) {\n    println(\"Reşit\")\n}",
                  "explanation": "Koşul true ise if bloğu çalışır."
                },
                {
                  "title": "if - else Kullanımı",
                  "code": "val age = 16\n\nif (age >= 18) {\n    println(\"Reşit\")\n} else {\n    println(\"Reşit değil\")\n}",
                  "explanation": "Koşul false olduğunda else bloğu çalışır."
                },
                {
                  "title": "if Expression Olarak Kullanımı",
                  "code": "val score = 75\n\nval result = if (score >= 60) {\n    \"Geçti\"\n} else {\n    \"Kaldı\"\n}",
                  "explanation": "Kotlin'de if bir değer döndürebilir ve değişkene atanabilir."
                },
                {
                  "title": "else if Kullanımı",
                  "code": "val note = 85\n\nval grade = if (note >= 90) {\n    \"AA\"\n} else if (note >= 80) {\n    \"BB\"\n} else {\n    \"CC\"\n}",
                  "explanation": "Birden fazla koşul else if ile kontrol edilebilir."
                }
              ],
              "keyPoints": [
                "Koşul mutlaka Boolean olmalıdır",
                "if bir expression olarak kullanılabilir",
                "else if ile çoklu koşullar kontrol edilir",
                "Kod okunabilirliği için süslü parantez önerilir",
                "Kontrol yapılarının temelidir"
              ],
              "questions": [
                {
                  "questionId": 120101,
                  "question": "if koşulu hangi türde değer almalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Int",
                    "String",
                    "Boolean",
                    "Any"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "if koşulu true veya false dönen bir ifade olmalıdır.",
                  "tags": ["if", "basics"]
                },
                {
                  "questionId": 120102,
                  "question": "Kotlin'de if yapısının önemli farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece kontrol yapısıdır",
                    "Sadece döngülerle çalışır",
                    "Bir ifade (expression) olarak değer döndürebilir",
                    "Sadece else ile kullanılır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de if bir expression'dır ve değer döndürebilir.",
                  "tags": ["if", "expression"]
                },
                {
                  "questionId": 120103,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val x = 10\nval y = 20\n\nval max = if (x > y) x else y\nprintln(max)",
                  "difficulty": "medium",
                  "options": [
                    "10",
                    "20",
                    "true",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "x > y false olduğu için else bloğu çalışır ve y değeri yazdırılır.",
                  "tags": ["if", "expression"]
                },
                {
                  "questionId": 120104,
                  "question": "else if ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Tek koşul varsa",
                    "Birden fazla koşul kontrol edilecekse",
                    "Sadece Boolean false ise",
                    "if kullanılamıyorsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Birden fazla koşul kontrol edilecekse else if kullanılır.",
                  "tags": ["if", "conditions"]
                },
                {
                  "questionId": 120105,
                  "question": "Aşağıdakilerden hangisi Kotlin'de geçerli bir if ifadesidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "if (x = 5)",
                    "if x > 5",
                    "if (x > 5) println(x)",
                    "if x > 5 then"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de koşul parantez içinde yazılır ve doğru sözdizimi gerekir.",
                  "tags": ["if", "syntax"]
                }
              ]
            },            
            {
              "topicId": 1202,
              "title": "when",
              "summary": "when yapısı, Kotlin'de çoklu koşulları kontrol etmek için kullanılan güçlü bir kontrol yapısıdır. Java'daki switch yapısının gelişmiş bir versiyonudur ve hem değer hem de koşul bazlı kontroller yapabilir.",
              "content": "## when\n\nKotlin'de **when**, bir değişkenin veya ifadenin farklı durumlara göre değerlendirilmesini sağlar. Java'daki switch yapısına benzer ancak çok daha esnek ve güçlüdür.\n\nwhen sadece sabit değerlerle değil; aralıklar, koleksiyonlar, tip kontrolleri ve Boolean koşullarla da çalışabilir. Ayrıca **if gibi bir expression** olarak kullanılarak değer döndürebilir.\n\nwhen yapısı, okunabilirliği artırır ve çoklu if-else bloklarının yerini alabilir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Basit when Kullanımı",
                  "code": "val day = 3\n\nwhen (day) {\n    1 -> println(\"Pazartesi\")\n    2 -> println(\"Salı\")\n    3 -> println(\"Çarşamba\")\n    else -> println(\"Geçersiz gün\")\n}",
                  "explanation": "Değer, eşleşen case'e göre çalışır."
                },
                {
                  "title": "Birden Fazla Değerle when",
                  "code": "val number = 2\n\nwhen (number) {\n    1, 3, 5 -> println(\"Tek\")\n    2, 4, 6 -> println(\"Çift\")\n}",
                  "explanation": "Tek bir case içinde birden fazla değer kontrol edilebilir."
                },
                {
                  "title": "when Expression Olarak Kullanımı",
                  "code": "val score = 85\n\nval result = when (score) {\n    in 90..100 -> \"AA\"\n    in 80..89 -> \"BB\"\n    else -> \"CC\"\n}",
                  "explanation": "when bir expression olarak değer döndürebilir."
                },
                {
                  "title": "Koşulsuz when Kullanımı",
                  "code": "val age = 20\n\nwhen {\n    age < 18 -> println(\"Reşit değil\")\n    age >= 18 -> println(\"Reşit\")\n}",
                  "explanation": "Koşulsuz when, Boolean ifadelerle çalışır."
                }
              ],
              "keyPoints": [
                "switch yerine kullanılır",
                "Birden fazla değeri aynı anda kontrol edebilir",
                "Aralıklar (in) ile çalışabilir",
                "Expression olarak değer döndürebilir",
                "Koşulsuz when kullanımı mümkündür"
              ],
              "questions": [
                {
                  "questionId": 120201,
                  "question": "when yapısı hangi kontrol yapısının yerine kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "if",
                    "for",
                    "switch",
                    "while"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "when, Java'daki switch yapısının gelişmiş halidir.",
                  "tags": ["when", "basics"]
                },
                {
                  "questionId": 120202,
                  "question": "Kotlin'de when yapısının önemli avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece sabit değerlerle çalışır",
                    "Expression olarak değer döndürebilir",
                    "Sadece Int ile çalışır",
                    "if yerine kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "when bir expression'dır ve değer döndürebilir.",
                  "tags": ["when", "expression"]
                },
                {
                  "questionId": 120203,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val x = 7\n\nval result = when (x) {\n    in 1..5 -> \"Düşük\"\n    in 6..10 -> \"Yüksek\"\n    else -> \"Bilinmiyor\"\n}\nprintln(result)",
                  "difficulty": "medium",
                  "options": [
                    "Düşük",
                    "Yüksek",
                    "Bilinmiyor",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "7 değeri 6..10 aralığında olduğu için \"Yüksek\" yazdırılır.",
                  "tags": ["when", "range"]
                },
                {
                  "questionId": 120204,
                  "question": "Koşulsuz when ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sabit değerler kontrol edilecekse",
                    "Boolean ifadelerle kontrol yapılacaksa",
                    "Sadece String değerler için",
                    "when kullanılamıyorsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Koşulsuz when, Boolean ifadelerle çalışır.",
                  "tags": ["when", "conditions"]
                },
                {
                  "questionId": 120205,
                  "question": "Aşağıdakilerden hangisi when yapısında kullanılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Int",
                    "Sadece String",
                    "Sabit değerler",
                    "Sabitler, aralıklar ve koşullar"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "when; sabitler, aralıklar, koleksiyonlar ve koşullarla çalışabilir.",
                  "tags": ["when", "advanced"]
                }
              ]
            },
            {
              "topicId": 1203,
              "title": "for Döngüsü",
              "summary": "for döngüsü, Kotlin'de belirli bir aralıkta veya koleksiyon üzerinde tekrar eden işlemleri gerçekleştirmek için kullanılır. Sayaç kontrollü ve koleksiyon tabanlı döngüler için en yaygın kullanılan yapıdır.",
              "content": "## for Döngüsü\n\nKotlin'de **for döngüsü**, bir aralık (range) veya koleksiyon (Array, List, Set, Map) üzerinde dolaşmak için kullanılır.\n\nKotlin'de klasik index tabanlı for yerine daha okunabilir ve güvenli yapılar tercih edilir. Range ifadeleri, step, downTo ve until gibi anahtar kelimelerle güçlü bir kullanım sunar.\n\nfor döngüsü özellikle listeleme, veri işleme ve tekrar eden görevler için idealdir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Basit for Döngüsü",
                  "code": "for (i in 1..5) {\n    println(i)\n}",
                  "explanation": "1'den 5'e kadar (5 dahil) döner."
                },
                {
                  "title": "until Kullanımı",
                  "code": "for (i in 0 until 5) {\n    println(i)\n}",
                  "explanation": "0'dan 4'e kadar döner. 5 dahil değildir."
                },
                {
                  "title": "step ve downTo Kullanımı",
                  "code": "for (i in 10 downTo 0 step 2) {\n    println(i)\n}",
                  "explanation": "10'dan 0'a doğru 2'şer azalarak döner."
                },
                {
                  "title": "Koleksiyon Üzerinde for",
                  "code": "val names = listOf(\"Ali\", \"Ayşe\", \"Mehmet\")\n\nfor (name in names) {\n    println(name)\n}",
                  "explanation": "Liste elemanları üzerinde tek tek dolaşır."
                }
              ],
              "keyPoints": [
                "Range veya koleksiyon üzerinde çalışır",
                "until, downTo ve step desteklenir",
                "Index hatalarını azaltır",
                "Okunabilir ve güvenlidir",
                "Koleksiyon işlemlerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 120301,
                  "question": "Aşağıdaki for döngüsü kaç kez çalışır?",
                  "questionType": "multiple_choice",
                  "code": "for (i in 1..3) {\n    println(i)\n}",
                  "difficulty": "easy",
                  "options": [
                    "2",
                    "3",
                    "4",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "1..3 aralığı 1, 2 ve 3 değerlerini kapsar.",
                  "tags": ["for", "range"]
                },
                {
                  "questionId": 120302,
                  "question": "until anahtar kelimesinin farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Başlangıç değerini almaz",
                    "Bitiş değerini dahil etmez",
                    "Sadece geriye doğru çalışır",
                    "step ile kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "until, bitiş değerini dahil etmez.",
                  "tags": ["for", "until"]
                },
                {
                  "questionId": 120303,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "for (i in 5 downTo 1) {\n    print(i)\n}",
                  "difficulty": "medium",
                  "options": [
                    "12345",
                    "54321",
                    "01234",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "downTo geriye doğru sayar.",
                  "tags": ["for", "downTo"]
                },
                {
                  "questionId": 120304,
                  "question": "Bir koleksiyon üzerinde dolaşmak için hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "for (i = 0; i < list.size; i++)",
                    "for (item in list)",
                    "while (list)",
                    "loop (list)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de koleksiyonlar doğrudan for-in ile gezilir.",
                  "tags": ["for", "collections"]
                },
                {
                  "questionId": 120305,
                  "question": "step anahtar kelimesi ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Döngüyü durdurur",
                    "Adım sayısını belirler",
                    "Sadece ileri sayar",
                    "Bitiş değerini değiştirir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "step, döngünün kaçar kaçar ilerleyeceğini belirler.",
                  "tags": ["for", "step"]
                }
              ]
            },
            {
              "topicId": 1204,
              "title": "while / do-while Döngüsü",
              "summary": "while ve do-while döngüleri, koşul doğru olduğu sürece çalışan kontrol yapılarıdır. while döngüsünde koşul başta kontrol edilirken, do-while döngüsünde döngü en az bir kez çalışır.",
              "content": "## while ve do-while Döngüsü\n\nKotlin'de **while döngüsü**, koşul doğru olduğu sürece çalışır. Koşul döngünün başında kontrol edilir.\n\n**do-while döngüsü** ise koşulu sonda kontrol eder. Bu sayede döngü bloğu **en az bir kez** çalıştırılır.\n\nBu döngüler genellikle tekrar sayısı önceden bilinmeyen durumlarda, kullanıcıdan veri alma, API'den cevap bekleme gibi senaryolarda kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Basit while Döngüsü",
                  "code": "var i = 1\n\nwhile (i <= 5) {\n    println(i)\n    i++\n}",
                  "explanation": "Koşul doğru olduğu sürece döngü çalışır."
                },
                {
                  "title": "Yanlış Koşulda while",
                  "code": "var x = 10\n\nwhile (x < 5) {\n    println(x)\n}",
                  "explanation": "Koşul baştan false olduğu için döngü hiç çalışmaz."
                },
                {
                  "title": "do-while Döngüsü",
                  "code": "var y = 10\n\ndo {\n    println(y)\n} while (y < 5)",
                  "explanation": "Koşul false olsa bile do-while en az bir kez çalışır."
                },
                {
                  "title": "Kullanıcıdan Veri Alma Senaryosu",
                  "code": "var password: String\n\ndo {\n    password = readLine() ?: \"\"\n} while (password.length < 6)",
                  "explanation": "Şifre en az 6 karakter olana kadar döngü devam eder."
                }
              ],
              "keyPoints": [
                "while döngüsünde koşul başta kontrol edilir",
                "do-while döngüsü en az bir kez çalışır",
                "Tekrar sayısı bilinmeyen durumlar için uygundur",
                "Yanlış koşulda while hiç çalışmayabilir",
                "Sonsuz döngülere dikkat edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 120401,
                  "question": "while döngüsünün temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "En az bir kez çalışır",
                    "Koşul sonda kontrol edilir",
                    "Koşul doğru olduğu sürece çalışır",
                    "Sadece sayılarla çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "while döngüsü koşul true olduğu sürece çalışır.",
                  "tags": ["while"]
                },
                {
                  "questionId": 120402,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "var i = 5\n\nwhile (i < 3) {\n    println(i)\n}",
                  "difficulty": "easy",
                  "options": [
                    "5",
                    "3",
                    "Hiçbir çıktı olmaz",
                    "Sonsuz döngü"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Koşul baştan false olduğu için döngü çalışmaz.",
                  "tags": ["while"]
                },
                {
                  "questionId": 120403,
                  "question": "do-while döngüsünün farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Koşul başta kontrol edilir",
                    "Sadece Boolean ile çalışır",
                    "En az bir kez çalışır",
                    "Sonsuz döngü oluşturur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "do-while koşuldan bağımsız olarak en az bir kez çalışır.",
                  "tags": ["do-while"]
                },
                {
                  "questionId": 120404,
                  "question": "Aşağıdaki kod kaç kez çalışır?",
                  "questionType": "multiple_choice",
                  "code": "var x = 0\n\ndo {\n    x++\n} while (x < 3)",
                  "difficulty": "medium",
                  "options": [
                    "1",
                    "2",
                    "3",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "x değeri 0,1,2 iken döngü çalışır. Toplam 3 kez.",
                  "tags": ["do-while"]
                },
                {
                  "questionId": 120405,
                  "question": "Sonsuz döngüye sebep olan durum hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Koşulun hiç güncellenmemesi",
                    "Koşulun false olması",
                    "Koşulun başta kontrol edilmesi",
                    "do-while kullanılması"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Koşul değişmezse döngü sonsuza kadar devam edebilir.",
                  "tags": ["while", "do-while"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 13001,
            "question": "Kotlin'de if yapısı hakkında aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece koşul kontrolü için kullanılır, değer döndüremez",
              "Sadece Boolean döndürür",
              "Bir ifade (expression) olarak değer döndürebilir",
              "Sadece Java uyumluluğu için vardır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de if bir expression'dır ve bir değer döndürebilir.",
            "tags": ["if", "else"]
          },
          {
            "questionId": 13002,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val x = 10\nval result = if (x > 5) \"Büyük\" else \"Küçük\"\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "Küçük",
              "Büyük",
              "true",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "x değeri 5'ten büyük olduğu için if bloğu çalışır ve \"Büyük\" yazdırılır.",
            "tags": ["if", "else"]
          },
          {
            "questionId": 13003,
            "question": "Kotlin'de when yapısı için aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece switch yerine kullanılır",
              "Sadece Int tipleriyle çalışır",
              "Hem koşul hem değer döndürebilir",
              "Sadece Boolean döndürür"
            ],
            "correctAnswerIndex": 2,
            "explanation": "when, Kotlin'de güçlü bir kontrol yapısıdır ve expression olarak değer döndürebilir.",
            "tags": ["when"]
          },
          {
            "questionId": 13004,
            "question": "Aşağıdaki when bloğunun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val day = 3\nval result = when(day) {\n    1 -> \"Pazartesi\"\n    2 -> \"Salı\"\n    3 -> \"Çarşamba\"\n    else -> \"Bilinmiyor\"\n}\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "Salı",
              "Çarşamba",
              "Pazartesi",
              "Bilinmiyor"
            ],
            "correctAnswerIndex": 1,
            "explanation": "day değeri 3 olduğu için when bloğunda \"Çarşamba\" çalışır.",
            "tags": ["when"]
          },
          {
            "questionId": 13005,
            "question": "Aşağıdaki for döngüsü kaç kez çalışır?",
            "questionType": "multiple_choice",
            "code": "for (i in 1..5) {\n    println(i)\n}",
            "difficulty": "easy",
            "options": [
              "4",
              "5",
              "6",
              "Sonsuz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "1..5 aralığı her iki sınırı da dahil eder, döngü 5 kez çalışır.",
            "tags": ["for"]
          },
          {
            "questionId": 13006,
            "question": "Kotlin'de aşağıdaki aralıklardan hangisi 5 değerini içermez?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "1..5",
              "1 until 5",
              "5 downTo 1",
              "1..10"
            ],
            "correctAnswerIndex": 1,
            "explanation": "until üst sınırı dahil etmez, bu nedenle 5 değeri aralığa dahil değildir.",
            "tags": ["for", "range"]
          },
          {
            "questionId": 13007,
            "question": "Aşağıdaki while döngüsü ile ilgili hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "En az bir kez çalışır",
              "Koşul sağlanmazsa hiç çalışmaz",
              "Sadece Int ile çalışır",
              "for döngüsünden daha hızlıdır"
            ],
            "correctAnswerIndex": 1,
            "explanation": "while döngüsünde koşul başta kontrol edilir, koşul false ise döngü hiç çalışmaz.",
            "tags": ["while"]
          },
          {
            "questionId": 13008,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "var i = 0\nwhile (i < 3) {\n    print(i)\n    i++\n}",
            "difficulty": "easy",
            "options": [
              "012",
              "123",
              "03",
              "Sonsuz döngü"
            ],
            "correctAnswerIndex": 0,
            "explanation": "i değeri 0'dan başlayarak 3'e kadar artırılır ve ekrana 012 yazdırılır.",
            "tags": ["while"]
          },
          {
            "questionId": 13009,
            "question": "Kotlin'de if-else yerine when kullanmanın avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Daha hızlı çalışır",
              "Daha az bellek kullanır",
              "Daha okunabilir ve genişletilebilir yapı sunar",
              "Sadece Boolean destekler"
            ],
            "correctAnswerIndex": 2,
            "explanation": "when, çoklu koşullarda kodun okunabilirliğini ve bakımını artırır.",
            "tags": ["when", "if"]
          },
          {
            "questionId": 13010,
            "question": "Kotlin'de for döngüsünde index'e erişmek için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "withIndex()",
              "getIndex()",
              "indexOf()",
              "forEachIndex()"
            ],
            "correctAnswerIndex": 0,
            "explanation": "withIndex() fonksiyonu, eleman ve index bilgisine birlikte erişim sağlar.",
            "tags": ["for", "index"]
          }
        ]
        },
        {
          "sectionId": 104,
          "sectionTitle": "Koleksiyonlar",
          "sectionDescription": "",
          "order": 4,
          "topics": [
            {
              "topicId": 1301,
              "title": "Array",
              "summary": "Array, aynı türden birden fazla veriyi tek bir değişken altında saklamaya yarayan sabit boyutlu bir veri yapısıdır. Kotlin'de Array'ler index mantığıyla çalışır ve elemanlara 0'dan başlayarak erişilir.",
              "content": "## Array (Dizi)\n\nArray, Kotlin'de belirli sayıda ve **aynı türde** veriyi saklamak için kullanılır. Array'lerin boyutu tanımlandıktan sonra değiştirilemez.\n\nHer eleman bir index numarasına sahiptir ve index'ler **0'dan başlar**. Array'ler genellikle sabit veri listeleri veya performansın önemli olduğu durumlarda tercih edilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Array Tanımlama",
                  "code": "val numbers = arrayOf(1, 2, 3, 4, 5)",
                  "explanation": "Integer türünde bir Array oluşturulur."
                },
                {
                  "title": "Index ile Erişim",
                  "code": "val cities = arrayOf(\"Ankara\", \"İstanbul\", \"İzmir\")\nprintln(cities[0])",
                  "explanation": "Array'in ilk elemanına erişilir."
                },
                {
                  "title": "Array Elemanı Güncelleme",
                  "code": "val ages = arrayOf(18, 20, 25)\nages[1] = 21",
                  "explanation": "Index kullanılarak eleman güncellenebilir."
                },
                {
                  "title": "Array Boyutu",
                  "code": "val names = arrayOf(\"Ali\", \"Veli\")\nprintln(names.size)",
                  "explanation": "Array içindeki eleman sayısını verir."
                },
                {
                  "title": "Döngü ile Array Gezme",
                  "code": "val scores = arrayOf(60, 70, 80)\nfor (score in scores) {\n    println(score)\n}",
                  "explanation": "for döngüsü ile tüm elemanlar gezilir."
                }
              ],
              "keyPoints": [
                "Array sabit boyutludur",
                "Aynı türden veriler saklanır",
                "Index'ler 0'dan başlar",
                "size özelliği eleman sayısını verir",
                "Elemanlar değiştirilebilir ama boyut değiştirilemez"
              ],
              "questions": [
                {
                  "questionId": 130101,
                  "question": "Array nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Farklı türden verileri tutan yapı",
                    "Sabit boyutlu veri koleksiyonu",
                    "Sonsuz eleman tutan liste",
                    "Sadece String tutan yapı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Array sabit boyutlu ve aynı türden verileri tutar.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130102,
                  "question": "Array index'leri kaçtan başlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "1",
                    "-1",
                    "0",
                    "2"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de Array index'leri 0'dan başlar.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130103,
                  "question": "Aşağıdaki kodun çıktısı nedir?",
                  "questionType": "multiple_choice",
                  "code": "val arr = arrayOf(10, 20, 30)\nprintln(arr[1])",
                  "difficulty": "easy",
                  "options": [
                    "10",
                    "20",
                    "30",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Index 1 ikinci elemanı temsil eder.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130104,
                  "question": "Array ile ilgili hangisi yanlıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Boyutu sonradan değiştirilebilir",
                    "Elemanlara index ile erişilir",
                    "Aynı türde veri tutar",
                    "size özelliği vardır"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Array'in boyutu tanımlandıktan sonra değiştirilemez.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130105,
                  "question": "Array hangi durumda daha uygundur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Eleman sayısı sürekli değişiyorsa",
                    "Sabit ve küçük veri listesi varsa",
                    "Farklı türler birlikte tutulacaksa",
                    "Dinamik ekleme çıkarma yapılacaksa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Array sabit boyutlu olduğu için değişmeyen veri listelerinde uygundur.",
                  "tags": ["array"]
                }
              ]
            },
            {
              "topicId": 1302,
              "title": "List ve MutableList",
              "summary": "List ve MutableList, Kotlin'de sıralı veri koleksiyonlarını temsil eder. List değiştirilemez (immutable) bir yapı sunarken, MutableList eleman ekleme, silme ve güncelleme gibi işlemlere izin verir.",
              "content": "## List ve MutableList\n\nKotlin'de List ve MutableList, aynı türden birden fazla veriyi sıralı şekilde saklamak için kullanılır.\n\n- **List**: Değiştirilemez (immutable). Eleman ekleme, silme veya güncelleme yapılamaz.\n- **MutableList**: Değiştirilebilir (mutable). Eleman ekleme, silme ve güncelleme yapılabilir.\n\nBest practice olarak, eğer koleksiyon değişmeyecekse List kullanılması önerilir. Bu yaklaşım kod güvenliğini ve okunabilirliği artırır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "List Tanımlama",
                  "code": "val names = listOf(\"Ali\", \"Veli\", \"Ayşe\")",
                  "explanation": "Değiştirilemez bir List oluşturulur."
                },
                {
                  "title": "MutableList Tanımlama",
                  "code": "val numbers = mutableListOf(1, 2, 3)",
                  "explanation": "Değiştirilebilir bir MutableList oluşturulur."
                },
                {
                  "title": "MutableList'e Eleman Ekleme",
                  "code": "val cities = mutableListOf(\"Ankara\", \"İstanbul\")\ncities.add(\"İzmir\")",
                  "explanation": "MutableList'e add() metodu ile eleman eklenir."
                },
                {
                  "title": "MutableList Eleman Güncelleme",
                  "code": "val ages = mutableListOf(18, 20, 25)\nages[1] = 21",
                  "explanation": "Index kullanılarak eleman güncellenebilir."
                },
                {
                  "title": "List Üzerinde Döngü",
                  "code": "val scores = listOf(60, 70, 80)\nfor (score in scores) {\n    println(score)\n}",
                  "explanation": "for döngüsü ile List elemanları gezilir."
                }
              ],
              "keyPoints": [
                "List immutable'dır, değiştirilemez",
                "MutableList mutable'dır, değiştirilebilir",
                "Index'ler 0'dan başlar",
                "List güvenli ve okunabilir kod sağlar",
                "Değişmeyecek koleksiyonlar için List tercih edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 130201,
                  "question": "List ve MutableList arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "List daha hızlıdır",
                    "MutableList sadece String tutar",
                    "List değiştirilemez, MutableList değiştirilebilir",
                    "Aralarında fark yoktur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "List immutable, MutableList mutable bir koleksiyondur.",
                  "tags": ["list", "mutablelist"]
                },
                {
                  "questionId": 130202,
                  "question": "Aşağıdakilerden hangisi eleman eklemeye izin verir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "listOf",
                    "List",
                    "MutableList",
                    "Array"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "MutableList eleman ekleme ve silmeye izin verir.",
                  "tags": ["mutablelist"]
                },
                {
                  "questionId": 130203,
                  "question": "Aşağıdaki kodda hangi satır hata verir?",
                  "questionType": "multiple_choice",
                  "code": "val list = listOf(1, 2, 3)\nlist.add(4)",
                  "difficulty": "medium",
                  "options": [
                    "Satır 1",
                    "Satır 2",
                    "İkisi de çalışır",
                    "Runtime hatası olur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "listOf ile oluşturulan List immutable olduğu için add() kullanılamaz.",
                  "tags": ["list"]
                },
                {
                  "questionId": 130204,
                  "question": "MutableList ile aşağıdakilerden hangisi yapılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Boyutunu değiştirmek",
                    "Sadece okuma yapmak",
                    "Sabit veri saklamak",
                    "Sadece compile-time'da kullanmak"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "MutableList eleman ekleme, silme ve güncellemeye izin verir.",
                  "tags": ["mutablelist"]
                },
                {
                  "questionId": 130205,
                  "question": "Best practice olarak hangisi önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her zaman MutableList kullanmak",
                    "Değişmeyecekse List kullanmak",
                    "Array yerine her zaman MutableList kullanmak",
                    "List kullanmamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Değişmeyecek koleksiyonlar için List kullanmak kod güvenliğini artırır.",
                  "tags": ["best-practice", "list"]
                }
              ]
            },
            {
              "topicId": 1303,
              "title": "Set",
              "summary": "Set, Kotlin'de benzersiz (unique) elemanlar tutan bir koleksiyon türüdür. Aynı elemandan birden fazla bulunmasına izin vermez ve genellikle tekrar eden verileri engellemek için kullanılır.",
              "content": "## Set\n\nSet, aynı türden benzersiz elemanları saklamak için kullanılan bir koleksiyondur.\n\n- **Set**: Değiştirilemez (immutable)\n- **MutableSet**: Değiştirilebilir (mutable)\n\nSet'lerde elemanların sırası garanti edilmez. Aynı değer birden fazla kez eklenmeye çalışılırsa sadece bir tanesi saklanır.\n\nTekrar eden verileri otomatik olarak filtrelemek için ideal bir yapıdır.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Set Tanımlama",
                  "code": "val numbers = setOf(1, 2, 3, 3, 4)",
                  "explanation": "Set tekrar eden elemanları otomatik olarak tekilleştirir."
                },
                {
                  "title": "MutableSet Tanımlama",
                  "code": "val cities = mutableSetOf(\"Ankara\", \"İstanbul\")",
                  "explanation": "Değiştirilebilir bir MutableSet oluşturulur."
                },
                {
                  "title": "MutableSet'e Eleman Ekleme",
                  "code": "val colors = mutableSetOf(\"Red\", \"Blue\")\ncolors.add(\"Green\")",
                  "explanation": "add() metodu ile yeni eleman eklenebilir."
                },
                {
                  "title": "Tekrar Eden Eleman Ekleme",
                  "code": "val set = mutableSetOf(1, 2, 3)\nset.add(2)\nprintln(set.size)",
                  "explanation": "Aynı eleman tekrar eklense bile Set içinde bir kez bulunur."
                },
                {
                  "title": "Set Üzerinde Döngü",
                  "code": "val fruits = setOf(\"Apple\", \"Banana\", \"Orange\")\nfor (fruit in fruits) {\n    println(fruit)\n}",
                  "explanation": "for döngüsü ile Set elemanları gezilebilir."
                }
              ],
              "keyPoints": [
                "Set benzersiz elemanlar tutar",
                "Aynı eleman Set içinde birden fazla kez bulunamaz",
                "Set immutable, MutableSet mutable'dır",
                "Eleman sırası garanti edilmez",
                "Tekrar eden verileri engellemek için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 130301,
                  "question": "Set koleksiyonunun temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sıralı elemanlar tutar",
                    "Tekrar eden elemanlara izin verir",
                    "Benzersiz elemanlar tutar",
                    "Sadece sayısal veri saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set aynı elemandan yalnızca bir tane tutar.",
                  "tags": ["set"]
                },
                {
                  "questionId": 130302,
                  "question": "Aşağıdakilerden hangisi değiştirilebilir Set oluşturur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "setOf",
                    "listOf",
                    "mutableSetOf",
                    "arrayOf"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "mutableSetOf ile MutableSet oluşturulur.",
                  "tags": ["mutableset"]
                },
                {
                  "questionId": 130303,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val set = setOf(1, 2, 2, 3)\nprintln(set.size)",
                  "difficulty": "medium",
                  "options": [
                    "2",
                    "3",
                    "4",
                    "Compile hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Set tekrar eden elemanları tekilleştirir, bu yüzden size 3 olur.",
                  "tags": ["set"]
                },
                {
                  "questionId": 130304,
                  "question": "Set kullanmanın en uygun olduğu senaryo hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sıralı veri gerektiğinde",
                    "Index ile erişim gerektiğinde",
                    "Tekrar eden verilerin engellenmesi gerektiğinde",
                    "Elemanların sürekli güncellendiği durumlarda"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set, tekrar eden elemanları otomatik olarak engeller.",
                  "tags": ["set", "use-case"]
                },
                {
                  "questionId": 130305,
                  "question": "Set koleksiyonları hakkında hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Set index kullanır",
                    "Set sıralı çalışır",
                    "Set tekrar eden elemanları tutmaz",
                    "Set sadece String saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set aynı elemanı birden fazla kez tutmaz.",
                  "tags": ["set"]
                }
              ]
            },
            {
              "topicId": 1304,
              "title": "Map",
              "summary": "Map, Kotlin'de anahtar-değer (key-value) mantığıyla çalışan bir koleksiyon türüdür. Her anahtar benzersizdir ve bir değere karşılık gelir. Verilere anahtar üzerinden hızlı erişim sağlar.",
              "content": "## Map\n\nMap, verileri anahtar (key) ve değer (value) çiftleri halinde saklar.\n\n- **Map**: Değiştirilemez (immutable)\n- **MutableMap**: Değiştirilebilir (mutable)\n\nMap'lerde anahtarlar benzersizdir. Aynı anahtar tekrar eklenirse eski değer güncellenir. Android geliştirmede JSON verileri, ayarlar ve cache işlemlerinde sıkça kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Map Tanımlama",
                  "code": "val ages = mapOf(\"Ahmet\" to 25, \"Mehmet\" to 30)",
                  "explanation": "mapOf ile değiştirilemez bir Map oluşturulur."
                },
                {
                  "title": "MutableMap Tanımlama",
                  "code": "val scores = mutableMapOf(\"Math\" to 90, \"Physics\" to 85)",
                  "explanation": "mutableMapOf ile değiştirilebilir bir Map oluşturulur."
                },
                {
                  "title": "Map'ten Veri Okuma",
                  "code": "val cities = mapOf(\"TR\" to \"Ankara\", \"FR\" to \"Paris\")\nprintln(cities[\"TR\"])",
                  "explanation": "Anahtar kullanılarak değere erişilir."
                },
                {
                  "title": "MutableMap'e Veri Ekleme",
                  "code": "val prices = mutableMapOf(\"Apple\" to 5)\nprices[\"Banana\"] = 3",
                  "explanation": "Yeni anahtar-değer çifti eklenir."
                },
                {
                  "title": "Aynı Anahtarla Güncelleme",
                  "code": "val map = mutableMapOf(\"A\" to 1)\nmap[\"A\"] = 2\nprintln(map[\"A\"])",
                  "explanation": "Aynı anahtar tekrar eklenirse değer güncellenir."
                }
              ],
              "keyPoints": [
                "Map key-value yapısı ile çalışır",
                "Anahtarlar benzersizdir",
                "Map immutable, MutableMap mutable'dır",
                "Anahtar ile hızlı veri erişimi sağlar",
                "Android'de JSON ve ayar verilerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 130401,
                  "question": "Map koleksiyonunun temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sıralı elemanlar tutar",
                    "Index ile erişim sağlar",
                    "Anahtar-değer yapısıyla çalışır",
                    "Tek tip veri saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map, anahtar-değer (key-value) yapısına sahiptir.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130402,
                  "question": "Aşağıdakilerden hangisi değiştirilebilir Map oluşturur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "mapOf",
                    "listOf",
                    "mutableMapOf",
                    "setOf"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "mutableMapOf ile MutableMap oluşturulur.",
                  "tags": ["mutablemap"]
                },
                {
                  "questionId": 130403,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val map = mapOf(\"A\" to 1, \"A\" to 2)\nprintln(map.size)",
                  "difficulty": "medium",
                  "options": [
                    "1",
                    "2",
                    "Compile hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Map anahtarları benzersizdir. Aynı anahtar tekrar kullanıldığında son değer geçerli olur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130404,
                  "question": "Map'ten veri okumak için hangisi kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "map.getKey()",
                    "map.value()",
                    "map[key]",
                    "map.indexOf()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map'te değerler anahtar kullanılarak map[key] şeklinde okunur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130405,
                  "question": "Map kullanımı için en uygun senaryo hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sıralı veri gerektiğinde",
                    "Index ile erişim gerektiğinde",
                    "Anahtar ile hızlı erişim gerektiğinde",
                    "Tekrar eden veriler gerektiğinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map, anahtar üzerinden hızlı erişim gereken durumlarda kullanılır.",
                  "tags": ["map", "use-case"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 14001,
            "question": "Kotlin'de Array ile List arasındaki temel fark nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Array immutable, List mutable'dır",
              "Array sabit boyutludur, List dinamik boyutludur",
              "Array sadece Int tutar",
              "List sadece String tutar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Array sabit boyutludur, List ise dinamik olarak büyüyüp küçülebilir.",
            "tags": ["array", "list"]
          },
          {
            "questionId": 14002,
            "question": "Aşağıdaki Array tanımının çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val numbers = arrayOf(1, 2, 3)\nprintln(numbers[1])",
            "difficulty": "easy",
            "options": [
              "1",
              "2",
              "3",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Array indexleri 0'dan başlar, index 1 değeri 2'dir.",
            "tags": ["array"]
          },
          {
            "questionId": 14003,
            "question": "Kotlin'de List ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Eleman eklenip çıkarılabilir",
              "Sadece MutableList ile eleman eklenebilir",
              "Index yapısı yoktur",
              "Sadece Int tutar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "List immutable'dır, eleman ekleme/çıkarma işlemleri MutableList ile yapılır.",
            "tags": ["list", "mutablelist"]
          },
          {
            "questionId": 14004,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val list = mutableListOf(10, 20)\nlist.add(30)\nprintln(list.size)",
            "difficulty": "easy",
            "options": [
              "2",
              "3",
              "30",
              "Hata verir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "MutableList'e eleman eklenebilir, toplam eleman sayısı 3 olur.",
            "tags": ["mutablelist"]
          },
          {
            "questionId": 14005,
            "question": "Set koleksiyonunun temel özelliği nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Index yapısı vardır",
              "Aynı elemandan birden fazla olabilir",
              "Tekrarlı elemanlara izin vermez",
              "Sıralı çalışmak zorundadır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Set, duplicate (tekrarlı) elemanlara izin vermez.",
            "tags": ["set"]
          },
          {
            "questionId": 14006,
            "question": "Aşağıdaki Set tanımının çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val set = setOf(1, 2, 2, 3)\nprintln(set.size)",
            "difficulty": "medium",
            "options": [
              "4",
              "3",
              "2",
              "Hata verir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Set tekrarlı elemanları kabul etmez, sadece 1,2,3 tutulur.",
            "tags": ["set"]
          },
          {
            "questionId": 14007,
            "question": "Map koleksiyonunda veriler nasıl tutulur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Index - Value",
              "Key - Value",
              "Value - Value",
              "Key - Key"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Map yapısı key-value (anahtar-değer) mantığıyla çalışır.",
            "tags": ["map"]
          },
          {
            "questionId": 14008,
            "question": "Aşağıdaki Map kullanımında ekrana ne yazdırılır?",
            "questionType": "multiple_choice",
            "code": "val map = mapOf(\"a\" to 1, \"b\" to 2)\nprintln(map[\"b\"])",
            "difficulty": "easy",
            "options": [
              "a",
              "1",
              "2",
              "null"
            ],
            "correctAnswerIndex": 2,
            "explanation": "\"b\" anahtarının karşılığı 2'dir.",
            "tags": ["map"]
          },
          {
            "questionId": 14009,
            "question": "MutableMap ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "code": null,
            "options": [
              "Yeni key-value eklenemez",
              "Sadece okunabilir",
              "Key-value ekleme ve silme yapılabilir",
              "Index kullanır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "MutableMap, Map'in değiştirilebilir versiyonudur.",
            "tags": ["map", "mutablemap"]
          },
          {
            "questionId": 14010,
            "question": "Aşağıdaki koleksiyonlardan hangisi benzersiz veri tutmak için en uygundur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Array",
              "List",
              "Set",
              "Map"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Set yapısı duplicate elemanları otomatik olarak engeller.",
            "tags": ["set", "collections"]
          }
        ]
        },
        {
          "sectionId": 105,
          "sectionTitle": "Fonksiyonlar ve Null Safety",
          "sectionDescription": "",
          "order": 5,
          "topics": [
            {
              "topicId": 1401,
              "title": "Fonksiyonlar",
              "summary": "Fonksiyonlar, belirli bir işi yapmak için yazılan ve gerektiğinde tekrar tekrar çağrılabilen kod bloklarıdır. Kotlin'de fonksiyonlar daha okunabilir, kısa ve güvenli bir yapı sunar.",
              "content": "## Fonksiyonlar\n\nFonksiyonlar, kod tekrarını önlemek ve uygulamayı daha düzenli hale getirmek için kullanılır.\n\nKotlin'de fonksiyonlar `fun` anahtar kelimesi ile tanımlanır. Fonksiyonlar parametre alabilir, değer döndürebilir veya sadece işlem yapabilir.\n\nKotlin'in kısa söz dizimi sayesinde tek satırlık fonksiyonlar sade bir şekilde yazılabilir. Fonksiyonlar Android geliştirmede UI işlemleri, veri işleme ve iş mantığını ayırmak için sıkça kullanılır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Parametresiz Fonksiyon",
                  "code": "fun sayHello() {\n    println(\"Merhaba Kotlin\")\n}",
                  "explanation": "Parametre almayan ve sadece işlem yapan basit bir fonksiyon."
                },
                {
                  "title": "Parametre Alan Fonksiyon",
                  "code": "fun greet(name: String) {\n    println(\"Merhaba $name\")\n}",
                  "explanation": "Fonksiyon dışarıdan parametre alabilir."
                },
                {
                  "title": "Geriye Değer Döndüren Fonksiyon",
                  "code": "fun sum(a: Int, b: Int): Int {\n    return a + b\n}",
                  "explanation": "Fonksiyon hesaplama yapıp bir değer döndürebilir."
                },
                {
                  "title": "Tek Satırlık Fonksiyon",
                  "code": "fun multiply(a: Int, b: Int): Int = a * b",
                  "explanation": "Tek satırlık fonksiyonlarda return yazmaya gerek yoktur."
                },
                {
                  "title": "Fonksiyon Çağırma",
                  "code": "val result = sum(5, 3)\nprintln(result)",
                  "explanation": "Fonksiyon çağrılarak dönen değer kullanılabilir."
                }
              ],
              "keyPoints": [
                "Fonksiyonlar fun anahtar kelimesi ile tanımlanır",
                "Parametre alabilir veya almayabilir",
                "Geriye değer döndürebilir",
                "Kod tekrarını önler",
                "Android projelerinde iş mantığını ayırmak için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 140101,
                  "question": "Kotlin'de fonksiyon tanımlamak için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "function",
                    "def",
                    "fun",
                    "method"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de fonksiyonlar fun anahtar kelimesi ile tanımlanır.",
                  "tags": ["functions", "basics"]
                },
                {
                  "questionId": 140102,
                  "question": "Bir fonksiyonun geriye değer döndürmesi için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "println kullanılmalı",
                    "return kullanılmalı",
                    "val kullanılmalı",
                    "var kullanılmalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlar return anahtar kelimesi ile değer döndürür.",
                  "tags": ["functions", "return"]
                },
                {
                  "questionId": 140103,
                  "question": "Aşağıdaki fonksiyonlardan hangisi doğru tanımlanmıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "fun sum(a, b): Int",
                    "fun sum(a: Int, b: Int): Int = a + b",
                    "function sum(a: Int, b: Int)",
                    "def sum(a: Int, b: Int)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de parametre tipleri belirtilmeli ve fun anahtar kelimesi kullanılmalıdır.",
                  "tags": ["functions", "syntax"]
                },
                {
                  "questionId": 140104,
                  "question": "Tek satırlık fonksiyonlarda hangisi kullanılmaz?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "return",
                    "fun",
                    "Parametreler",
                    "Dönüş tipi"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Tek satırlık fonksiyonlarda return anahtar kelimesi kullanılmaz.",
                  "tags": ["functions"]
                },
                {
                  "questionId": 140105,
                  "question": "Fonksiyonların en büyük faydası nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kod boyutunu artırmak",
                    "Kod tekrarını azaltmak",
                    "Daha fazla değişken oluşturmak",
                    "Sadece çıktı almak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlar kod tekrarını azaltır ve düzenli kod yazılmasını sağlar.",
                  "tags": ["functions", "best-practice"]
                }
              ]
            },
            {
              "topicId": 1402,
              "title": "Parametreler ve Geri Dönüş Tipleri",
              "summary": "Parametreler, fonksiyonlara dışarıdan veri göndermeyi sağlar. Geri dönüş tipi ise fonksiyonun yaptığı işlemin sonucunda döndürdüğü veri tipini belirtir. Kotlin'de fonksiyonlar farklı parametreler alabilir ve farklı türlerde değerler döndürebilir.",
              "content": "## Parametreler ve Geri Dönüş Tipleri\n\nFonksiyonlar, dışarıdan veri alabilmek için parametre kullanır. Parametrelerin türleri açıkça belirtilmelidir.\n\nGeri dönüş tipi, fonksiyonun yaptığı işlem sonucunda hangi türde bir değer döndüreceğini ifade eder. Eğer fonksiyon bir değer döndürmüyorsa dönüş tipi `Unit` olarak kabul edilir.\n\nKotlin'de varsayılan parametreler, isimli parametreler ve Unit dönüş tipi gibi modern özellikler bulunmaktadır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Tek Parametreli Fonksiyon",
                  "code": "fun printAge(age: Int) {\n    println(age)\n}",
                  "explanation": "Fonksiyon tek bir parametre alabilir."
                },
                {
                  "title": "Birden Fazla Parametre",
                  "code": "fun sum(a: Int, b: Int): Int {\n    return a + b\n}",
                  "explanation": "Fonksiyon birden fazla parametre alabilir."
                },
                {
                  "title": "Unit Dönüş Tipi",
                  "code": "fun showMessage(message: String): Unit {\n    println(message)\n}",
                  "explanation": "Değer döndürmeyen fonksiyonların dönüş tipi Unit'tir."
                },
                {
                  "title": "Varsayılan Parametre",
                  "code": "fun greet(name: String = \"Misafir\") {\n    println(\"Merhaba $name\")\n}",
                  "explanation": "Parametreye varsayılan değer atanabilir."
                },
                {
                  "title": "İsimli Parametre Kullanımı",
                  "code": "greet(name = \"Ahmet\")",
                  "explanation": "Parametreler isimleriyle çağrılabilir."
                }
              ],
              "keyPoints": [
                "Parametreler fonksiyonlara veri aktarır",
                "Parametre tipleri belirtilmelidir",
                "Fonksiyonlar değer döndürebilir veya Unit döndürür",
                "Varsayılan parametreler kullanılabilir",
                "İsimli parametreler okunabilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 140201,
                  "question": "Fonksiyonlara dışarıdan veri göndermek için ne kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Return",
                    "Parametre",
                    "Variable",
                    "Unit"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlara veri parametreler aracılığıyla gönderilir.",
                  "tags": ["parameters"]
                },
                {
                  "questionId": 140202,
                  "question": "Değer döndürmeyen fonksiyonların dönüş tipi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Void",
                    "Null",
                    "Unit",
                    "None"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de değer döndürmeyen fonksiyonların dönüş tipi Unit'tir.",
                  "tags": ["unit"]
                },
                {
                  "questionId": 140203,
                  "question": "Aşağıdaki fonksiyonlardan hangisi varsayılan parametre kullanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "fun test(a: Int)",
                    "fun test(a: Int = 5)",
                    "fun test(a)",
                    "fun test(): Int"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Varsayılan parametre, parametreye başlangıç değeri verilerek tanımlanır.",
                  "tags": ["default-parameters"]
                },
                {
                  "questionId": 140204,
                  "question": "İsimli parametrelerin en büyük avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performansı artırmak",
                    "Hafıza kullanımını azaltmak",
                    "Kod okunabilirliğini artırmak",
                    "Daha az parametre kullanmak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "İsimli parametreler, fonksiyon çağrılarını daha okunabilir yapar.",
                  "tags": ["named-parameters"]
                },
                {
                  "questionId": 140205,
                  "question": "Bir fonksiyonun dönüş tipini belirtmek için hangi sembol kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "=",
                    "->",
                    ":",
                    "::"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Fonksiyon dönüş tipi iki nokta (:) ile belirtilir.",
                  "tags": ["return-type"]
                }
              ]
            },
            {
              "topicId": 1403,
              "title": "Null Safety",
              "summary": "Null Safety, Kotlin'in null referans hatalarını (NullPointerException) önlemek için sunduğu bir güvenlik mekanizmasıdır. Kotlin'de bir değişken varsayılan olarak null olamaz, bu da uygulamaların daha güvenli çalışmasını sağlar.",
              "content": "## Null Safety\n\nKotlin'de değişkenler varsayılan olarak null olamaz. Eğer bir değişkenin null değer alabilmesini istiyorsak, tipinin sonuna `?` eklememiz gerekir.\n\nKotlin, null değerlerle güvenli çalışmak için çeşitli operatörler sunar:\n\n- `?` : Nullable değişken\n- `?.` : Safe call (güvenli çağrı)\n- `?:` : Elvis operatörü (varsayılan değer)\n- `!!` : Not-null assertion (risklidir)\n\nBu yapı sayesinde NullPointerException hataları büyük ölçüde engellenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Nullable Değişken",
                  "code": "var name: String? = null",
                  "explanation": "String? ifadesi değişkenin null olabileceğini belirtir."
                },
                {
                  "title": "Safe Call (?.)",
                  "code": "val length = name?.length",
                  "explanation": "Eğer name null ise hata vermez, sonuç null olur."
                },
                {
                  "title": "Elvis Operatörü (?:)",
                  "code": "val length = name?.length ?: 0",
                  "explanation": "Eğer name null ise varsayılan olarak 0 atanır."
                },
                {
                  "title": "Not-Null Assertion (!!)",
                  "code": "val length = name!!.length",
                  "explanation": "name null ise uygulama çöker. Dikkatli kullanılmalıdır."
                },
                {
                  "title": "if ile Null Kontrolü",
                  "code": "if (name != null) {\n    println(name.length)\n}",
                  "explanation": "Klasik null kontrolü yapılabilir."
                }
              ],
              "keyPoints": [
                "Kotlin'de değişkenler varsayılan olarak null olamaz",
                "Nullable değişkenler ? ile tanımlanır",
                "Safe call (?.) NullPointerException'ı önler",
                "Elvis operatörü varsayılan değer sağlar",
                "!! operatörü risklidir ve önerilmez"
              ],
              "questions": [
                {
                  "questionId": 140301,
                  "question": "Kotlin'de bir değişkenin null olabilmesi için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val kullanmak",
                    "var kullanmak",
                    "Tipin sonuna ? eklemek",
                    "!! kullanmak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Nullable değişkenler ? ile tanımlanır.",
                  "tags": ["null-safety"]
                },
                {
                  "questionId": 140302,
                  "question": "Safe call operatörü hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "!!",
                    "?:",
                    "?.",
                    "::"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "?. operatörü null güvenli çağrı sağlar.",
                  "tags": ["safe-call"]
                },
                {
                  "questionId": 140303,
                  "question": "Aşağıdaki kodda name null ise length değeri ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val name: String? = null\nval length = name?.length ?: 0",
                  "difficulty": "medium",
                  "options": [
                    "null",
                    "Hata verir",
                    "0",
                    "1"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Elvis operatörü sayesinde null durumda 0 atanır.",
                  "tags": ["elvis-operator"]
                },
                {
                  "questionId": 140304,
                  "question": "!! operatörü ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Null kontrolü yapar",
                    "Null ise varsayılan değer atar",
                    "Null değilse çalışır, null ise crash olur",
                    "Her zaman güvenlidir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "!! operatörü null ise NullPointerException fırlatır.",
                  "tags": ["not-null-assertion"]
                },
                {
                  "questionId": 140305,
                  "question": "Null Safety'nin temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kod yazmayı zorlaştırmak",
                    "Daha fazla değişken oluşturmak",
                    "NullPointerException hatalarını önlemek",
                    "Performansı düşürmek"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Null Safety, NullPointerException hatalarını minimize eder.",
                  "tags": ["null-safety", "best-practice"]
                }
              ]
            },
            {
              "topicId": 1404,
              "title": "lateinit ve lazy",
              "summary": "lateinit ve lazy, Kotlin'de değişkenlerin geç (sonradan) başlatılmasını sağlayan iki farklı yaklaşımdır. lateinit mutable değişkenler için kullanılırken, lazy immutable değişkenler için kullanılır.",
              "content": "## lateinit ve lazy\n\nKotlin'de normalde bir değişken tanımlandığında hemen başlatılmalıdır. Ancak bazı durumlarda değişkenin değeri daha sonra atanır.\n\nBu durumlar için Kotlin iki çözüm sunar:\n\n- **lateinit**: var ile kullanılan, daha sonra başlatılacak değişkenler için\n- **lazy**: val ile kullanılan, ilk erişimde başlatılan değişkenler için\n\nAndroid geliştirmede özellikle ViewBinding, Activity ve Fragment yapılarında sıkça kullanılır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "lateinit Kullanımı",
                  "code": "lateinit var name: String\n\nfun initName() {\n    name = \"Ahmet\"\n}",
                  "explanation": "lateinit, var ile kullanılır ve sonradan değer atanır."
                },
                {
                  "title": "lateinit Kontrolü",
                  "code": "if (::name.isInitialized) {\n    println(name)\n}",
                  "explanation": "lateinit değişkenin başlatılıp başlatılmadığı kontrol edilebilir."
                },
                {
                  "title": "lazy Kullanımı",
                  "code": "val age: Int by lazy {\n    25\n}",
                  "explanation": "lazy, değişken ilk kez kullanıldığında çalışır."
                },
                {
                  "title": "lazy Çalışma Mantığı",
                  "code": "val message: String by lazy {\n    println(\"Initialized\")\n    \"Merhaba\"\n}",
                  "explanation": "lazy blok yalnızca ilk erişimde çalışır."
                },
                {
                  "title": "Android Örneği (ViewBinding)",
                  "code": "private lateinit var binding: ActivityMainBinding",
                  "explanation": "Android'de ViewBinding genellikle lateinit ile tanımlanır."
                }
              ],
              "keyPoints": [
                "lateinit sadece var ile kullanılır",
                "lazy sadece val ile kullanılır",
                "lateinit primitive tiplerde kullanılamaz",
                "lazy ilk erişimde çalışır",
                "Android'de ViewBinding için yaygın olarak kullanılır"
              ],
              "questions": [
                {
                  "questionId": 140401,
                  "question": "lateinit hangi değişken türü ile kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val",
                    "const",
                    "var",
                    "let"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lateinit sadece var ile kullanılabilir.",
                  "tags": ["lateinit"]
                },
                {
                  "questionId": 140402,
                  "question": "lazy hangi durumda çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Uygulama başlarken",
                    "Değişken tanımlandığında",
                    "İlk erişildiğinde",
                    "Fonksiyon çağrıldığında"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lazy blok ilk erişimde çalışır.",
                  "tags": ["lazy"]
                },
                {
                  "questionId": 140403,
                  "question": "Aşağıdakilerden hangisi lazy için doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "var ile kullanılır",
                    "Null olabilir",
                    "Sadece val ile kullanılır",
                    "Her zaman hemen çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lazy sadece val ile kullanılır.",
                  "tags": ["lazy"]
                },
                {
                  "questionId": 140404,
                  "question": "lateinit ile ilgili hangisi yanlıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "var ile kullanılır",
                    "Primitive tiplerde kullanılabilir",
                    "Sonradan değer atanır",
                    "Null Safety ile ilişkilidir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "lateinit primitive tiplerde (Int, Boolean vb.) kullanılamaz.",
                  "tags": ["lateinit"]
                },
                {
                  "questionId": 140405,
                  "question": "Android'de ViewBinding genellikle nasıl tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val binding = ActivityMainBinding()",
                    "lateinit var binding",
                    "val binding by lazy",
                    "var binding?"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewBinding genellikle lateinit var ile tanımlanır.",
                  "tags": ["android", "viewbinding"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 16001,
            "question": "Kotlin'de nullable bir değişken nasıl tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "String name",
              "String! name",
              "String? name",
              "nullable String name"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de nullable değişkenler '?' işareti ile tanımlanır.",
            "tags": ["null_safety", "nullable"]
          },
          {
            "questionId": 16002,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "fun printLength(text: String?) {\n    println(text?.length)\n}\n\nprintLength(null)",
            "difficulty": "easy",
            "options": [
              "0",
              "null",
              "Compile-time hatası",
              "Runtime hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe call (?.) kullanıldığı için null durumda hata oluşmaz ve null yazdırılır.",
            "tags": ["safe_call", "null_safety"]
          },
          {
            "questionId": 16003,
            "question": "Elvis operatörü (?:) ne amaçla kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Null kontrolü yapmak",
              "Exception fırlatmak",
              "Null durumunda varsayılan değer vermek",
              "Tip dönüşümü yapmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Elvis operatörü, ifade null ise alternatif bir değer döndürmek için kullanılır.",
            "tags": ["elvis_operator", "null_safety"]
          },
          {
            "questionId": 16004,
            "question": "Aşağıdaki kod çalıştığında ne olur?",
            "questionType": "multiple_choice",
            "code": "val name: String? = null\nprintln(name!!)",
            "difficulty": "medium",
            "options": [
              "null yazdırılır",
              "Boş string yazdırılır",
              "Compile-time hatası",
              "NullPointerException"
            ],
            "correctAnswerIndex": 3,
            "explanation": "!! operatörü null olmayan varsayımı yapar. Değer null olduğu için runtime'da NullPointerException fırlatılır.",
            "tags": ["not_null_assertion", "exception"]
          },
          {
            "questionId": 16005,
            "question": "Aşağıdakilerden hangisi lateinit için doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Primitive tiplerde kullanılabilir",
              "val ile kullanılabilir",
              "Nullable değişkenlerde kullanılır",
              "Sonradan initialize edilen non-null değişkenler için kullanılır"
            ],
            "correctAnswerIndex": 3,
            "explanation": "lateinit, non-null ve sonradan initialize edilecek var değişkenler için kullanılır.",
            "tags": ["lateinit"]
          },
          {
            "questionId": 16006,
            "question": "Aşağıdaki kod neden hatalıdır?",
            "questionType": "multiple_choice",
            "code": "lateinit var age: Int",
            "difficulty": "medium",
            "options": [
              "var yerine val kullanılması gerekir",
              "lateinit sadece String için geçerlidir",
              "Primitive tiplerde kullanılamaz",
              "Int nullable olmadığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "lateinit primitive tiplerde kullanılamaz, sadece reference type'lar için geçerlidir.",
            "tags": ["lateinit", "primitive"]
          },
          {
            "questionId": 16007,
            "question": "lazy delegate ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her erişimde yeniden hesaplanır",
              "Sadece var ile kullanılabilir",
              "İlk erişimde initialize edilir",
              "Nullable değişkenler için zorunludur"
            ],
            "correctAnswerIndex": 2,
            "explanation": "lazy, değişkeni ilk erişimde initialize eder ve sonucu saklar.",
            "tags": ["lazy"]
          },
          {
            "questionId": 16008,
            "question": "Aşağıdaki kodun çıktısı nedir?",
            "questionType": "multiple_choice",
            "code": "val number: Int? = null\nval result = number ?: 10\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "null",
              "0",
              "10",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 2,
            "explanation": "number null olduğu için Elvis operatörü 10 değerini döndürür.",
            "tags": ["elvis_operator"]
          },
          {
            "questionId": 16009,
            "question": "Fonksiyon parametreleri nullable olabilir mi?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Hayır",
              "Sadece varsayılan parametrelerde",
              "Evet, '?' kullanılarak",
              "Sadece lateinit ile"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fonksiyon parametreleri nullable olabilir ve '?' ile belirtilir.",
            "tags": ["function", "nullable"]
          },
          {
            "questionId": 16010,
            "question": "lateinit ve lazy arasındaki temel fark nedir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "lateinit thread-safe'dir, lazy değildir",
              "lateinit var ile, lazy val ile kullanılır",
              "lazy nullable değişkenler içindir",
              "lateinit ilk erişimde initialize olur"
            ],
            "correctAnswerIndex": 1,
            "explanation": "lateinit yalnızca var ile kullanılır, lazy ise val ile ve ilk erişimde initialize edilir.",
            "tags": ["lateinit", "lazy", "difference"]
          }
        ]
        },
        {
          "sectionId": 106,
          "sectionTitle": "Nesne Yönelimli Programlama",
          "sectionDescription": "",
          "order": 6,
          "topics": [
            {
              "topicId": 1501,
              "title": "Sınıflara Giriş (Classlar)",
              "summary": "Sınıflar (class), nesne tabanlı programlamanın temel yapı taşlarıdır. Kotlin'de sınıflar; özellikleri (property) ve davranışları (fonksiyon) bir arada tutarak gerçek hayattaki nesneleri temsil eder.",
              "content": "## Sınıflara Giriş (Classlar)\n\nNesne tabanlı programlamada (OOP), sınıflar bir nesnenin taslağını (şablonunu) temsil eder. Bir sınıftan birden fazla nesne (object) oluşturulabilir.\n\nKotlin'de sınıflar `class` anahtar kelimesi ile tanımlanır. Sınıflar; değişkenler (property) ve fonksiyonlar (method) içerebilir.\n\nAndroid geliştirmede Activity, Fragment, ViewModel gibi tüm yapılar birer sınıftır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Sınıf Tanımı",
                  "code": "class Person {\n    var name: String = \"\"\n    var age: Int = 0\n}",
                  "explanation": "Person sınıfı iki property içerir."
                },
                {
                  "title": "Nesne Oluşturma",
                  "code": "val person = Person()\nperson.name = \"Ahmet\"\nperson.age = 25",
                  "explanation": "Sınıftan bir nesne (object) oluşturulur."
                },
                {
                  "title": "Sınıf İçinde Fonksiyon",
                  "code": "class Car {\n    var brand: String = \"\"\n\n    fun drive() {\n        println(\"Araba sürülüyor\")\n    }\n}",
                  "explanation": "Sınıf içinde fonksiyon tanımlanabilir."
                },
                {
                  "title": "Fonksiyon Çağırma",
                  "code": "val car = Car()\ncar.drive()",
                  "explanation": "Sınıf fonksiyonları nesne üzerinden çağrılır."
                },
                {
                  "title": "Birden Fazla Nesne",
                  "code": "val p1 = Person()\nval p2 = Person()",
                  "explanation": "Aynı sınıftan birden fazla nesne oluşturulabilir."
                }
              ],
              "keyPoints": [
                "Sınıflar OOP'nin temel yapı taşıdır",
                "class anahtar kelimesi ile tanımlanır",
                "Sınıflardan nesneler (object) oluşturulur",
                "Sınıflar property ve fonksiyon içerir",
                "Android'deki her yapı aslında bir sınıftır"
              ],
              "questions": [
                {
                  "questionId": 150101,
                  "question": "Kotlin'de sınıf tanımlamak için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "object",
                    "class",
                    "struct",
                    "type"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de sınıflar class anahtar kelimesi ile tanımlanır.",
                  "tags": ["class", "oop"]
                },
                {
                  "questionId": 150102,
                  "question": "Bir sınıftan oluşturulan örneğe ne ad verilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Method",
                    "Property",
                    "Object",
                    "Package"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sınıftan oluşturulan her örnek bir object'tir.",
                  "tags": ["object", "oop"]
                },
                {
                  "questionId": 150103,
                  "question": "Aşağıdakilerden hangisi sınıf içinde bulunabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece değişken",
                    "Sadece fonksiyon",
                    "Değişken ve fonksiyon",
                    "Sadece constructor"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sınıflar hem property hem fonksiyon içerebilir.",
                  "tags": ["class"]
                },
                {
                  "questionId": 150104,
                  "question": "Aşağıdaki ifadelerden hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Bir sınıftan sadece bir nesne oluşturulur",
                    "Sınıflar sadece veri tutar",
                    "Bir sınıftan birden fazla nesne oluşturulabilir",
                    "Sınıflar fonksiyon içeremez"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Aynı sınıftan birden fazla nesne oluşturulabilir.",
                  "tags": ["oop"]
                },
                {
                  "questionId": 150105,
                  "question": "Android'de Activity ve Fragment ne tür yapılardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fonksiyon",
                    "Değişken",
                    "Sınıf",
                    "Paket"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Activity ve Fragment, Kotlin'de sınıf olarak tanımlanır.",
                  "tags": ["android", "class"]
                }
              ]
            },
            {
              "topicId": 1502,
              "title": "Constructor",
              "summary": "Constructor, bir sınıftan nesne oluşturulurken çalışan özel bir yapıdır. Kotlin'de constructor'lar sayesinde sınıfın başlangıç değerleri belirlenir ve nesne oluşturma süreci kontrol altına alınır.",
              "content": "## Constructor (Yapıcı Metot)\n\nConstructor, bir sınıftan nesne oluşturulduğu anda otomatik olarak çalışan özel bir fonksiyondur. Kotlin'de constructor kullanımı oldukça basittir ve genellikle sınıf başlığında tanımlanır.\n\nKotlin'de iki tür constructor vardır:\n- Primary Constructor (Birincil)\n- Secondary Constructor (İkincil)\n\nPrimary constructor sınıf başlığında tanımlanır ve en çok kullanılan yöntemdir. Secondary constructor ise ek senaryolar için kullanılır.\n\nAndroid geliştirmede model sınıfları, ViewModel'ler ve adapter yapıları constructor mantığına dayanır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Primary Constructor",
                  "code": "class User(val name: String, val age: Int)",
                  "explanation": "Primary constructor sınıf başlığında tanımlanır."
                },
                {
                  "title": "Nesne Oluşturma",
                  "code": "val user = User(\"Ahmet\", 25)",
                  "explanation": "Constructor parametreleri nesne oluştururken gönderilir."
                },
                {
                  "title": "Init Bloğu",
                  "code": "class Product(val price: Int) {\n    init {\n        println(\"Ürün fiyatı: $price\")\n    }\n}",
                  "explanation": "init bloğu constructor çalıştığında otomatik olarak tetiklenir."
                },
                {
                  "title": "Secondary Constructor",
                  "code": "class Car {\n    var brand: String\n\n    constructor(brand: String) {\n        this.brand = brand\n    }\n}",
                  "explanation": "Secondary constructor, class içinde constructor anahtar kelimesi ile tanımlanır."
                },
                {
                  "title": "Birden Fazla Constructor",
                  "code": "class Person(val name: String) {\n    var age: Int = 0\n\n    constructor(name: String, age: Int) : this(name) {\n        this.age = age\n    }\n}",
                  "explanation": "Secondary constructor, primary constructor'ı çağırmak zorundadır."
                }
              ],
              "keyPoints": [
                "Constructor nesne oluşturulurken çalışır",
                "Primary constructor en çok kullanılan yöntemdir",
                "init bloğu constructor ile birlikte çalışır",
                "Secondary constructor ek senaryolar için kullanılır",
                "Android model sınıfları constructor yapısını yoğun kullanır"
              ],
              "questions": [
                {
                  "questionId": 150201,
                  "question": "Constructor ne zaman çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sınıf tanımlandığında",
                    "Fonksiyon çağrıldığında",
                    "Nesne oluşturulduğunda",
                    "Uygulama kapandığında"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Constructor, sınıftan nesne oluşturulduğu anda çalışır.",
                  "tags": ["constructor", "oop"]
                },
                {
                  "questionId": 150202,
                  "question": "Primary constructor nerede tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fonksiyon içinde",
                    "Sınıf başlığında",
                    "init bloğunda",
                    "Companion object içinde"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Primary constructor sınıf başlığında tanımlanır.",
                  "tags": ["constructor"]
                },
                {
                  "questionId": 150203,
                  "question": "init bloğu ne zaman çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Uygulama açıldığında",
                    "Fonksiyon çağrıldığında",
                    "Constructor çalıştığında",
                    "Sınıf silindiğinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "init bloğu constructor ile birlikte otomatik olarak çalışır.",
                  "tags": ["init", "constructor"]
                },
                {
                  "questionId": 150204,
                  "question": "Secondary constructor hangi anahtar kelime ile tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "init",
                    "class",
                    "new",
                    "constructor"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Secondary constructor, constructor anahtar kelimesi ile tanımlanır.",
                  "tags": ["constructor"]
                },
                {
                  "questionId": 150205,
                  "question": "Secondary constructor için aşağıdakilerden hangisi zorunludur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "init bloğu çağırmak",
                    "Primary constructor'ı çağırmak",
                    "open sınıf olmak",
                    "abstract sınıf olmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Secondary constructor, primary constructor'ı çağırmak zorundadır.",
                  "tags": ["oop", "constructor"]
                }
              ]
            },
            {
              "topicId": 1503,
              "title": "Encapsulation",
              "summary": "Encapsulation (kapsülleme), nesneye ait verilerin doğrudan erişime kapatılması ve kontrollü bir şekilde dışarıya açılması prensibidir. Kotlin'de bu işlem access modifier'lar ve getter/setter yapıları ile sağlanır.",
              "content": "## Encapsulation (Kapsülleme)\n\nEncapsulation, nesne yönelimli programlamanın (OOP) temel prensiplerinden biridir. Amaç, bir sınıfın iç detaylarını gizleyerek dış dünyaya yalnızca gerekli olan kısmı açmaktır.\n\nKotlin'de encapsulation genellikle **private**, **public**, **protected** gibi erişim belirleyiciler ve **getter/setter** yapıları ile uygulanır.\n\nBu yaklaşım sayesinde:\n- Kod güvenliği artar\n- Hatalı kullanımlar engellenir\n- Sınıflar daha sürdürülebilir hale gelir\n\nAndroid geliştirmede ViewModel, Repository ve Model sınıflarında encapsulation yoğun şekilde kullanılır.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Private Property Kullanımı",
                  "code": "class User {\n    private var password: String = \"1234\"\n\n    fun checkPassword(input: String): Boolean {\n        return input == password\n    }\n}",
                  "explanation": "password değişkeni private olduğu için dışarıdan doğrudan erişilemez."
                },
                {
                  "title": "Public Getter - Private Setter",
                  "code": "class Account {\n    var balance: Int = 0\n        private set\n}",
                  "explanation": "balance değeri dışarıdan okunabilir ama değiştirilemez."
                },
                {
                  "title": "Custom Getter ve Setter",
                  "code": "class Product {\n    var price: Int = 0\n        get() = field\n        set(value) {\n            if (value >= 0) {\n                field = value\n            }\n        }\n}",
                  "explanation": "Setter içinde kontrol yapılarak hatalı değer atamaları engellenir."
                },
                {
                  "title": "Encapsulation ile Veri Koruma",
                  "code": "class BankAccount {\n    private var balance: Int = 0\n\n    fun deposit(amount: Int) {\n        if (amount > 0) balance += amount\n    }\n\n    fun getBalance(): Int = balance\n}",
                  "explanation": "balance sadece sınıf içinden değiştirilebilir, dışarıya kontrollü açılır."
                }
              ],
              "keyPoints": [
                "Encapsulation, veriyi gizleyip kontrollü açma prensibidir",
                "private erişim belirleyicisi sık kullanılır",
                "Getter ve setter ile kontrollü erişim sağlanır",
                "Hatalı veri girişleri engellenir",
                "Kodun güvenliği ve sürdürülebilirliği artar"
              ],
              "questions": [
                {
                  "questionId": 150301,
                  "question": "Encapsulation'ın temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kodu uzatmak",
                    "Veriyi gizlemek ve kontrollü erişim sağlamak",
                    "Daha fazla sınıf oluşturmak",
                    "Sadece performansı artırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Encapsulation, veriyi gizleyip kontrollü erişim sağlamak için kullanılır.",
                  "tags": ["encapsulation", "oop"]
                },
                {
                  "questionId": 150302,
                  "question": "Bir değişkenin dışarıdan erişimini tamamen kapatmak için hangi access modifier kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "public",
                    "protected",
                    "internal",
                    "private"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "private ile tanımlanan değişkenlere sadece sınıf içinden erişilebilir.",
                  "tags": ["access-modifiers"]
                },
                {
                  "questionId": 150303,
                  "question": "Aşağıdaki yapılardan hangisi encapsulation örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Tüm değişkenleri public yapmak",
                    "private property + public method kullanmak",
                    "Her sınıfı abstract yapmak",
                    "Sadece data class kullanmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Veriyi private yapıp kontrollü metotlarla erişmek encapsulation'dır.",
                  "tags": ["encapsulation"]
                },
                {
                  "questionId": 150304,
                  "question": "Aşağıdaki kodda balance neden private tanımlanmıştır?",
                  "questionType": "multiple_choice",
                  "code": "class Account {\n    private var balance = 0\n\n    fun deposit(amount: Int) {\n        balance += amount\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "Performans için",
                    "Dışarıdan doğrudan değiştirilmesini engellemek için",
                    "Derleme süresini kısaltmak için",
                    "Zorunlu olduğu için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Encapsulation sayesinde balance sadece kontrollü şekilde değiştirilebilir.",
                  "tags": ["encapsulation", "security"]
                },
                {
                  "questionId": 150305,
                  "question": "Getter ve setter'ların temel görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sınıf oluşturmak",
                    "Veriyi silmek",
                    "Değişkenlere kontrollü erişim sağlamak",
                    "Inheritance sağlamak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Getter ve setter, değişkenlere kontrollü erişim sağlar.",
                  "tags": ["getter", "setter"]
                }
              ]
            },
            {
              "topicId": 1504,
              "title": "Inheritance",
              "summary": "Inheritance (kalıtım), bir sınıfın başka bir sınıfın özelliklerini ve davranışlarını miras almasını sağlar. Kotlin'de kalıtım, kod tekrarını azaltmak ve sınıflar arasında hiyerarşik bir yapı kurmak için kullanılır.",
              "content": "## Inheritance (Kalıtım)\n\nInheritance, nesne yönelimli programlamanın temel prensiplerinden biridir. Bir sınıfın başka bir sınıftan türemesini sağlar.\n\nKotlin'de bir sınıf varsayılan olarak **final**'dır. Kalıtım yapılabilmesi için **open** anahtar kelimesi kullanılır.\n\nAlt sınıflar (**child / subclass**), üst sınıfın (**parent / superclass**) public ve protected üyelerine erişebilir.\n\nAndroid geliştirmede Activity, Fragment, ViewModel gibi yapılar kalıtımın en yaygın kullanıldığı örneklerdir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Basit Kalıtım Örneği",
                  "code": "open class Animal {\n    fun makeSound() {\n        println(\"Ses çıkarıyor\")\n    }\n}\n\nclass Dog : Animal() {\n    fun bark() {\n        println(\"Hav hav\")\n    }\n}",
                  "explanation": "Dog sınıfı, Animal sınıfından kalıtım alır ve onun fonksiyonlarını kullanabilir."
                },
                {
                  "title": "Constructor ile Kalıtım",
                  "code": "open class Vehicle(val brand: String)\n\nclass Car(brand: String, val doors: Int) : Vehicle(brand)",
                  "explanation": "Alt sınıf, üst sınıfın constructor'ına parametre gönderebilir."
                },
                {
                  "title": "open ve override Kullanımı",
                  "code": "open class Shape {\n    open fun draw() {\n        println(\"Şekil çiziliyor\")\n    }\n}\n\nclass Circle : Shape() {\n    override fun draw() {\n        println(\"Daire çiziliyor\")\n    }\n}",
                  "explanation": "Bir fonksiyon override edilecekse üst sınıfta open olarak tanımlanmalıdır."
                },
                {
                  "title": "super Anahtar Kelimesi",
                  "code": "open class User {\n    open fun getRole() {\n        println(\"User\")\n    }\n}\n\nclass Admin : User() {\n    override fun getRole() {\n        super.getRole()\n        println(\"Admin\")\n    }\n}",
                  "explanation": "super ile üst sınıfın fonksiyonuna erişilebilir."
                }
              ],
              "keyPoints": [
                "Kotlin'de sınıflar varsayılan olarak final'dır",
                "Kalıtım için open anahtar kelimesi gerekir",
                "Alt sınıf, üst sınıfın public ve protected üyelerine erişebilir",
                "override edilen fonksiyonlar open olmalıdır",
                "super anahtar kelimesi ile üst sınıfa erişilir"
              ],
              "questions": [
                {
                  "questionId": 150401,
                  "question": "Kotlin'de bir sınıfın kalıtım alabilmesi için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "abstract",
                    "open",
                    "inherit",
                    "extends"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır. Kalıtım için open kullanılmalıdır.",
                  "tags": ["inheritance", "open"]
                },
                {
                  "questionId": 150402,
                  "question": "Aşağıdakilerden hangisi override edilebilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "final fonksiyon",
                    "private fonksiyon",
                    "open fonksiyon",
                    "local fonksiyon"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sadece open olarak tanımlanan fonksiyonlar override edilebilir.",
                  "tags": ["override"]
                },
                {
                  "questionId": 150403,
                  "question": "super anahtar kelimesi ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Alt sınıfı çağırır",
                    "Üst sınıfın üyelerine erişir",
                    "Yeni nesne oluşturur",
                    "Interface implement eder"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "super, üst sınıfın fonksiyon ve property'lerine erişmek için kullanılır.",
                  "tags": ["super"]
                },
                {
                  "questionId": 150404,
                  "question": "Aşağıdaki kodda hata oluşmasının sebebi nedir?",
                  "questionType": "multiple_choice",
                  "code": "class A\n\nclass B : A()",
                  "difficulty": "medium",
                  "options": [
                    "Constructor eksik",
                    "A sınıfı open değil",
                    "B sınıfı final",
                    "override eksik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "A sınıfı open olmadığı için kalıtım alınamaz.",
                  "tags": ["inheritance", "error"]
                },
                {
                  "questionId": 150405,
                  "question": "Android'de aşağıdakilerden hangisi inheritance örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Activity : AppCompatActivity",
                    "Intent kullanımı",
                    "SharedPreferences",
                    "DataBinding"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Activity'ler genellikle AppCompatActivity'den kalıtım alır.",
                  "tags": ["android", "inheritance"]
                }
              ]
            },
            {
              "topicId": 1505,
              "title": "Polymorphism",
              "summary": "Polymorphism (çok biçimlilik), aynı arayüz veya üst sınıf referansı ile farklı nesnelerin farklı davranışlar sergilemesini sağlar. Kotlin'de polymorphism, inheritance ve override mekanizmaları ile uygulanır.",
              "content": "## Polymorphism (Çok Biçimlilik)\n\nPolymorphism, nesne yönelimli programlamanın temel prensiplerinden biridir. Aynı türden referanslar kullanılarak farklı nesnelerin kendi davranışlarını sergilemesini sağlar.\n\nKotlin'de polymorphism genellikle:\n- open ve override fonksiyonlar\n- Üst sınıf referansı ile alt sınıf nesnesi oluşturma\n- Interface ve abstract class yapıları\n\nüzerinden uygulanır.\n\nAndroid geliştirmede polymorphism; Adapter, ViewModel, Repository ve callback yapılarında sıkça kullanılır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Üst Sınıf Referansı ile Alt Sınıf Nesnesi",
                  "code": "open class Animal {\n    open fun makeSound() {\n        println(\"Ses çıkarıyor\")\n    }\n}\n\nclass Cat : Animal() {\n    override fun makeSound() {\n        println(\"Miyav\")\n    }\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Hav hav\")\n    }\n}",
                  "explanation": "Animal referansı, farklı alt sınıf nesneleri için farklı çıktılar üretir."
                },
                {
                  "title": "Polymorphism Kullanımı",
                  "code": "fun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nanimalSound(Cat())\nanimalSound(Dog())",
                  "explanation": "Fonksiyon, Animal türü alır ama gelen nesneye göre davranış değişir."
                },
                {
                  "title": "Liste Üzerinden Polymorphism",
                  "code": "val animals: List<Animal> = listOf(Cat(), Dog())\n\nfor (animal in animals) {\n    animal.makeSound()\n}",
                  "explanation": "Aynı liste içinde farklı alt sınıflar kendi davranışlarını sergiler."
                },
                {
                  "title": "Android'de Polymorphism Örneği",
                  "code": "open class BaseViewModel\n\nclass MainViewModel : BaseViewModel()\nclass DetailViewModel : BaseViewModel()",
                  "explanation": "ViewModel'lar genellikle ortak bir üst sınıftan türetilir."
                }
              ],
              "keyPoints": [
                "Polymorphism, tek referans ile farklı davranışlar üretir",
                "Inheritance polymorphism için temel şarttır",
                "override edilen fonksiyonlar runtime'da çağrılır",
                "Üst sınıf referansı alt sınıf nesnesini tutabilir",
                "Kod esnekliği ve genişletilebilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 150501,
                  "question": "Polymorphism neyi ifade eder?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Bir sınıfın tek görevi olmasını",
                    "Aynı referans ile farklı davranışlar sergilenmesini",
                    "Sınıfların birbirini çağırmasını",
                    "Sadece interface kullanımını"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism, aynı referans ile farklı nesnelerin farklı davranış göstermesidir.",
                  "tags": ["polymorphism", "oop"]
                },
                {
                  "questionId": 150502,
                  "question": "Aşağıdakilerden hangisi polymorphism için gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Data class",
                    "Inheritance",
                    "Singleton",
                    "Companion object"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism genellikle inheritance ve override ile sağlanır.",
                  "tags": ["inheritance"]
                },
                {
                  "questionId": 150503,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "open class A {\n    open fun print() {\n        println(\"A\")\n    }\n}\n\nclass B : A() {\n    override fun print() {\n        println(\"B\")\n    }\n}\n\nval obj: A = B()\nobj.print()",
                  "difficulty": "medium",
                  "options": [
                    "A",
                    "B",
                    "Compile hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Runtime'da nesnenin gerçek tipi (B) çalışır.",
                  "tags": ["runtime", "override"]
                },
                {
                  "questionId": 150504,
                  "question": "Override edilen fonksiyon ne zaman belirlenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Compile time",
                    "Runtime",
                    "Build time",
                    "Install time"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism runtime binding kullanır.",
                  "tags": ["runtime"]
                },
                {
                  "questionId": 150505,
                  "question": "Android'de Adapter yapılarında polymorphism neden kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI tasarlamak için",
                    "Farklı item tiplerini yönetmek için",
                    "Performansı düşürmek için",
                    "Veritabanı bağlantısı için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Adapter'larda farklı view type'lar polymorphism ile yönetilir.",
                  "tags": ["android", "adapter"]
                }
              ]
            },
            {
              "topicId": 1506,
              "title": "Abstraction",
              "summary": "Abstraction (soyutlama), bir nesnenin sadece gerekli özelliklerini dışarıya sunup detayları gizleme prensibidir. Kotlin'de abstraction, abstract class ve interface yapıları ile uygulanır.",
              "content": "## Abstraction (Soyutlama)\n\nAbstraction, nesne yönelimli programlamanın en önemli prensiplerinden biridir. Amaç, **ne yapıldığını** göstermek, **nasıl yapıldığını** gizlemektir.\n\nKotlin'de abstraction iki temel yapı ile sağlanır:\n\n- **Abstract Class**: Gövdeli ve gövdesiz (abstract) fonksiyonlar içerebilir, state tutabilir.\n- **Interface**: Fonksiyon imzaları tanımlar, çoklu implementasyona izin verir.\n\nAndroid geliştirmede abstraction; Repository, DataSource, Callback, Listener ve Service yapılarında yoğun şekilde kullanılır.",
              "difficulty": "medium",
              "order": 6,
              "codeExamples": [
                {
                  "title": "Abstract Class Örneği",
                  "code": "abstract class Vehicle {\n    abstract fun move()\n\n    fun stop() {\n        println(\"Araç durdu\")\n    }\n}\n\nclass Car : Vehicle() {\n    override fun move() {\n        println(\"Araba hareket ediyor\")\n    }\n}",
                  "explanation": "Abstract class hem gövdeli hem gövdesiz fonksiyonlar içerebilir."
                },
                {
                  "title": "Interface Örneği",
                  "code": "interface Flyable {\n    fun fly()\n}\n\nclass Bird : Flyable {\n    override fun fly() {\n        println(\"Kuş uçuyor\")\n    }\n}",
                  "explanation": "Interface, sınıflara davranış kazandırmak için kullanılır."
                },
                {
                  "title": "Abstract Property Kullanımı",
                  "code": "abstract class Employee {\n    abstract val salary: Int\n}\n\nclass Developer : Employee() {\n    override val salary: Int = 30000\n}",
                  "explanation": "Abstract class'lar abstract property tanımlayabilir."
                },
                {
                  "title": "Android'de Abstraction Örneği",
                  "code": "interface UserRepository {\n    fun getUsers(): List<String>\n}\n\nclass UserRepositoryImpl : UserRepository {\n    override fun getUsers(): List<String> {\n        return listOf(\"Ahmet\", \"Mehmet\")\n    }\n}",
                  "explanation": "Repository pattern abstraction kullanılarak uygulanır."
                }
              ],
              "keyPoints": [
                "Abstraction, detayları gizleyip gerekli kısmı sunar",
                "Abstract class hem state hem fonksiyon içerebilir",
                "Interface çoklu implementasyona izin verir",
                "Abstract class'tan nesne oluşturulamaz",
                "Android mimarilerinde abstraction temel yapı taşıdır"
              ],
              "questions": [
                {
                  "questionId": 150601,
                  "question": "Abstraction'ın temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kodu uzatmak",
                    "Detayları gizleyip gerekli yapıyı sunmak",
                    "Daha fazla sınıf oluşturmak",
                    "Performansı artırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Abstraction, ne yapıldığını gösterip nasıl yapıldığını gizler.",
                  "tags": ["abstraction", "oop"]
                },
                {
                  "questionId": 150602,
                  "question": "Abstract class ile ilgili hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Nesnesi oluşturulabilir",
                    "Sadece abstract fonksiyon içerir",
                    "Hem gövdeli hem gövdesiz fonksiyon içerebilir",
                    "Çoklu kalıtımı destekler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Abstract class'lar hem normal hem abstract fonksiyonlar içerebilir.",
                  "tags": ["abstract-class"]
                },
                {
                  "questionId": 150603,
                  "question": "Interface'lerin en önemli avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "State tutabilmeleri",
                    "Constructor içermeleri",
                    "Çoklu implementasyona izin vermeleri",
                    "Sadece Android'de çalışmaları"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin interface'leri çoklu implementasyona izin verir.",
                  "tags": ["interface"]
                },
                {
                  "questionId": 150604,
                  "question": "Aşağıdakilerden hangisi abstraction örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Concrete class kullanımı",
                    "private değişken tanımlama",
                    "Repository interface kullanımı",
                    "Data class oluşturma"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Repository interface, abstraction'ın en yaygın kullanım alanlarından biridir.",
                  "tags": ["android", "architecture"]
                },
                {
                  "questionId": 150605,
                  "question": "Android mimarilerinde abstraction neden önemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI tasarımı için",
                    "Test edilebilirliği artırmak için",
                    "APK boyutunu küçültmek için",
                    "XML yazmamak için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Abstraction sayesinde kod daha test edilebilir ve sürdürülebilir olur.",
                  "tags": ["mvvm", "clean-architecture"]
                }
              ]
            },
            {
              "topicId": 1507,
              "title": "Visibility Modifiers",
              "summary": "Visibility Modifiers (erişim belirleyiciler), sınıfların, fonksiyonların ve değişkenlerin nerelerden erişilebilir olduğunu belirler. Kotlin'de public, private, protected ve internal olmak üzere dört temel erişim belirleyici bulunur.",
              "content": "## Visibility Modifiers (Erişim Belirleyiciler)\n\nVisibility modifiers, bir sınıfın veya üyenin (property, fonksiyon) hangi kapsamdan erişilebileceğini kontrol eder.\n\nKotlin'de dört temel erişim belirleyici vardır:\n\n- **public**: Her yerden erişilebilir (varsayılan)\n- **private**: Sadece tanımlandığı dosya veya sınıf içinden erişilebilir\n- **protected**: Sadece sınıf ve alt sınıflar tarafından erişilebilir\n- **internal**: Aynı module (modül) içerisinden erişilebilir\n\nDoğru visibility kullanımı, encapsulation ve abstraction prensiplerinin temelini oluşturur.",
              "difficulty": "medium",
              "order": 7,
              "codeExamples": [
                {
                  "title": "Public (Varsayılan) Kullanımı",
                  "code": "class User {\n    val name: String = \"Ahmet\"\n}",
                  "explanation": "public varsayılan olduğu için name her yerden erişilebilir."
                },
                {
                  "title": "Private Kullanımı",
                  "code": "class Account {\n    private var balance: Int = 0\n\n    fun getBalance(): Int {\n        return balance\n    }\n}",
                  "explanation": "balance sadece Account sınıfı içinden erişilebilir."
                },
                {
                  "title": "Protected Kullanımı",
                  "code": "open class Person {\n    protected val age: Int = 30\n}\n\nclass Employee : Person() {\n    fun printAge() {\n        println(age)\n    }\n}",
                  "explanation": "protected üyeler alt sınıflar tarafından erişilebilir."
                },
                {
                  "title": "Internal Kullanımı",
                  "code": "internal class Logger {\n    fun log(message: String) {\n        println(message)\n    }\n}",
                  "explanation": "internal tanımlanan sınıf sadece aynı module içinde erişilebilir."
                },
                {
                  "title": "Constructor Visibility",
                  "code": "class Singleton private constructor() {\n    companion object {\n        val instance = Singleton()\n    }\n}",
                  "explanation": "private constructor ile dışarıdan nesne oluşturulması engellenir."
                }
              ],
              "keyPoints": [
                "Kotlin'de varsayılan visibility public'tir",
                "private en dar erişim seviyesidir",
                "protected sadece inheritance ile çalışır",
                "internal module bazlı erişim sağlar",
                "Doğru visibility kod güvenliğini artırır"
              ],
              "questions": [
                {
                  "questionId": 150701,
                  "question": "Kotlin'de varsayılan visibility modifier hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "private",
                    "protected",
                    "internal",
                    "public"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Kotlin'de herhangi bir modifier belirtilmezse varsayılan olarak public kabul edilir.",
                  "tags": ["visibility", "public"]
                },
                {
                  "questionId": 150702,
                  "question": "Aynı module içinden erişim sağlayan visibility hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "private",
                    "protected",
                    "internal",
                    "public"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "internal modifier, sadece aynı module içinden erişime izin verir.",
                  "tags": ["internal"]
                },
                {
                  "questionId": 150703,
                  "question": "protected modifier hangi durumda anlam kazanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Top-level fonksiyonlarda",
                    "Inheritance (kalıtım) durumunda",
                    "Data class'larda",
                    "Singleton yapısında"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "protected sadece sınıf ve alt sınıflar için geçerlidir.",
                  "tags": ["protected", "inheritance"]
                },
                {
                  "questionId": 150704,
                  "question": "Aşağıdaki kodda hangi üyeye dışarıdan erişilemez?",
                  "questionType": "multiple_choice",
                  "code": "class Test {\n    private val a = 1\n    val b = 2\n}",
                  "difficulty": "easy",
                  "options": [
                    "a",
                    "b",
                    "İkisine de erişilebilir",
                    "Hiçbirine erişilemez"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "private tanımlanan a değişkenine sınıf dışından erişilemez.",
                  "tags": ["private"]
                },
                {
                  "questionId": 150705,
                  "question": "Android projelerinde internal genellikle ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI bileşenleri",
                    "Test edilebilirliği artırmak",
                    "Module içi sınıfları sınırlamak",
                    "Veritabanı tabloları"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "internal, module sınırları içinde erişimi kısıtlamak için kullanılır.",
                  "tags": ["android", "module"]
                }
              ]
            }

          ],
          "sectionMixedQuestions": [
          {
            "questionId": 17001,
            "question": "Kotlin'de bir sınıf (class) nasıl tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "class MyClass {}",
              "MyClass class {}",
              "define class MyClass {}",
              "object MyClass {}"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de sınıflar 'class' anahtar kelimesi ile tanımlanır.",
            "tags": ["class", "oop"]
          },
          {
            "questionId": 17002,
            "question": "Primary constructor aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "class User { constructor(name: String) {} }",
              "class User(name: String)",
              "fun constructor() {}",
              "init(name: String)"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Primary constructor, class tanımının yanında parantez içinde tanımlanır.",
            "tags": ["constructor", "primary_constructor"]
          },
          {
            "questionId": 17003,
            "question": "Encapsulation'ın temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Kodun daha hızlı çalışmasını sağlamak",
              "Sınıflar arası kalıtım sağlamak",
              "Veriyi dış müdahalelere karşı korumak",
              "Aynı isimli fonksiyonları kullanmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Encapsulation, sınıf içindeki veriyi private yaparak kontrollü erişim sağlamayı amaçlar.",
            "tags": ["encapsulation", "oop"]
          },
          {
            "questionId": 17004,
            "question": "Aşağıdaki visibility modifier'lardan hangisi sadece aynı sınıf içinde erişime izin verir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "public",
              "internal",
              "protected",
              "private"
            ],
            "correctAnswerIndex": 3,
            "explanation": "private, yalnızca tanımlandığı sınıf içinde erişilebilir.",
            "tags": ["visibility", "private"]
          },
          {
            "questionId": 17005,
            "question": "Kotlin'de inheritance (kalıtım) için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "extends",
              "inherits",
              ":",
              "implements"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de bir sınıf başka bir sınıftan ':' operatörü ile türetilir.",
            "tags": ["inheritance"]
          },
          {
            "questionId": 17006,
            "question": "Bir sınıfın miras alınabilmesi için hangi anahtar kelime ile işaretlenmesi gerekir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "abstract",
              "open",
              "public",
              "override"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır. Miras alınabilmesi için open olarak tanımlanmalıdır.",
            "tags": ["open", "inheritance"]
          },
          {
            "questionId": 17007,
            "question": "Polymorphism aşağıdakilerden hangisini ifade eder?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Bir sınıfın birden fazla constructor'a sahip olması",
              "Aynı fonksiyonun farklı davranışlar sergilemesi",
              "Sınıfların gizlenmesi",
              "Verilerin kapsüllenmesi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Polymorphism, aynı isimli fonksiyonların farklı sınıflarda farklı davranışlar göstermesidir.",
            "tags": ["polymorphism"]
          },
          {
            "questionId": 17008,
            "question": "Aşağıdakilerden hangisi abstraction için doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Abstract class instance alınabilir",
              "Abstract fonksiyonların gövdesi olmak zorundadır",
              "Detayları gizleyip sadece gerekli yapıyı sunar",
              "Sadece interface ile yapılır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Abstraction, karmaşık detayları gizleyerek kullanıcıya sade bir yapı sunar.",
            "tags": ["abstraction"]
          },
          {
            "questionId": 17009,
            "question": "Aşağıdaki kodda hangi OOP prensibi uygulanmaktadır?",
            "questionType": "multiple_choice",
            "code": "open class Animal {\n    open fun sound() {}\n}\n\nclass Dog : Animal() {\n    override fun sound() {}\n}",
            "difficulty": "hard",
            "options": [
              "Encapsulation",
              "Inheritance",
              "Polymorphism",
              "Abstraction"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Aynı fonksiyonun (sound) farklı sınıflarda farklı şekilde override edilmesi polymorphism örneğidir.",
            "tags": ["polymorphism", "override"]
          },
          {
            "questionId": 17010,
            "question": "protected visibility modifier ne anlama gelir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her yerden erişilebilir",
              "Sadece aynı dosya içinden erişilebilir",
              "Sadece aynı sınıf ve alt sınıflardan erişilebilir",
              "Sadece aynı modülden erişilebilir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "protected, tanımlandığı sınıf ve o sınıftan türeyen alt sınıflar tarafından erişilebilir.",
            "tags": ["protected", "visibility"]
          }
        ]
        },
        {
          "sectionId": 107,
          "sectionTitle": "Fonksiyonel Programlama",
          "sectionDescription": "",
          "order": 7,
          "topics": [
            {
              "topicId": 1601,
              "title": "Lambda",
              "summary": "Lambda, isimsiz (anonim) fonksiyonlardır ve fonksiyonel programlamanın temel yapı taşlarından biridir. Kotlin'de lambda ifadeleri, fonksiyonları değişken gibi kullanmayı ve daha okunabilir, esnek kod yazmayı sağlar.",
              "content": "## Lambda\n\nLambda ifadeleri, kısa ve tek kullanımlık fonksiyonlar tanımlamak için kullanılır. Kotlin'de fonksiyonlar birer first-class citizen'dır, yani değişkenlere atanabilir, parametre olarak gönderilebilir ve fonksiyondan döndürülebilir.\n\nLambda yapısı:\n\n```\n{ parametreler -> işlem }\n```\n\nLambda'lar genellikle collection işlemleri, callback yapıları ve asenkron işlemlerde kullanılır.\n\nAndroid geliştirmede onClick listener'lar, adapter callback'leri ve higher-order function'lar lambda kullanımının en yaygın örnekleridir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Lambda Tanımı",
                  "code": "val sum = { a: Int, b: Int -> a + b }\n\nprintln(sum(3, 5))",
                  "explanation": "Lambda bir değişkene atanabilir ve fonksiyon gibi çağrılabilir."
                },
                {
                  "title": "Tek Parametreli Lambda (it)",
                  "code": "val printNumber: (Int) -> Unit = { println(it) }\n\nprintNumber(10)",
                  "explanation": "Tek parametre varsa it anahtar kelimesi kullanılabilir."
                },
                {
                  "title": "Fonksiyon Parametresi Olarak Lambda",
                  "code": "fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nval result = calculate(4, 2) { x, y -> x * y }",
                  "explanation": "Fonksiyonlar parametre olarak lambda alabilir."
                },
                {
                  "title": "Android'de Lambda Kullanımı",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "explanation": "Listener yapıları lambda ile sadeleşir."
                }
              ],
              "keyPoints": [
                "Lambda ifadeleri isimsiz fonksiyonlardır",
                "Fonksiyonlar Kotlin'de first-class citizen'dır",
                "Lambda'lar değişkene atanabilir",
                "Fonksiyonlara parametre olarak gönderilebilir",
                "Android callback'lerinde yaygın kullanılır"
              ],
              "questions": [
                {
                  "questionId": 160101,
                  "question": "Lambda ifadesi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "İsimli fonksiyon",
                    "Anonim (isimsiz) fonksiyon",
                    "Sadece Android'e özel yapı",
                    "Class türü"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda, isimsiz fonksiyonlardır.",
                  "tags": ["lambda", "functional"]
                },
                {
                  "questionId": 160102,
                  "question": "Tek parametreli lambda'da hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "this",
                    "param",
                    "it",
                    "self"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Tek parametreli lambda'da it kullanılır.",
                  "tags": ["lambda"]
                },
                {
                  "questionId": 160103,
                  "question": "Aşağıdakilerden hangisi doğru lambda tanımıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "{ a, b => a + b }",
                    "{ a: Int, b: Int -> a + b }",
                    "(a, b) -> a + b",
                    "lambda(a, b)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de lambda tanımı bu şekildedir.",
                  "tags": ["syntax"]
                },
                {
                  "questionId": 160104,
                  "question": "Lambda'lar genellikle hangi yapılarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "XML layout",
                    "Callback ve collection işlemleri",
                    "Manifest dosyası",
                    "Gradle script"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda'lar callback ve collection işlemlerinde yaygındır.",
                  "tags": ["collections", "callback"]
                },
                {
                  "questionId": 160105,
                  "question": "Android'de lambda kullanımının avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha fazla kod yazmak",
                    "Okunabilirliği ve sadeliği artırmak",
                    "Sadece performans kazanmak",
                    "Java uyumluluğunu kaldırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda, boilerplate kodu azaltır ve okunabilirliği artırır.",
                  "tags": ["android", "lambda"]
                }
              ]
            },
            {
              "topicId": 1602,
              "title": "Map ve Filter",
              "summary": "Map ve Filter, koleksiyonlar üzerinde veri dönüştürme ve filtreleme işlemleri yapmak için kullanılan fonksiyonel programlama araçlarıdır. Kotlin'de okunabilir ve temiz kod yazmayı sağlar.",
              "content": "## Map ve Filter\n\nMap fonksiyonu, bir koleksiyondaki her elemanı dönüştürerek yeni bir koleksiyon oluşturur.\n\nFilter fonksiyonu ise belirli bir koşulu sağlayan elemanları seçerek yeni bir koleksiyon döndürür.\n\nBu fonksiyonlar orijinal koleksiyonu değiştirmez, immutable yapıyı korur.\n\nAndroid geliştirmede listeleme, arama, veri dönüştürme ve UI'ya uygun veri hazırlama işlemlerinde sıkça kullanılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Map Kullanımı",
                  "code": "val numbers = listOf(1, 2, 3, 4)\n\nval doubled = numbers.map { it * 2 }\n\nprintln(doubled)",
                  "explanation": "Map, listedeki her elemanı dönüştürür."
                },
                {
                  "title": "Filter Kullanımı",
                  "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nval evenNumbers = numbers.filter { it % 2 == 0 }\n\nprintln(evenNumbers)",
                  "explanation": "Filter, koşulu sağlayan elemanları seçer."
                },
                {
                  "title": "Map + Filter Birlikte",
                  "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nval result = numbers.filter { it > 2 }.map { it * 10 }\n\nprintln(result)",
                  "explanation": "Önce filtreleme sonra dönüştürme yapılır."
                },
                {
                  "title": "Android Kullanım Senaryosu",
                  "code": "val users = listOf(\"Ali\", \"Ayşe\", \"Mehmet\")\n\nval uiList = users.map { it.uppercase() }\n\nprintln(uiList)",
                  "explanation": "UI'da gösterilecek veriler map ile dönüştürülür."
                }
              ],
              "keyPoints": [
                "Map koleksiyon elemanlarını dönüştürür",
                "Filter koşula uyan elemanları seçer",
                "Orijinal koleksiyon değişmez",
                "Fonksiyonel ve okunabilir kod sağlar",
                "Android projelerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 160201,
                  "question": "Map fonksiyonunun temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Elemanları silmek",
                    "Elemanları dönüştürmek",
                    "Listeyi sıralamak",
                    "Listeyi ters çevirmek"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Map, her elemanı dönüştürerek yeni bir koleksiyon oluşturur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 160202,
                  "question": "Filter fonksiyonu ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Elemanları değiştirir",
                    "Koşula uyan elemanları seçer",
                    "Listeyi kopyalar",
                    "Listeyi sıralar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Filter, verilen koşulu sağlayan elemanları döndürür.",
                  "tags": ["filter"]
                },
                {
                  "questionId": 160203,
                  "question": "Aşağıdaki kodun çıktısı nedir?\n\nnumbers.filter { it > 3 }.map { it * 2 }",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "[2, 4, 6]",
                    "[8, 10]",
                    "[4, 6, 8]",
                    "[6, 8, 10]"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Önce 3'ten büyükler seçilir, sonra 2 ile çarpılır.",
                  "tags": ["map", "filter"]
                },
                {
                  "questionId": 160204,
                  "question": "Map ve Filter kullanıldığında koleksiyon nasıl etkilenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Orijinal liste değişir",
                    "Orijinal liste silinir",
                    "Yeni bir liste oluşturulur",
                    "Sadece ilk eleman değişir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map ve Filter yeni bir koleksiyon döndürür.",
                  "tags": ["collections"]
                },
                {
                  "questionId": 160205,
                  "question": "Map & Filter Android'de en çok nerede kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Manifest dosyasında",
                    "Gradle ayarlarında",
                    "UI için veri hazırlamada",
                    "XML layout içinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Veriyi UI'ya uygun hale getirmek için sıkça kullanılır.",
                  "tags": ["android", "functional"]
                }
              ]
            },
            {
              "topicId": 1603,
              "title": "Scope Fonksiyonları",
              "summary": "Scope fonksiyonları, bir nesne üzerinde geçici bir kapsam (scope) oluşturarak daha okunabilir ve düzenli kod yazmayı sağlar. Kotlin'de let, run, apply, also ve with olmak üzere beş adet scope fonksiyonu bulunur.",
              "content": "## Scope Fonksiyonları\n\nScope fonksiyonları bir nesne ile birlikte çalışırken tekrar tekrar nesne adını yazma ihtiyacını ortadan kaldırır.\n\nBu fonksiyonlar, nesneye erişim şekline (this / it) ve geri dönüş tipine göre birbirinden ayrılır.\n\nAndroid geliştirmede null kontrolü, view binding, nesne yapılandırma ve zincirleme işlemler için sıkça kullanılır.\n\n### Scope Fonksiyonları Özeti\n- let → it kullanır, sonuç döndürür\n- run → this kullanır, sonuç döndürür\n- apply → this kullanır, nesnenin kendisini döndürür\n- also → it kullanır, nesnenin kendisini döndürür\n- with → this kullanır, sonuç döndürür (extension değildir)",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "let Kullanımı",
                  "code": "val name: String? = \"Ahmet\"\n\nname?.let {\n    println(it.uppercase())\n}",
                  "explanation": "let genellikle null kontrolü için kullanılır."
                },
                {
                  "title": "run Kullanımı",
                  "code": "val user = \"Kotlin\"\n\nval length = user.run {\n    this.length\n}\n\nprintln(length)",
                  "explanation": "run, this ile erişim sağlar ve sonuç döndürür."
                },
                {
                  "title": "apply Kullanımı",
                  "code": "val list = mutableListOf<String>().apply {\n    add(\"A\")\n    add(\"B\")\n}",
                  "explanation": "apply nesneyi yapılandırmak için kullanılır."
                },
                {
                  "title": "also Kullanımı",
                  "code": "val numbers = mutableListOf(1, 2, 3)\n    .also { println(\"Liste oluşturuldu: $it\") }",
                  "explanation": "also yan işlemler (log, debug) için idealdir."
                },
                {
                  "title": "with Kullanımı",
                  "code": "val user = StringBuilder()\n\nwith(user) {\n    append(\"Hello \")\n    append(\"Kotlin\")\n}\n\nprintln(user.toString())",
                  "explanation": "with bir nesneyle blok halinde çalışmayı sağlar."
                }
              ],
              "keyPoints": [
                "Scope fonksiyonları kod okunabilirliğini artırır",
                "let ve also -> it kullanır",
                "run, apply, with -> this kullanır",
                "apply ve also nesnenin kendisini döndürür",
                "Android projelerinde ViewBinding ve null kontrolünde yaygındır"
              ],
              "questions": [
                {
                  "questionId": 160301,
                  "question": "Hangi scope fonksiyonu null kontrolü için en sık kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "apply",
                    "with",
                    "let",
                    "also"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "let genellikle nullable nesnelerle kullanılır.",
                  "tags": ["scope", "let"]
                },
                {
                  "questionId": 160302,
                  "question": "Hangi scope fonksiyonu nesnenin kendisini döndürür?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "run",
                    "apply",
                    "with",
                    "let"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "apply yapılandırma sonrası nesnenin kendisini döndürür.",
                  "tags": ["apply"]
                },
                {
                  "questionId": 160303,
                  "question": "this anahtar kelimesiyle çalışan scope fonksiyonları hangileridir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "let ve also",
                    "apply ve run",
                    "let ve run",
                    "also ve with"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "apply ve run this ile erişim sağlar.",
                  "tags": ["scope"]
                },
                {
                  "questionId": 160304,
                  "question": "Log veya debug amaçlı en uygun scope fonksiyonu hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "run",
                    "with",
                    "also",
                    "let"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "also yan işlemler için tasarlanmıştır.",
                  "tags": ["also"]
                },
                {
                  "questionId": 160305,
                  "question": "with fonksiyonunun diğerlerinden farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Extension fonksiyon olması",
                    "Nesnenin kendisini döndürmesi",
                    "Extension olmaması",
                    "Null kontrolü yapması"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "with extension değildir, nesne parametre olarak verilir.",
                  "tags": ["with"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 18001,
            "question": "Lambda expression nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "İsimsiz bir sınıf",
              "İsimsiz bir fonksiyon",
              "Bir interface türü",
              "Bir veri tipi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Lambda, isimsiz fonksiyonlardır ve genellikle kısa işlemler için kullanılır.",
            "tags": ["lambda", "functional"]
          },
          {
            "questionId": 18002,
            "question": "Aşağıdakilerden hangisi geçerli bir lambda tanımıdır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "{ x, y -> x + y }",
              "(x, y) => x + y",
              "lambda x y { x + y }",
              "fun(x, y) = x + y"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de lambda tanımı { parametreler -> işlem } şeklindedir.",
            "tags": ["lambda", "syntax"]
          },
          {
            "questionId": 18003,
            "question": "map fonksiyonunun temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Listeyi filtrelemek",
              "Liste elemanlarını dönüştürmek",
              "Listeyi sıralamak",
              "Liste elemanlarını silmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "map, koleksiyonun her elemanını dönüştürerek yeni bir liste oluşturur.",
            "tags": ["map", "collections"]
          },
          {
            "questionId": 18004,
            "question": "filter fonksiyonu ne yapar?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Elemanları dönüştürür",
              "Belirli koşula uyanları seçer",
              "Elemanları gruplar",
              "Listeyi ters çevirir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "filter, verilen koşulu sağlayan elemanlardan yeni bir koleksiyon oluşturur.",
            "tags": ["filter"]
          },
          {
            "questionId": 18005,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val numbers = listOf(1, 2, 3, 4)\nval result = numbers.map { it * 2 }\nprintln(result)",
            "difficulty": "medium",
            "options": [
              "[1, 2, 3, 4]",
              "[2, 4, 6, 8]",
              "[1, 4, 9, 16]",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "map her elemanı 2 ile çarpar ve yeni bir liste döndürür.",
            "tags": ["map"]
          },
          {
            "questionId": 18006,
            "question": "Aşağıdaki scope fonksiyonlarından hangisi 'this' kullanır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "let",
              "also",
              "apply",
              "filter"
            ],
            "correctAnswerIndex": 2,
            "explanation": "apply ve run scope fonksiyonlarında context object 'this' ile temsil edilir.",
            "tags": ["scope_functions", "apply"]
          },
          {
            "questionId": 18007,
            "question": "let scope fonksiyonunun temel kullanım amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Nesneyi yapılandırmak",
              "Yan etkiler oluşturmak",
              "Null kontrolü ve dönüşüm",
              "Thread yönetimi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "let genellikle null kontrolü ve nesne üzerinde işlem yapmak için kullanılır.",
            "tags": ["let", "null_safety"]
          },
          {
            "questionId": 18008,
            "question": "Aşağıdaki kodda hangi scope fonksiyonu kullanılmıştır?",
            "questionType": "multiple_choice",
            "code": "val user = User().apply {\n    name = \"Ahmet\"\n    age = 25\n}",
            "difficulty": "medium",
            "options": [
              "let",
              "run",
              "also",
              "apply"
            ],
            "correctAnswerIndex": 3,
            "explanation": "apply, nesneyi yapılandırmak için kullanılır ve this referansını kullanır.",
            "tags": ["apply", "scope_functions"]
          },
          {
            "questionId": 18009,
            "question": "also scope fonksiyonunun ayırt edici özelliği nedir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "this kullanır",
              "Yeni bir nesne döndürür",
              "Yan etkiler (logging gibi) için kullanılır",
              "Null-safe değildir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "also genellikle loglama gibi yan etkiler için kullanılır ve it referansını kullanır.",
            "tags": ["also"]
          },
          {
            "questionId": 18010,
            "question": "map ve filter birlikte kullanıldığında ne sağlar?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Koleksiyonu sıralar",
              "Koleksiyonu optimize eder",
              "Filtrelenmiş veriyi dönüştürür",
              "Sadece performans artışı sağlar"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Önce filter ile elemanlar seçilir, ardından map ile dönüştürülür. Bu, fonksiyonel programlamanın temel desenidir.",
            "tags": ["map", "filter", "functional"]
          }
        ]
        },
        {
          "sectionId": 1700,
          "sectionTitle": "Hata Yönetimi",
          "sectionDescription": "Uygulama çalışırken oluşabilecek hataların yakalanması, yönetilmesi ve debug edilmesi",
          "order": 7,
          "topics": [
            {
              "topicId": 1701,
              "title": "try-catch",
              "summary": "try-catch yapısı, çalışma zamanında (runtime) oluşabilecek hataları yakalayarak uygulamanın çökmesini engeller. Kotlin'de hataya neden olabilecek kodlar try bloğuna yazılır ve oluşan hata catch bloğunda ele alınır.",
              "content": "## try-catch\n\ntry-catch, özellikle kullanıcı girdileri, network işlemleri ve dosya okuma gibi riskli işlemlerde kullanılır.\n\nKotlin'de birden fazla catch bloğu tanımlanabilir ve finally bloğu isteğe bağlıdır.\n\ntry-catch bir expression olarak da kullanılabilir ve değer döndürebilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit try-catch Kullanımı",
                  "code": "try {\n    val number = \"10a\".toInt()\n} catch (e: NumberFormatException) {\n    println(\"Hatalı sayı formatı\")\n}",
                  "explanation": "String değeri Int'e çevrilirken hata oluşur ve catch bloğu çalışır."
                },
                {
                  "title": "try-catch Expression",
                  "code": "val result = try {\n    10 / 2\n} catch (e: Exception) {\n    0\n}",
                  "explanation": "try-catch bir değer döndürebilir."
                }
              ],
              "keyPoints": [
                "Runtime hatalarını yakalamak için kullanılır",
                "Birden fazla catch bloğu yazılabilir",
                "finally isteğe bağlıdır",
                "try-catch expression olarak kullanılabilir"
              ],
              "questions": [
                {
                  "questionId": 170101,
                  "question": "try-catch yapısının temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Compile-time hataları yakalamak",
                    "Runtime hataları yakalamak",
                    "Performansı artırmak",
                    "Değişken tanımlamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "try-catch runtime sırasında oluşan hataları yakalamak için kullanılır.",
                  "tags": ["try-catch"]
                }
              ]
            },
            {
              "topicId": 1702,
              "title": "Exception",
              "summary": "Exception, uygulama çalışırken meydana gelen beklenmeyen hataları temsil eden nesnelerdir. Kotlin'de tüm exception'lar Exception sınıfından türetilir.",
              "content": "## Exception\n\nException'lar programın normal akışını bozar.\n\nKotlin'de checked exception yoktur, bu da kodu daha sade hale getirir.\n\nGeliştirici isterse kendi custom exception sınıflarını da oluşturabilir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Exception Fırlatma",
                  "code": "fun divide(a: Int, b: Int): Int {\n    if (b == 0) {\n        throw IllegalArgumentException(\"Bölen 0 olamaz\")\n    }\n    return a / b\n}",
                  "explanation": "Hatalı durumlarda manuel olarak exception fırlatılabilir."
                }
              ],
              "keyPoints": [
                "Tüm exception'lar Exception sınıfından türetilir",
                "Kotlin'de checked exception yoktur",
                "throw ile manuel exception fırlatılabilir",
                "Custom exception tanımlanabilir"
              ],
              "questions": [
                {
                  "questionId": 170201,
                  "question": "Kotlin'de checked exception var mı?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet",
                    "Hayır",
                    "Sadece Android'de var",
                    "Sadece JVM'de var"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de checked exception yoktur.",
                  "tags": ["exception"]
                }
              ]
            },
            {
              "topicId": 1703,
              "title": "Debug Mantığı",
              "summary": "Debug mantığı, uygulamada oluşan hataların nedenini bulmak ve çözmek için kullanılan sistematik yaklaşımdır. Loglama, breakpoint ve stack trace analizi bu sürecin temel parçalarıdır.",
              "content": "## Debug Mantığı\n\nDebug sürecinde hatanın nerede ve neden oluştuğu analiz edilir.\n\nAndroid Studio debugger, Logcat ve stack trace bu süreçte en önemli araçlardır.\n\nHataları sadece çözmek değil, tekrar oluşmasını engellemek de hedeflenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Log ile Debug",
                  "code": "Log.d(\"DEBUG\", \"Butona tıklandı\")",
                  "explanation": "Log mesajları uygulamanın akışını takip etmek için kullanılır."
                }
              ],
              "keyPoints": [
                "Breakpoint ile kod adım adım çalıştırılabilir",
                "Stack trace hatanın kaynağını gösterir",
                "Loglama debug sürecini kolaylaştırır",
                "Hatanın kök nedeni bulunmalıdır"
              ],
              "questions": [
                {
                  "questionId": 170301,
                  "question": "Stack trace neyi gösterir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI hatalarını",
                    "Memory kullanımını",
                    "Hatanın oluştuğu çağrı zincirini",
                    "Network trafiğini"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Stack trace hatanın hangi method çağrılarında oluştuğunu gösterir.",
                  "tags": ["debug"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 19001,
            "question": "Kotlin'de hata yakalamak için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "if-else",
              "try-catch",
              "when",
              "throw-catch"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de runtime hataları yakalamak için try-catch bloğu kullanılır.",
            "tags": ["try_catch", "exception"]
          },
          {
            "questionId": 19002,
            "question": "Aşağıdakilerden hangisi runtime exception örneğidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Syntax error",
              "NullPointerException",
              "Import hatası",
              "Derleme uyarısı"
            ],
            "correctAnswerIndex": 1,
            "explanation": "NullPointerException, uygulama çalışırken oluşan bir runtime exception'dır.",
            "tags": ["runtime_exception"]
          },
          {
            "questionId": 19003,
            "question": "Aşağıdaki kodda hangi durumda exception oluşur?",
            "questionType": "multiple_choice",
            "code": "val number = 10\nprintln(number / 0)",
            "difficulty": "easy",
            "options": [
              "Compile-time",
              "ArithmeticException",
              "NullPointerException",
              "Hiçbir hata oluşmaz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Sıfıra bölme işlemi ArithmeticException fırlatır.",
            "tags": ["exception", "arithmetic"]
          },
          {
            "questionId": 19004,
            "question": "Kotlin'de finally bloğunun amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Sadece hata oluştuğunda çalışır",
              "Exception fırlatmak için kullanılır",
              "Her durumda çalışır",
              "Sadece try başarılıysa çalışır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "finally bloğu, exception oluşsa da oluşmasa da her zaman çalışır.",
            "tags": ["finally"]
          },
          {
            "questionId": 19005,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "try {\n    val list = listOf(1, 2, 3)\n    println(list[5])\n} catch (e: Exception) {\n    println(\"Hata\")\n}",
            "difficulty": "medium",
            "options": [
              "5",
              "Compile-time hatası",
              "Hata",
              "Uygulama kapanır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "IndexOutOfBoundsException oluşur ve catch bloğu çalışır.",
            "tags": ["try_catch", "index"]
          },
          {
            "questionId": 19006,
            "question": "Exception fırlatmak için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "throw",
              "throws",
              "exception",
              "error"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de exception fırlatmak için throw anahtar kelimesi kullanılır.",
            "tags": ["throw"]
          },
          {
            "questionId": 19007,
            "question": "Aşağıdakilerden hangisi debug sürecinde en çok kullanılan yöntemlerden biridir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulamayı silip tekrar kurmak",
              "Print/Log kullanmak",
              "Random değerler denemek",
              "Kodları silmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Log veya print kullanımı, hata ayıklamada temel ve etkili bir yöntemdir.",
            "tags": ["debug", "log"]
          },
          {
            "questionId": 19008,
            "question": "Stack trace neyi ifade eder?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulamanın performansını",
              "Hatanın oluştuğu method zincirini",
              "Bellek kullanımını",
              "UI hatalarını"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Stack trace, hatanın hangi method çağrıları sonucunda oluştuğunu gösterir.",
            "tags": ["stacktrace", "debug"]
          },
          {
            "questionId": 19009,
            "question": "Kotlin'de try-catch bir ifade (expression) olarak kullanılabilir mi?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Hayır",
              "Sadece Java'da",
              "Evet",
              "Sadece finally ile"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de try-catch bir expression'dır ve değer döndürebilir.",
            "tags": ["expression", "try_catch"]
          },
          {
            "questionId": 19010,
            "question": "En sağlıklı debug yaklaşımı aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Deneme-yanılma",
              "Breakpoint ve adım adım inceleme",
              "Kodun tamamını yazmak",
              "Exception'ları görmezden gelmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Breakpoint kullanarak kodu adım adım incelemek, hatanın kök nedenini bulmada en etkili yöntemdir.",
            "tags": ["debug", "breakpoint"]
          }
        ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 90001,
          "question": "Kotlin'de değiştirilemeyen değişken hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["var", "val", "let", "const"],
          "correctAnswerIndex": 1,
          "explanation": "val immutable değişkenler için kullanılır.",
          "tags": ["val", "variables"]
        },
        {
          "questionId": 90002,
          "question": "Aşağıdaki veri tiplerinden hangisi kesirli sayı tutar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["Int", "Long", "Float", "Boolean"],
          "correctAnswerIndex": 2,
          "explanation": "Float ve Double kesirli sayılar içindir.",
          "tags": ["float", "double"]
        },
        {
          "questionId": 90003,
          "question": "when yapısı neyin alternatifidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["for", "while", "if-else zinciri", "try-catch"],
          "correctAnswerIndex": 2,
          "explanation": "when, if-else zincirlerinin daha okunabilir halidir.",
          "tags": ["when"]
        },
        {
          "questionId": 90004,
          "question": "Aşağıdaki döngülerden hangisi koşul yanlış olsa bile en az bir kez çalışır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["for", "while", "do-while", "repeat"],
          "correctAnswerIndex": 2,
          "explanation": "do-while döngüsü en az bir kez çalışır.",
          "tags": ["loop"]
        },
        {
          "questionId": 90005,
          "question": "Hangi koleksiyon türü benzersiz (unique) elemanlar tutar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["List", "Array", "Set", "Map"],
          "correctAnswerIndex": 2,
          "explanation": "Set aynı elemandan birden fazla tutmaz.",
          "tags": ["set"]
        },
        {
          "questionId": 90006,
          "question": "Map koleksiyonunda veriler nasıl tutulur?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Sadece değer",
            "Index ve değer",
            "Key - Value",
            "Liste şeklinde"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Map key-value yapısıyla çalışır.",
          "tags": ["map"]
        },
        {
          "questionId": 90007,
          "question": "Fonksiyonun bir değer döndürmesini sağlayan yapı hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["print", "return", "break", "continue"],
          "correctAnswerIndex": 1,
          "explanation": "return fonksiyondan değer döndürür.",
          "tags": ["functions"]
        },
        {
          "questionId": 90008,
          "question": "Nullable bir değişken nasıl tanımlanır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["String name", "String! name", "String? name", "nullable String"],
          "correctAnswerIndex": 2,
          "explanation": "Kotlin'de nullable değişkenler '?' ile tanımlanır.",
          "tags": ["null_safety"]
        },
        {
          "questionId": 90009,
          "question": "Elvis operatörü (?:) ne işe yarar?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Null kontrolü yapar",
            "Exception fırlatır",
            "Null ise varsayılan değer döndürür",
            "Tip dönüşümü yapar"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Null durumunda alternatif değer döndürür.",
          "tags": ["elvis"]
        },
        {
          "questionId": 90010,
          "question": "lateinit ile ilgili hangisi doğrudur?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "val ile kullanılır",
            "Primitive tiplerde kullanılır",
            "Sonradan initialize edilir",
            "Nullable olmak zorundadır"
          ],
          "correctAnswerIndex": 2,
          "explanation": "lateinit, non-null var değişkenlerde kullanılır.",
          "tags": ["lateinit"]
        },
        {
          "questionId": 90011,
          "question": "Bir sınıfın miras alınabilmesi için hangi anahtar kelime gerekir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": ["abstract", "open", "override", "protected"],
          "correctAnswerIndex": 1,
          "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır.",
          "tags": ["inheritance"]
        },
        {
          "questionId": 90012,
          "question": "Encapsulation'ın temel amacı nedir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Performans artırmak",
            "Veriyi gizlemek",
            "Kod kısaltmak",
            "UI ayırmak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Encapsulation veri güvenliği sağlar.",
          "tags": ["encapsulation"]
        },
        {
          "questionId": 90013,
          "question": "Polymorphism neyi ifade eder?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Çoklu constructor",
            "Aynı metodun farklı davranışı",
            "Veri gizleme",
            "Tek sorumluluk"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Override edilen fonksiyonlar polymorphism örneğidir.",
          "tags": ["polymorphism"]
        },
        {
          "questionId": 90014,
          "question": "Lambda nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "İsimsiz sınıf",
            "İsimsiz fonksiyon",
            "Interface",
            "Değişken"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Lambda isimsiz fonksiyonlardır.",
          "tags": ["lambda"]
        },
        {
          "questionId": 90015,
          "question": "map fonksiyonu ne yapar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Filtreler",
            "Dönüştürür",
            "Siler",
            "Sıralar"
          ],
          "correctAnswerIndex": 1,
          "explanation": "map her elemanı dönüştürür.",
          "tags": ["map"]
        },
        {
          "questionId": 90016,
          "question": "let scope fonksiyonu genellikle ne için kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Nesne oluşturmak",
            "Yan etki",
            "Null kontrolü",
            "Thread yönetimi"
          ],
          "correctAnswerIndex": 2,
          "explanation": "let genellikle nullable işlemler için kullanılır.",
          "tags": ["scope"]
        },
        {
          "questionId": 90017,
          "question": "Exception fırlatmak için hangi anahtar kelime kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["throw", "throws", "catch", "error"],
          "correctAnswerIndex": 0,
          "explanation": "throw exception fırlatır.",
          "tags": ["exception"]
        },
        {
          "questionId": 90018,
          "question": "finally bloğu ne zaman çalışır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Sadece hata olunca",
            "Sadece try başarılıysa",
            "Her durumda",
            "Hiçbir zaman"
          ],
          "correctAnswerIndex": 2,
          "explanation": "finally her koşulda çalışır.",
          "tags": ["finally"]
        },
        {
          "questionId": 90019,
          "question": "Stack trace neyi gösterir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "UI hatasını",
            "Hata oluşan method zincirini",
            "Performansı",
            "Bellek durumunu"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Stack trace hata yolunu gösterir.",
          "tags": ["debug"]
        },
        {
          "questionId": 90020,
          "question": "Kotlin'de try-catch bir expression olabilir mi?",
          "questionType": "multiple_choice",
          "difficulty": "hard",
          "options": ["Hayır", "Sadece Java'da", "Evet", "Sadece finally ile"],
          "correctAnswerIndex": 2,
          "explanation": "Kotlin'de try-catch değer döndürebilir.",
          "tags": ["try_catch"]
        }
      ]
    },
    {
      "categoryId": 2,
      "categoryTitle": "Android Temelleri",
      "categoryDescription": "Android uygulama geliştirmenin temel kavramları",
      "order": 2,
      "sections": [
        {
          "sectionId": 2100,
          "sectionTitle": "Android’e Giriş",
          "sectionDescription": "Android işletim sisteminin temel yapısı ve Android uygulama geliştirmenin genel mantığı",
          "order": 1,
          "topics": [
            {
              "topicId": 2101,
              "title": "Android Nedir",
              "summary": "Android, Google tarafından geliştirilen, Linux tabanlı, açık kaynaklı bir mobil işletim sistemidir. Akıllı telefonlar, tabletler, TV’ler ve giyilebilir cihazlarda yaygın olarak kullanılır. Android uygulamaları genellikle Kotlin veya Java dili ile geliştirilir.",
              "content": "## Android Nedir\n\nAndroid, mobil cihazlar için geliştirilmiş bir işletim sistemidir.\n\nAçık kaynaklı yapısı sayesinde birçok üretici tarafından özelleştirilerek kullanılır.\n\nAndroid uygulamaları, Android SDK ve Android Studio kullanılarak geliştirilir.\n\nGoogle Play Store, Android uygulamalarının dağıtıldığı resmi platformdur.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Linux tabanlı bir işletim sistemidir",
                "Google tarafından geliştirilir",
                "Açık kaynaklıdır",
                "Kotlin ve Java ile uygulama geliştirilir",
                "Google Play Store üzerinden dağıtılır"
              ],
              "questions": [
                {
                  "questionId": 210101,
                  "question": "Android işletim sistemi hangi şirket tarafından geliştirilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Apple",
                    "Microsoft",
                    "Google",
                    "Samsung"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android, Google tarafından geliştirilen açık kaynaklı bir mobil işletim sistemidir.",
                  "tags": ["android", "temel"]
                },
                {
                  "questionId": 210102,
                  "question": "Android hangi işletim sistemi çekirdeğini kullanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Windows NT",
                    "Linux",
                    "macOS",
                    "Unix"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android, Linux tabanlı bir işletim sistemidir ve Linux çekirdeğini kullanır.",
                  "tags": ["android", "linux"]
                },
                {
                  "questionId": 210103,
                  "question": "Android uygulamaları hangi programlama dilleri ile geliştirilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Swift ve Objective-C",
                    "C# ve VB.NET",
                    "Kotlin ve Java",
                    "Python ve Ruby"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android uygulamaları genellikle Kotlin veya Java dili ile geliştirilir. Google, resmi olarak Kotlin'i tercih etmektedir.",
                  "tags": ["android", "kotlin", "java"]
                },
                {
                  "questionId": 210104,
                  "question": "Android uygulamalarının resmi dağıtım platformu hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "App Store",
                    "Microsoft Store",
                    "Google Play Store",
                    "Amazon Appstore"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Google Play Store, Android uygulamalarının dağıtıldığı resmi platformdur.",
                  "tags": ["android", "play_store"]
                },
                {
                  "questionId": 210105,
                  "question": "Android'in açık kaynaklı olması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Herkes ücretsiz kullanabilir ama değiştiremez",
                    "Sadece Google geliştirebilir",
                    "Kaynak kodları açıktır ve özelleştirilebilir",
                    "Sadece büyük şirketler kullanabilir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Açık kaynaklı olması, Android'in kaynak kodlarının herkese açık olduğu ve cihaz üreticileri tarafından özelleştirilebileceği anlamına gelir.",
                  "tags": ["android", "open_source"]
                },
                {
                  "questionId": 210106,
                  "question": "Android uygulamaları geliştirmek için hangi IDE kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Visual Studio",
                    "Xcode",
                    "Android Studio",
                    "Eclipse"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android Studio, Google'ın resmi olarak desteklediği ve Android SDK'sını içeren entegre geliştirme ortamıdır.",
                  "tags": ["android", "android_studio"]
                },
                {
                  "questionId": 210107,
                  "question": "Android hangi tür cihazlarda kullanılmaz?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Akıllı telefonlar",
                    "Tabletler",
                    "iPhone",
                    "Akıllı TV'ler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "iPhone cihazları iOS işletim sistemini kullanır. Android, akıllı telefonlar, tabletler, TV'ler ve giyilebilir cihazlarda kullanılır.",
                  "tags": ["android", "devices"]
                }
              ]
            },
            {
              "topicId": 2102,
              "title": "Android Proje Yapısı",
              "summary": "Android proje yapısı, uygulamanın kod, kaynak dosyaları ve konfigürasyonlarının düzenli bir şekilde tutulmasını sağlar. Android Studio’da oluşturulan her proje belirli klasör ve dosya yapısına sahiptir.",
              "content": "## Android Proje Yapısı\n\nAndroid projeleri modüler bir yapıya sahiptir.\n\nTemel olarak Java/Kotlin kodları, XML arayüz dosyaları ve uygulama ayarları ayrı klasörlerde tutulur.\n\nBu yapı, büyük projelerin daha yönetilebilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Temel Proje Yapısı",
                  "code": "app/\n ├─ java/ (veya kotlin/)\n │   └─ MainActivity.kt\n ├─ res/\n │   ├─ layout/\n │   ├─ drawable/\n │   └─ values/\n └─ AndroidManifest.xml",
                  "explanation": "Android projelerinde temel klasör ve dosyaların genel görünümü."
                }
              ],
              "keyPoints": [
                "java/kotlin: Uygulama kodları",
                "res/layout: XML arayüz dosyaları",
                "res/drawable: Görseller",
                "res/values: Renk, stil ve string tanımları",
                "AndroidManifest.xml: Uygulama yapılandırması"
              ],
              "questions": [
                {
                  "questionId": 210201,
                  "question": "Android projelerinde uygulama kodları hangi klasörde bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "res/",
                    "java/ veya kotlin/",
                    "drawable/",
                    "manifest/"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Uygulama kodları (Activity, Fragment vb.) java/ veya kotlin/ klasöründe tutulur.",
                  "tags": ["android", "proje_yapisi"]
                },
                {
                  "questionId": 210202,
                  "question": "XML arayüz dosyaları hangi klasörde bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "res/drawable/",
                    "res/values/",
                    "res/layout/",
                    "java/"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "XML arayüz (layout) dosyaları res/layout/ klasöründe tutulur.",
                  "tags": ["android", "layout", "xml"]
                },
                {
                  "questionId": 210203,
                  "question": "AndroidManifest.xml dosyasının amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Activity'leri tanımlar",
                    "Uygulama görsellerini saklar",
                    "Uygulama yapılandırması ve izinlerini tanımlar",
                    "Kod derlemesini sağlar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "AndroidManifest.xml, uygulamanın temel yapılandırmasını, Activity'leri, Service'leri, izinleri ve diğer bileşenleri tanımlar.",
                  "tags": ["android", "manifest"]
                },
                {
                  "questionId": 210204,
                  "question": "res/drawable klasörü ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "String değerler",
                    "Görseller ve çizilebilir kaynaklar",
                    "Kod dosyaları",
                    "Veritabanı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "res/drawable/ klasörü, görseller, icon'lar ve diğer çizilebilir kaynaklar için kullanılır.",
                  "tags": ["android", "drawable", "resources"]
                },
                {
                  "questionId": 210205,
                  "question": "res/values klasöründe hangi dosyalar bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece renkler",
                    "Sadece string'ler",
                    "Renk, stil, string ve boyut tanımları",
                    "Sadece Activity'ler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "res/values/ klasöründe strings.xml, colors.xml, styles.xml, dimens.xml gibi kaynak dosyaları bulunur.",
                  "tags": ["android", "values", "resources"]
                },
                {
                  "questionId": 210206,
                  "question": "Aşağıdaki proje yapısında MainActivity.kt dosyası hangi klasördedir?",
                  "questionType": "multiple_choice",
                  "code": "app/\n ├─ kotlin/\n │   └─ MainActivity.kt\n ├─ res/\n │   ├─ layout/\n │   └─ drawable/\n └─ AndroidManifest.xml",
                  "difficulty": "easy",
                  "options": [
                    "res/layout/",
                    "kotlin/",
                    "res/drawable/",
                    "AndroidManifest/"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MainActivity.kt, uygulama kodlarının bulunduğu kotlin/ klasöründedir.",
                  "tags": ["android", "proje_yapisi"]
                },
                {
                  "questionId": 210207,
                  "question": "Android projelerinin modüler yapıda olmasının avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha hızlı derleme",
                    "Daha küçük APK boyutu",
                    "Büyük projelerin daha yönetilebilir olması",
                    "Daha az bellek kullanımı"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Modüler yapı, kod, kaynak ve konfigürasyonların ayrı tutulmasını sağlayarak büyük projelerin daha kolay yönetilmesini sağlar.",
                  "tags": ["android", "modular"]
                },
                {
                  "questionId": 210208,
                  "question": "Bir Android projesinde build.gradle dosyasının rolü nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Arayüz tasarımı",
                    "Proje bağımlılıkları ve derleme ayarları",
                    "Veritabanı şeması",
                    "Kullanıcı izinleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "build.gradle dosyası, projenin bağımlılıklarını (dependency), minimum SDK versiyonunu, hedef SDK'yı ve derleme ayarlarını içerir.",
                  "tags": ["android", "gradle", "build"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 210001,
              "question": "Android uygulamalarını geliştirmek için hangi IDE ve hangi diller kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Xcode, Swift",
                "Android Studio, Kotlin/Java",
                "Visual Studio, C#",
                "Eclipse, Python"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Android uygulamaları Android Studio IDE'si kullanılarak Kotlin veya Java ile geliştirilir.",
              "tags": ["android", "ide", "kotlin"]
            },
            {
              "questionId": 210002,
              "question": "Android'in açık kaynaklı olması geliştiricilere nasıl bir avantaj sağlar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece bedava kullanım",
                "Kaynak kodları inceleyip özelleştirebilme",
                "Daha hızlı çalışma",
                "Otomatik güncelleme"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Açık kaynak, geliştiricilerin Android kaynak kodlarını incelemesine ve cihaz üreticilerinin özelleştirmesine olanak tanır.",
              "tags": ["android", "open_source"]
            },
            {
              "questionId": 210003,
              "question": "Bir Android projesinde uygulama izinleri nerede tanımlanır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "MainActivity.kt",
                "build.gradle",
                "AndroidManifest.xml",
                "strings.xml"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Uygulama izinleri (permissions) AndroidManifest.xml dosyasında tanımlanır.",
              "tags": ["android", "permissions", "manifest"]
            },
            {
              "questionId": 210004,
              "question": "res/layout ve res/values klasörlerinin ortak özelliği nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "İkisi de kod dosyası içerir",
                "İkisi de kaynak (resource) dosyası içerir",
                "İkisi de görsel içerir",
                "İkisi de Java dosyası içerir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Her ikisi de res/ klasörü altında kaynak dosyaları içerir. layout XML arayüzleri, values ise string, renk gibi değerleri tutar.",
              "tags": ["android", "resources"]
            },
            {
              "questionId": 210005,
              "question": "Android'de Linux çekirdeği kullanılmasının avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece performans artışı",
                "Güvenlik, bellek yönetimi ve donanım soyutlaması",
                "Sadece açık kaynak lisansı",
                "Sadece çoklu görev desteği"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Linux çekirdeği, güvenlik, bellek yönetimi, süreç yönetimi ve donanım soyutlaması gibi temel işlevler sağlar.",
              "tags": ["android", "linux", "kernel"]
            },
            {
              "questionId": 210006,
              "question": "Aşağıdakilerden hangisi Android Studio'nun bir parçası değildir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Layout Editor",
                "Emulator",
                "Xcode Interface Builder",
                "Gradle Build System"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Xcode Interface Builder, Apple'ın iOS geliştirme aracıdır ve Android Studio'nun bir parçası değildir.",
              "tags": ["android", "android_studio"]
            },
            {
              "questionId": 210007,
              "question": "Bir Android uygulamasının APK dosyası nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Android kaynak kodu",
                "Android uygulama paketi (yüklenebilir dosya)",
                "Android proje dosyası",
                "Android manifest dosyası"
              ],
              "correctAnswerIndex": 1,
              "explanation": "APK (Android Package Kit), Android uygulamalarının dağıtım ve kurulum formatıdır.",
              "tags": ["android", "apk"]
            },
            {
              "questionId": 210008,
              "question": "MainActivity.kt ve activity_main.xml dosyaları arasındaki ilişki nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "İkisi de aynı dosyadır",
                "MainActivity.kt kodu, activity_main.xml arayüzünü kullanır",
                "activity_main.xml kodu, MainActivity.kt'yi çağırır",
                "Hiçbir ilişki yoktur"
              ],
              "correctAnswerIndex": 1,
              "explanation": "MainActivity.kt (kod), activity_main.xml (arayüz) dosyasını setContentView() ile bağlar ve kullanır.",
              "tags": ["android", "activity", "layout"]
            },
            {
              "questionId": 210009,
              "question": "Google Play Store'a uygulama yüklemek için hangi dosya formatı kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "EXE",
                "APK veya AAB",
                "IPA",
                "ZIP"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Google Play Store'a APK (Android Package) veya AAB (Android App Bundle) formatında uygulama yüklenir.",
              "tags": ["android", "play_store", "apk"]
            },
            {
              "questionId": 210010,
              "question": "Android projelerinde build.gradle ve AndroidManifest.xml'in ortak önemi nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "İkisi de sadece görsel tasarım içerir",
                "İkisi de proje yapılandırması için kritiktir",
                "İkisi de veritabanı yönetir",
                "İkisi de kod derlemesi yapar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "build.gradle derleme ayarlarını ve bağımlılıkları, AndroidManifest.xml ise uygulama bileşenlerini ve izinleri yapılandırır. İkisi de proje için kritik öneme sahiptir.",
              "tags": ["android", "configuration"]
            }
          ]
        },
        {
            "sectionId": 2200,
            "sectionTitle": "Layout & UI",
            "sectionDescription": "Android uygulamalarda kullanıcı arayüzü oluşturma ve layout yapıları",
            "order": 2,
            "topics": [
            {
              "topicId": 2201,
              "title": "XML Nedir",
              "summary": "XML, Android'de kullanıcı arayüzlerini tanımlamak için kullanılan işaretleme dilidir. Görünümlerin hiyerarşisi, boyutları ve özellikleri XML dosyaları içerisinde tanımlanır.",
              "content": "## XML Nedir\n\nAndroid'de UI genellikle XML dosyaları ile oluşturulur.\n\nBu yapı, tasarım ve iş mantığını ayırarak kodun daha okunabilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit XML Örneği",
                  "code": "<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Merhaba Android\" />",
                  "explanation": "Basit bir TextView tanımı."
                }
              ],
              "keyPoints": [
                "UI XML ile tanımlanır",
                "Koddan bağımsızdır",
                "Okunabilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 220101,
                  "question": "Android'de kullanıcı arayüzü hangi dil ile tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "JSON",
                    "HTML",
                    "XML",
                    "CSS"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android'de UI genellikle XML (eXtensible Markup Language) ile tanımlanır.",
                  "tags": ["xml", "ui"]
                },
                {
                  "questionId": 220102,
                  "question": "XML ile UI tanımlamanın avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Daha hızlı çalışır",
                    "Tasarım ve iş mantığını ayırır",
                    "Daha az bellek kullanır",
                    "Otomatik güncelleme sağlar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "XML kullanımı, tasarım ve kod mantığını ayırarak kodun daha okunabilir ve yönetilebilir olmasını sağlar.",
                  "tags": ["xml", "separation"]
                },
                {
                  "questionId": 220103,
                  "question": "Aşağıdaki XML kodunda TextView'in genişliği ne kadardır?",
                  "questionType": "multiple_choice",
                  "code": "<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Merhaba\" />",
                  "difficulty": "medium",
                  "options": [
                    "Ekranın tamamı kadar",
                    "İçeriği kadar",
                    "Sabit 100dp",
                    "Parent kadar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "wrap_content, view'in genişliğini/yüksekliğini içeriği kadar yapar.",
                  "tags": ["xml", "wrap_content"]
                }
              ]
            },
            {
              "topicId": 2202,
              "title": "View Nedir",
              "summary": "View, Android'de ekranda görünen en temel UI bileşenidir. Button, TextView, EditText gibi tüm arayüz elemanları View sınıfından türetilir.",
              "content": "## View Nedir\n\nView, kullanıcı ile etkileşime giren temel bileşendir.\n\nTüm UI elemanları View veya ViewGroup'tan türetilir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "UI'nin temel yapı taşıdır",
                "Tıklama ve dokunma olaylarını alır",
                "ViewGroup içinde yer alır"
              ],
              "questions": [
                {
                  "questionId": 220201,
                  "question": "View nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı tablosu",
                    "Ekranda görünen temel UI bileşeni",
                    "Network isteği",
                    "Dosya sistemi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View, Android'de ekranda görünen en temel UI bileşenidir.",
                  "tags": ["view", "ui"]
                },
                {
                  "questionId": 220202,
                  "question": "Aşağıdakilerden hangisi View sınıfından türemez?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Button",
                    "TextView",
                    "Activity",
                    "EditText"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Activity bir UI bileşeni değildir. Button, TextView, EditText gibi tüm UI elemanları View sınıfından türer.",
                  "tags": ["view", "inheritance"]
                },
                {
                  "questionId": 220203,
                  "question": "ViewGroup nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece metin gösteren view",
                    "Diğer view'leri içeren özel bir View",
                    "Veritabanı grubu",
                    "Sadece resim gösteren view"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewGroup, diğer view'leri içerebilen özel bir View türüdür. LinearLayout, ConstraintLayout gibi layout'lar ViewGroup'tur.",
                  "tags": ["viewgroup", "layout"]
                }
              ]
            },
            {
              "topicId": 2203,
              "title": "LinearLayout",
              "summary": "LinearLayout, View'leri yatay veya dikey olarak sıralayan bir layout türüdür. orientation özelliği ile dizilim yönü belirlenir.",
              "content": "## LinearLayout\n\nBasit ve anlaşılır bir layout yapısıdır.\n\nİç içe kullanımı performans sorunlarına yol açabilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "LinearLayout Örneği",
                  "code": "<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView />\n    <Button />\n</LinearLayout>",
                  "explanation": "Dikey dizilimli LinearLayout."
                }
              ],
              "keyPoints": [
                "orientation: vertical / horizontal",
                "Basit dizilimler için idealdir",
                "Derin hiyerarşiden kaçınılmalı"
              ],
              "questions": [
                {
                  "questionId": 220301,
                  "question": "LinearLayout'ta orientation özelliği ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Renk belirler",
                    "Yatay veya dikey dizilim belirler",
                    "Boyut belirler",
                    "Arka plan belirler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "orientation özelliği ile view'lerin yatay (horizontal) veya dikey (vertical) dizilimi belirlenir.",
                  "tags": ["linearlayout", "orientation"]
                },
                {
                  "questionId": 220302,
                  "question": "Aşağıdaki LinearLayout'ta view'ler nasıl dizilir?",
                  "questionType": "multiple_choice",
                  "code": "<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView />\n    <Button />\n</LinearLayout>",
                  "difficulty": "easy",
                  "options": [
                    "Yan yana yatay",
                    "Alt alta dikey",
                    "Üst üste",
                    "Rastgele"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "orientation=\"vertical\" olduğu için view'ler alt alta dikey olarak dizilir.",
                  "tags": ["linearlayout", "vertical"]
                },
                {
                  "questionId": 220303,
                  "question": "LinearLayout'un performans açısından dezavantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Çok az view alır",
                    "İç içe kullanımda performans düşer",
                    "Sadece yatay çalışır",
                    "Renk desteklemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Derin hiyerarşi (nested layout) oluşturulduğunda performans sorunlarına yol açar.",
                  "tags": ["linearlayout", "performance"]
                },
                {
                  "questionId": 220304,
                  "question": "LinearLayout hangi basit UI'lar için idealdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Karmaşık form ekranları",
                    "Basit liste ve dikey/yatay dizilimler",
                    "3D grafikler",
                    "Video oynatıcı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LinearLayout basit, düz dizilimler için idealdir. Karmaşık UI'lar için ConstraintLayout önerilir.",
                  "tags": ["linearlayout", "use_case"]
                }
              ]
            },
            {
              "topicId": 2204,
              "title": "ConstraintLayout",
              "summary": "ConstraintLayout, View'leri birbirine ve parent'a göre konumlandırmaya olanak tanıyan güçlü bir layout türüdür. Performans açısından en çok önerilen layout yapısıdır.",
              "content": "## ConstraintLayout\n\nEsnek ve performanslıdır.\n\nTek layout içinde karmaşık arayüzler oluşturulabilir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Performans dostudur",
                "Karmaşık UI'lar için idealdir",
                "Constraint mantığı kullanır"
              ],
              "questions": [
                {
                  "questionId": 220401,
                  "question": "ConstraintLayout'un en büyük avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece basit UI'lar oluşturur",
                    "Performanslı ve esnek UI oluşturur",
                    "Sadece liste gösterir",
                    "XML kullanmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde performanslı şekilde oluşturmaya olanak tanır.",
                  "tags": ["constraintlayout", "performance"]
                },
                {
                  "questionId": 220402,
                  "question": "ConstraintLayout'ta view'ler nasıl konumlandırılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece parent'a göre",
                    "Sadece dikey dizilim",
                    "Birbirine ve parent'a göre constraint'lerle",
                    "Otomatik rastgele"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "ConstraintLayout'ta view'ler birbirine veya parent'a göre constraint (kısıtlama) ile konumlandırılır.",
                  "tags": ["constraintlayout", "constraint"]
                },
                {
                  "questionId": 220403,
                  "question": "ConstraintLayout hangi layout ihtiyacını azaltır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "RecyclerView",
                    "Nested (iç içe) layout",
                    "Fragment",
                    "Activity"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout sayesinde karmaşık UI'lar tek layout içinde oluşturulabildiği için nested layout ihtiyacı azalır.",
                  "tags": ["constraintlayout", "nested"]
                },
                {
                  "questionId": 220404,
                  "question": "Android Studio'da ConstraintLayout ile görsel tasarım yapan araç nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Emulator",
                    "Layout Editor",
                    "Logcat",
                    "Gradle"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android Studio'nun Layout Editor'ü ile ConstraintLayout'lar görsel olarak tasarlanabilir.",
                  "tags": ["constraintlayout", "layout_editor"]
                },
                {
                  "questionId": 220405,
                  "question": "ConstraintLayout hangi tür projeler için en çok önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece metin tabanlı uygulamalar",
                    "Karmaşık ve çok ekranlı modern uygulamalar",
                    "Sadece oyun uygulamaları",
                    "Sadece widget'lar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, performansı ve esnekliği sayesinde modern ve karmaşık Android uygulamaları için en çok önerilen layout türüdür.",
                  "tags": ["constraintlayout", "best_practice"]
                }
              ]
            },
            {
              "topicId": 2205,
              "title": "Nested Layout",
              "summary": "Nested Layout, layoutların iç içe kullanılmasıdır. Karmaşık arayüzlerde okunabilirliği artırabilir ancak aşırı kullanımı performans sorunlarına yol açar.",
              "content": "## Nested Layout\n\nİç içe layout kullanımı dikkatli yapılmalıdır.\n\nConstraintLayout bu ihtiyacı büyük ölçüde azaltır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "İç içe layout yapısıdır",
                "Performansı olumsuz etkileyebilir",
                "Alternatif olarak ConstraintLayout önerilir"
              ],
              "questions": [
                {
                  "questionId": 220501,
                  "question": "Nested Layout ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Tek layout kullanımı",
                    "Layout'ların iç içe kullanılması",
                    "View'sız layout",
                    "Sadece XML'siz layout"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Nested Layout, layout'ların iç içe kullanılması anlamına gelir.",
                  "tags": ["nested_layout"]
                },
                {
                  "questionId": 220502,
                  "question": "Aşırı nested layout kullanımının dezavantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha az bellek kullanır",
                    "Performansı olumsuz etkiler",
                    "Daha hızlı çalışır",
                    "Kod kısalır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Derin layout hiyerarşisi, view çizim süresini artırarak performansı olumsuz etkiler.",
                  "tags": ["nested_layout", "performance"]
                },
                {
                  "questionId": 220503,
                  "question": "Nested layout yerine hangi yapı önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Daha fazla nested layout",
                    "ConstraintLayout",
                    "Sadece kod ile UI",
                    "XML kullanmamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde oluşturabildiği için nested layout ihtiyacını azaltır.",
                  "tags": ["nested_layout", "alternative"]
                }
              ]
            },
            {
              "topicId": 2206,
              "title": "View Binding",
              "summary": "View Binding, XML'de tanımlanan view'lara güvenli ve kolay erişim sağlayan bir özelliktir. findViewById kullanımını ortadan kaldırır.",
              "content": "## View Binding\n\nDerleme zamanında binding sınıfları oluşturur.\n\nNull safety sağlar ve kodu sadeleştirir.",
              "difficulty": "easy",
              "order": 6,
              "codeExamples": [
                {
                  "title": "View Binding Kullanımı",
                  "code": "val binding = ActivityMainBinding.inflate(layoutInflater)\nsetContentView(binding.root)\n\nbinding.textView.text = \"Merhaba\"",
                  "explanation": "View Binding ile view erişimi."
                }
              ],
              "keyPoints": [
                "findViewById ihtiyacını kaldırır",
                "Null safety sağlar",
                "Kod okunabilirliğini artırır"
              ],
              "questions": [
                {
                  "questionId": 220601,
                  "question": "View Binding'in amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı bağlantısı",
                    "XML'deki view'lara güvenli erişim",
                    "Network isteği",
                    "Animasyon oluşturma"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding, XML'de tanımlanan view'lara güvenli ve kolay erişim sağlar.",
                  "tags": ["view_binding"]
                },
                {
                  "questionId": 220602,
                  "question": "View Binding hangi eski yöntemi ortadan kaldırır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "setContentView",
                    "findViewById",
                    "onCreate",
                    "inflate"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding, findViewById kullanımını ortadan kaldırarak daha güvenli kod yazmamızı sağlar.",
                  "tags": ["view_binding", "findviewbyid"]
                },
                {
                  "questionId": 220603,
                  "question": "View Binding ne zaman oluşturulur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Runtime'da",
                    "Derleme zamanında (compile-time)",
                    "Uygulama ilk açıldığında",
                    "Manuel olarak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding sınıfları derleme zamanında otomatik olarak oluşturulur.",
                  "tags": ["view_binding", "compile_time"]
                },
                {
                  "questionId": 220604,
                  "question": "Aşağıdaki View Binding kodunda binding.textView ne tür bir nesnedir?",
                  "questionType": "multiple_choice",
                  "code": "val binding = ActivityMainBinding.inflate(layoutInflater)\nbinding.textView.text = \"Merhaba\"",
                  "difficulty": "easy",
                  "options": [
                    "String",
                    "TextView",
                    "Button",
                    "Int"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding ile XML'deki textView ID'sine sahip TextView nesnesine doğrudan erişilir.",
                  "tags": ["view_binding", "textview"]
                },
                {
                  "questionId": 220605,
                  "question": "View Binding'in null safety sağlaması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "View'ler asla null olamaz",
                    "Derleme zamanında view varlığı garanti edilir",
                    "Sadece nullable view'ler kullanılır",
                    "Null kontrolü yapmaya gerek kalmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding, XML'de tanımlı view'lere tür güvenli erişim sağlar ve yanlış ID kullanımını derleme zamanında engeller.",
                  "tags": ["view_binding", "null_safety"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 220001,
              "question": "Android'de UI tanımlamak için XML kullanmanın kod yazımından farkı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hiçbir fark yok",
                "XML tasarım ve mantığı ayırır",
                "XML daha yavaştır",
                "XML kullanılamaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "XML ile UI tasarımı, Kotlin/Java kodundan ayrılarak daha okunabilir ve yönetilebilir olur.",
              "tags": ["xml", "separation"]
            },
            {
              "questionId": 220002,
              "question": "LinearLayout yerine ConstraintLayout kullanmanın performans avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "Nested layout ihtiyacını azaltır ve performansı artırır",
                "Sadece daha az kod yazılır",
                "Sadece görsel olarak daha güzeldir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde oluşturarak nested layout kullanımını ve dolayısıyla performans kaybını azaltır.",
              "tags": ["constraintlayout", "performance"]
            },
            {
              "questionId": 220003,
              "question": "findViewById yerine View Binding kullanmanın avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Daha hızlı çalışır",
                "Null safety ve tür güvenliği sağlar",
                "Daha az bellek kullanır",
                "XML'e ihtiyaç kalmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding, findViewById'a göre null safety ve tür güvenliği sağlar, böylece derleme zamanında hata yakalanır.",
              "tags": ["view_binding", "findviewbyid"]
            },
            {
              "questionId": 220004,
              "question": "wrap_content ve match_parent arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hiçbir fark yok",
                "wrap_content içeriği kadar, match_parent parent kadar",
                "wrap_content daha büyük",
                "match_parent sadece yükseklik içindir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "wrap_content view'i içeriği kadar yapar, match_parent ise parent'ın boyutu kadar yapar.",
              "tags": ["layout_params"]
            },
            {
              "questionId": 220005,
              "question": "ViewGroup ve View arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "ViewGroup diğer view'leri içerebilir, View içeremez",
                "ViewGroup sadece metin gösterir",
                "View daha büyüktür",
                "Hiçbir fark yok"
              ],
              "correctAnswerIndex": 0,
              "explanation": "ViewGroup, diğer view'leri (child view) içerebilen özel bir View türüdür. LinearLayout, ConstraintLayout gibi layout'lar ViewGroup'tur.",
              "tags": ["viewgroup", "view"]
            },
            {
              "questionId": 220006,
              "question": "Bir ekranda 5 seviye nested LinearLayout kullanmanın sonucu ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha hızlı çalışır",
                "Performans düşer, layout render süresi artar",
                "Hiçbir etkisi olmaz",
                "Daha az bellek kullanır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Derin nested layout hiyerarşisi, view ölçüm ve çizim süresini artırarak performans düşüşüne yol açar.",
              "tags": ["nested_layout", "performance"]
            },
            {
              "questionId": 220007,
              "question": "ConstraintLayout'ta bir view'i ekranın ortasına konumlandırmak için ne yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir şey yapılmaz, otomatik ortalanır",
                "Tüm kenarları parent'a constraint'lenir",
                "Sadece left constraint'i verilir",
                "LinearLayout kullanılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ConstraintLayout'ta bir view'i ortalamak için tüm kenarları (top, bottom, start, end) parent'a constraint'lenir.",
              "tags": ["constraintlayout", "centering"]
            },
            {
              "questionId": 220008,
              "question": "LinearLayout orientation=\"horizontal\" durumunda view'ler nasıl dizilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Alt alta dikey",
                "Yan yana yatay",
                "Üst üste",
                "Rastgele"
              ],
              "correctAnswerIndex": 1,
              "explanation": "orientation=\"horizontal\" olduğunda view'ler yan yana yatay olarak dizilir.",
              "tags": ["linearlayout", "horizontal"]
            },
            {
              "questionId": 220009,
              "question": "View Binding'i projeye dahil etmek için hangi dosyada ayar yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "AndroidManifest.xml",
                "build.gradle (Module: app)",
                "strings.xml",
                "MainActivity.kt"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding, build.gradle (Module: app) dosyasında viewBinding { enabled = true } şeklinde etkinleştirilir.",
              "tags": ["view_binding", "gradle"]
            },
            {
              "questionId": 220010,
              "question": "Modern Android uygulamalarında UI oluşturmak için en çok önerilen layout ve binding yöntemi hangisidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "LinearLayout + findViewById",
                "ConstraintLayout + View Binding",
                "FrameLayout + findViewById",
                "RelativeLayout + findViewById"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modern Android geliştirmede ConstraintLayout (performans için) ve View Binding (güvenli view erişimi için) birlikte kullanımı önerilir.",
              "tags": ["best_practice", "modern_android"]
            }
          ]
        },
        {
          "sectionId": 2300,
          "sectionTitle": "Activity & Lifecycle",
          "sectionDescription": "Android uygulamalarda Activity kavramı, yaşam döngüsü ve Context kullanımı",
          "order": 3,
          "topics": [
            {
              "topicId": 2301,
              "title": "Activity Nedir",
              "summary": "Activity, Android uygulamalarda kullanıcıya gösterilen tek bir ekranı temsil eder. Uygulama içerisindeki her ekran genellikle bir Activity veya Fragment tarafından yönetilir.",
              "content": "## Activity Nedir\n\nActivity, kullanıcı ile etkileşime girilen temel bileşendir.\n\nBir uygulama birden fazla Activity içerebilir ve Activity'ler arasında Intent kullanılarak geçiş yapılır.\n\nActivity, Android işletim sistemi tarafından belirli bir yaşam döngüsüne göre yönetilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Activity Tanımı",
                  "code": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}",
                  "explanation": "Bir Activity'nin temel yapısı ve onCreate metodu."
                }
              ],
              "keyPoints": [
                "Her Activity bir ekranı temsil eder",
                "AppCompatActivity'den türetilir",
                "Intent ile Activity geçişleri yapılır",
                "Yaşam döngüsü metotlarına sahiptir"
              ],
              "questions": [
                {
                  "questionId": 230101,
                  "question": "Activity nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı tablosu",
                    "Kullanıcıya gösterilen tek bir ekran",
                    "Sadece arka plan servisi",
                    "Network bağlantısı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Activity, Android uygulamalarda kullanıcıya gösterilen tek bir ekranı temsil eder.",
                  "tags": ["activity", "temel"]
                },
                {
                  "questionId": 230102,
                  "question": "Activity hangi sınıftan türetilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fragment",
                    "View",
                    "AppCompatActivity",
                    "Context"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Modern Android uygulamalarında Activity'ler genellikle AppCompatActivity sınıfından türetilir.",
                  "tags": ["activity", "inheritance"]
                },
                {
                  "questionId": 230103,
                  "question": "Activity'ler arasında geçiş yapmak için ne kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Toast",
                    "Intent",
                    "Bundle",
                    "Context"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Activity'ler arasında geçiş yapmak için Intent kullanılır.",
                  "tags": ["activity", "intent"]
                },
                {
                  "questionId": 230104,
                  "question": "Aşağıdaki kodda onCreate metodunun amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "Activity'yi yok eder",
                    "Activity'yi başlatır ve ilk kurulumu yapar",
                    "Activity'yi arka plana alır",
                    "Sadece log basar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "onCreate metodu, Activity oluşturulduğunda çağrılır ve ilk kurulum işlemleri burada yapılır. setContentView ile layout bağlanır.",
                  "tags": ["activity", "oncreate"]
                },
                {
                  "questionId": 230105,
                  "question": "Bir uygulamada kaç tane Activity bulunabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece 1 tane",
                    "En fazla 3 tane",
                    "Birden fazla olabilir",
                    "Activity olmadan da uygulama çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Bir Android uygulaması birden fazla Activity içerebilir. Her Activity farklı bir ekranı temsil edebilir.",
                  "tags": ["activity", "multiple"]
                }
              ]
            },
            {
              "topicId": 2302,
              "title": "Lifecycle Metotları",
              "summary": "Lifecycle metotları, Activity'nin oluşturulmasından yok edilmesine kadar geçen sürede hangi aşamalardan geçtiğini belirler. Bu metotlar sayesinde kaynak yönetimi doğru şekilde yapılır.",
              "content": "## Lifecycle Metotları\n\nAndroid, Activity'nin durumuna göre belirli lifecycle metotlarını çağırır.\n\nBu metotlar, uygulamanın arka plana alınması, tekrar açılması veya kapatılması gibi durumlarda çalışır.\n\nDoğru lifecycle yönetimi performans ve stabilite açısından kritik öneme sahiptir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Lifecycle Metotları Örneği",
                  "code": "override fun onStart() {\n    super.onStart()\n}\n\noverride fun onResume() {\n    super.onResume()\n}\n\noverride fun onPause() {\n    super.onPause()\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n}",
                  "explanation": "Activity yaşam döngüsünde sık kullanılan metotlar."
                }
              ],
              "keyPoints": [
                "onCreate: Activity oluşturulur",
                "onStart / onResume: Activity görünür ve aktif",
                "onPause / onStop: Activity arka plana alınır",
                "onDestroy: Activity yok edilir",
                "Kaynaklar lifecycle'a göre yönetilmelidir"
              ],
              "questions": [
                {
                  "questionId": 230201,
                  "question": "Activity ilk oluşturulduğunda hangi lifecycle metodu çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onStart()",
                    "onResume()",
                    "onCreate()",
                    "onDestroy()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onCreate() metodu, Activity ilk oluşturulduğunda çağrılır ve temel kurulum işlemleri burada yapılır.",
                  "tags": ["lifecycle", "oncreate"]
                },
                {
                  "questionId": 230202,
                  "question": "Activity görünür hale geldiğinde hangi metot çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "onCreate()",
                    "onStart()",
                    "onPause()",
                    "onDestroy()"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "onStart() metodu, Activity görünür hale geldiğinde (kullanıcı ekranı görebildiğinde) çağrılır.",
                  "tags": ["lifecycle", "onstart"]
                },
                {
                  "questionId": 230203,
                  "question": "Activity tamamen aktif ve kullanıcı etkileşime geçebilir durumdayken hangi metot çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "onCreate()",
                    "onStart()",
                    "onResume()",
                    "onPause()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onResume() metodu, Activity tamamen aktif hale geldiğinde ve kullanıcı etkileşime geçebilir durumdayken çağrılır.",
                  "tags": ["lifecycle", "onresume"]
                },
                {
                  "questionId": 230204,
                  "question": "Activity arka plana alındığında hangi metot çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onResume()",
                    "onCreate()",
                    "onPause()",
                    "onRestart()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onPause() metodu, Activity arka plana alındığında veya başka bir Activity öne çıktığında çağrılır.",
                  "tags": ["lifecycle", "onpause"]
                },
                {
                  "questionId": 230205,
                  "question": "Activity tamamen yok edildiğinde hangi metot çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onStop()",
                    "onPause()",
                    "onDestroy()",
                    "onCreate()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onDestroy() metodu, Activity tamamen yok edildiğinde çağrılır. Burada kaynaklar serbest bırakılmalıdır.",
                  "tags": ["lifecycle", "ondestroy"]
                }
              ]
            },
            {
              "topicId": 2303,
              "title": "Context",
              "summary": "Context, Android uygulamasının mevcut durumunu ve ortam bilgisini temsil eder. Kaynaklara erişim, Activity başlatma ve sistem servislerini kullanmak için gereklidir.",
              "content": "## Context\n\nContext, uygulama hakkında bilgi sağlar.\n\nActivity, Application ve Service gibi sınıflar Context türevleridir.\n\nYanlış Context kullanımı memory leak gibi sorunlara yol açabilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Context Kullanımı",
                  "code": "Toast.makeText(this, \"Merhaba\", Toast.LENGTH_SHORT).show()",
                  "explanation": "Activity context kullanılarak Toast gösterilmesi."
                }
              ],
              "keyPoints": [
                "Kaynaklara erişim sağlar",
                "Activity ve Application Context farkı vardır",
                "Yanlış kullanım memory leak oluşturabilir",
                "Toast, Intent ve Dialog işlemlerinde kullanılır"
              ],
              "questions": [
                {
                  "questionId": 230301,
                  "question": "Context nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece layout dosyası",
                    "Uygulamanın mevcut durumunu temsil eden ortam bilgisi",
                    "Sadece veritabanı",
                    "Sadece network bağlantısı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Context, Android uygulamasının mevcut durumunu ve ortam bilgisini temsil eder.",
                  "tags": ["context", "temel"]
                },
                {
                  "questionId": 230302,
                  "question": "Aşağıdaki kodda 'this' ne tür bir Context'tir?",
                  "questionType": "multiple_choice",
                  "code": "Toast.makeText(this, \"Merhaba\", Toast.LENGTH_SHORT).show()",
                  "difficulty": "medium",
                  "options": [
                    "Application Context",
                    "Activity Context",
                    "Service Context",
                    "Fragment Context"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Activity içinde 'this' kullanıldığında Activity Context'i temsil eder.",
                  "tags": ["context", "activity_context"]
                },
                {
                  "questionId": 230303,
                  "question": "Yanlış Context kullanımı hangi soruna yol açabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha hızlı çalışma",
                    "Memory leak (bellek sızıntısı)",
                    "Daha az bellek kullanımı",
                    "Hiçbir sorun oluşmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Yanlış Context kullanımı (örneğin Activity Context'i uzun ömürlü nesnelerde tutmak) memory leak'e yol açabilir.",
                  "tags": ["context", "memory_leak"]
                },
                {
                  "questionId": 230304,
                  "question": "Context hangi işlemler için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece veritabanı işlemleri",
                    "Kaynaklara erişim, Activity başlatma, sistem servisleri",
                    "Sadece network işlemleri",
                    "Sadece matematiksel hesaplamalar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Context; kaynaklara erişim (getString, getDrawable), Activity başlatma (Intent), sistem servislerini kullanma ve Toast/Dialog gösterme gibi işlemler için kullanılır.",
                  "tags": ["context", "usage"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 230001,
              "question": "Activity yaşam döngüsünde doğru sıralama hangisidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "onCreate → onResume → onStart",
                "onCreate → onStart → onResume",
                "onStart → onCreate → onResume",
                "onResume → onCreate → onStart"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity yaşam döngüsü: onCreate() → onStart() → onResume() sırasıyla çalışır.",
              "tags": ["lifecycle", "sequence"]
            },
            {
              "questionId": 230002,
              "question": "Kullanıcı Home tuşuna basarak uygulamayı arka plana aldığında hangi lifecycle metotları çağrılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece onPause()",
                "onPause() → onStop()",
                "onPause() → onDestroy()",
                "Hiçbiri çağrılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Uygulama arka plana alındığında önce onPause(), ardından onStop() çağrılır. Activity yok edilmez.",
              "tags": ["lifecycle", "background"]
            },
            {
              "questionId": 230003,
              "question": "Activity'de setContentView() metodu hangi lifecycle metodunda çağrılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "onStart()",
                "onResume()",
                "onCreate()",
                "onDestroy()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "setContentView() metodu, layout'u Activity'ye bağlamak için onCreate() metodunda çağrılır.",
              "tags": ["activity", "setcontentview"]
            },
            {
              "questionId": 230004,
              "question": "Activity Context ve Application Context arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "Activity Context Activity'ye bağlı, Application Context tüm uygulamaya bağlı",
                "Application Context daha yavaştır",
                "Activity Context sadece layout için kullanılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity Context, Activity'nin yaşam döngüsüne bağlıdır. Application Context ise uygulama çalıştığı sürece yaşar ve uzun ömürlü işlemler için tercih edilir.",
              "tags": ["context", "difference"]
            },
            {
              "questionId": 230005,
              "question": "onDestroy() metodunda ne tür işlemler yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Layout bağlama",
                "Kaynakları serbest bırakma (cleanup)",
                "Yeni Activity başlatma",
                "Toast gösterme"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onDestroy() metodunda listener'lar, broadcast receiver'lar gibi kaynaklar serbest bırakılmalı ve cleanup işlemleri yapılmalıdır.",
              "tags": ["lifecycle", "cleanup"]
            },
            {
              "questionId": 230006,
              "question": "Activity arka plandayken tekrar ön plana geldiğinde hangi lifecycle metotları çalışır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "onCreate() → onStart() → onResume()",
                "onRestart() → onStart() → onResume()",
                "Sadece onResume()",
                "onStart() → onResume()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity arka plandayken tekrar ön plana geldiğinde onRestart() → onStart() → onResume() sırası çalışır.",
              "tags": ["lifecycle", "restart"]
            },
            {
              "questionId": 230007,
              "question": "Intent kullanarak başka bir Activity'ye veri göndermek için hangi metot kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "intent.getData()",
                "intent.putExtra()",
                "intent.send()",
                "intent.setData()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent ile veri göndermek için putExtra() metodu kullanılır.",
              "tags": ["intent", "data_passing"]
            },
            {
              "questionId": 230008,
              "question": "onPause() ve onStop() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "onPause() Activity kısmen görünür, onStop() tamamen görünmez",
                "onStop() daha önce çağrılır",
                "onPause() sadece ilk açılışta çalışır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onPause()'da Activity hala kısmen görünür olabilir (örneğin dialog üstte), onStop()'ta ise Activity tamamen görünmez hale gelir.",
              "tags": ["lifecycle", "onpause_onstop"]
            },
            {
              "questionId": 230009,
              "question": "AndroidManifest.xml'de Activity tanımlanmazsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir şey olmaz",
                "Uygulama açılmaz",
                "Activity çalıştırılamaz",
                "Sadece uyarı verir"
              ],
              "correctAnswerIndex": 2,
              "explanation": "AndroidManifest.xml'de tanımlanmayan Activity'ler çalıştırılamaz ve runtime exception oluşur.",
              "tags": ["activity", "manifest"]
            },
            {
              "questionId": 230010,
              "question": "Configuration change (ekran döndürme) durumunda Activity varsayılan olarak ne yapar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey olmaz",
                "Sadece onPause() çağrılır",
                "Activity yok edilip yeniden oluşturulur",
                "Sadece layout değişir"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Configuration change (örneğin ekran döndürme) durumunda Activity varsayılan olarak yok edilir (onDestroy) ve yeniden oluşturulur (onCreate).",
              "tags": ["lifecycle", "configuration_change"]
            }
          ]
        },
        {
          "sectionId": 2400,
          "sectionTitle": "Kullanıcı Etkileşimi",
          "sectionDescription": "Kullanıcının uygulama ile etkileşime girmesini sağlayan temel UI bileşenleri",
          "order": 4,
          "topics": [
            {
              "topicId": 2401,
              "title": "Button",
              "summary": "Button, kullanıcının bir aksiyon başlatmasını sağlayan temel UI bileşenidir. Genellikle tıklama (click) olayları ile birlikte kullanılır.",
              "content": "## Button\n\nButton, kullanıcıdan aksiyon almak için kullanılır.\n\nTıklama olayları click listener aracılığıyla yakalanır.\n\nXML üzerinden veya kod ile özelleştirilebilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Button Tanımı",
                  "code": "<Button\n    android:id=\"@+id/btnSave\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Kaydet\" />",
                  "explanation": "XML ile Button tanımlama."
                }
              ],
              "keyPoints": [
                "Kullanıcı aksiyonu için kullanılır",
                "Click listener ile çalışır",
                "XML ve koddan kontrol edilebilir"
              ],
              "questions": [
                {
                  "questionId": 240101,
                  "question": "Button ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Metin göstermek",
                    "Kullanıcıdan aksiyon almak",
                    "Sadece görsel için",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Button, kullanıcının bir aksiyon başlatmasını sağlayan temel UI bileşenidir.",
                  "tags": ["button", "temel"]
                },
                {
                  "questionId": 240102,
                  "question": "Aşağıdaki XML'de Button'un ID'si nedir?",
                  "questionType": "multiple_choice",
                  "code": "<Button\n    android:id=\"@+id/btnSave\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Kaydet\" />",
                  "difficulty": "easy",
                  "options": [
                    "Kaydet",
                    "btnSave",
                    "Button",
                    "wrap_content"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "android:id=\"@+id/btnSave\" ifadesinde Button'un ID'si btnSave'dir.",
                  "tags": ["button", "xml"]
                },
                {
                  "questionId": 240103,
                  "question": "Button'a tıklama olayı nasıl eklenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onClick listener",
                    "setText metodu",
                    "setId metodu",
                    "Otomatik eklenir"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Button'a tıklama olayı eklemek için setOnClickListener kullanılır.",
                  "tags": ["button", "click_listener"]
                }
              ]
            },
            {
              "topicId": 2402,
              "title": "EditText",
              "summary": "EditText, kullanıcıdan metin girişi almak için kullanılan bir UI bileşenidir. Formlar ve veri giriş ekranlarında yaygın olarak kullanılır.",
              "content": "## EditText\n\nEditText, kullanıcıdan veri almak için kullanılır.\n\ninputType ile klavye türü belirlenebilir.\n\nGirilen veri String olarak alınır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "EditText Kullanımı",
                  "code": "<EditText\n    android:id=\"@+id/etName\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"İsim giriniz\" />",
                  "explanation": "Basit EditText tanımı."
                }
              ],
              "keyPoints": [
                "Kullanıcıdan metin alır",
                "inputType ile klavye ayarlanır",
                "Genellikle form ekranlarında kullanılır"
              ],
              "questions": [
                {
                  "questionId": 240201,
                  "question": "EditText ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece metin göstermek",
                    "Kullanıcıdan metin girişi almak",
                    "Resim göstermek",
                    "Video oynatmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "EditText, kullanıcıdan metin girişi almak için kullanılan bir UI bileşenidir.",
                  "tags": ["edittext", "input"]
                },
                {
                  "questionId": 240202,
                  "question": "EditText'te klavye türünü belirlemek için hangi özellik kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "android:text",
                    "android:hint",
                    "android:inputType",
                    "android:id"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "android:inputType ile klavye türü belirlenir (textPassword, number, email vb.).",
                  "tags": ["edittext", "inputtype"]
                },
                {
                  "questionId": 240203,
                  "question": "Aşağıdaki EditText'te hint metni ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": "<EditText\n    android:id=\"@+id/etName\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"İsim giriniz\" />",
                  "difficulty": "easy",
                  "options": [
                    "Kullanıcıya yönlendirme gösterir",
                    "Edittext'in değeridir",
                    "ID'sidir",
                    "Hata mesajıdır"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "hint, EditText boşken kullanıcıya ne girmesi gerektiğini belirten açıklayıcı metindir.",
                  "tags": ["edittext", "hint"]
                }
              ]
            },
            {
              "topicId": 2403,
              "title": "Click Listener",
              "summary": "Click Listener, kullanıcı bir View'a tıkladığında çalışacak kod bloğunu tanımlamak için kullanılır. En yaygın kullanılan etkileşim yöntemidir.",
              "content": "## Click Listener\n\nClick listener sayesinde kullanıcı etkileşimleri yakalanır.\n\nKotlin'de lambda yapısı ile daha sade yazılabilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Click Listener Örneği",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "explanation": "Lambda kullanılarak click listener tanımı."
                }
              ],
              "keyPoints": [
                "Kullanıcı etkileşimini yakalar",
                "Lambda ile sade kullanım",
                "Tüm View'lar için geçerlidir"
              ],
              "questions": [
                {
                  "questionId": 240301,
                  "question": "Click listener ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "View oluşturur",
                    "Kullanıcı tıklama olaylarını yakalar",
                    "Layout tasarlar",
                    "Veritabanına veri yazar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Click listener, kullanıcı bir View'a tıkladığında çalışacak kod bloğunu tanımlamak için kullanılır.",
                  "tags": ["click_listener", "temel"]
                },
                {
                  "questionId": 240302,
                  "question": "Aşağıdaki kodda ne olur?",
                  "questionType": "multiple_choice",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "difficulty": "easy",
                  "options": [
                    "Button oluşturulur",
                    "Button tıklandığında konsola mesaj yazılır",
                    "Button silinir",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "setOnClickListener içindeki kod bloğu, button'a tıklandığında çalışır ve konsola mesaj yazar.",
                  "tags": ["click_listener", "kotlin"]
                },
                {
                  "questionId": 240303,
                  "question": "Click listener hangi View'lar için kullanılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Button",
                    "Sadece TextView",
                    "Tüm View'lar",
                    "Sadece EditText"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Click listener tüm View türleri için kullanılabilir (Button, TextView, ImageView, CardView vb.).",
                  "tags": ["click_listener", "view"]
                }
              ]
            },
            {
              "topicId": 2404,
              "title": "AlertDialog",
              "summary": "AlertDialog, kullanıcıya bilgi vermek veya onay almak için kullanılan açılır pencere yapısıdır. Kritik aksiyonlar öncesinde sıkça tercih edilir.",
              "content": "## AlertDialog\n\nAlertDialog, kullanıcıdan onay veya seçim almak için kullanılır.\n\nBaşlık, mesaj ve butonlar içerir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "AlertDialog Örneği",
                  "code": "AlertDialog.Builder(this)\n    .setTitle(\"Uyarı\")\n    .setMessage(\"Silmek istiyor musunuz?\")\n    .setPositiveButton(\"Evet\", null)\n    .setNegativeButton(\"Hayır\", null)\n    .show()",
                  "explanation": "Basit bir AlertDialog oluşturma."
                }
              ],
              "keyPoints": [
                "Kullanıcıdan onay almak için kullanılır",
                "Pozitif ve negatif butonlar içerir",
                "Context gerektirir"
              ],
              "questions": [
                {
                  "questionId": 240401,
                  "question": "AlertDialog ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece bilgi göstermek",
                    "Kullanıcıdan onay veya seçim almak",
                    "Layout oluşturmak",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "AlertDialog, kullanıcıya bilgi vermek veya onay almak için kullanılan açılır pencere yapısıdır.",
                  "tags": ["alertdialog", "temel"]
                },
                {
                  "questionId": 240402,
                  "question": "AlertDialog'da pozitif buton ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "İptal butonu",
                    "Onay/Evet butonu",
                    "Geri butonu",
                    "Kapat butonu"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "setPositiveButton, genellikle 'Evet', 'Tamam', 'Kaydet' gibi onay butonları için kullanılır.",
                  "tags": ["alertdialog", "positive_button"]
                },
                {
                  "questionId": 240403,
                  "question": "Aşağıdaki AlertDialog kodunda kaç buton vardır?",
                  "questionType": "multiple_choice",
                  "code": "AlertDialog.Builder(this)\n    .setTitle(\"Uyarı\")\n    .setMessage(\"Silmek istiyor musunuz?\")\n    .setPositiveButton(\"Evet\", null)\n    .setNegativeButton(\"Hayır\", null)\n    .show()",
                  "difficulty": "easy",
                  "options": [
                    "1 buton",
                    "2 buton",
                    "3 buton",
                    "Buton yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Positive (Evet) ve Negative (Hayır) olmak üzere 2 buton vardır.",
                  "tags": ["alertdialog", "buttons"]
                },
                {
                  "questionId": 240404,
                  "question": "AlertDialog oluşturmak için ne gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece String",
                    "Context",
                    "Sadece Layout",
                    "Fragment"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "AlertDialog oluşturmak için Context gereklidir. Builder'a this (Activity context) veya applicationContext verilebilir.",
                  "tags": ["alertdialog", "context"]
                }
              ]
            },
            {
              "topicId": 2405,
              "title": "Toast / Snackbar",
              "summary": "Toast ve Snackbar, kullanıcıya kısa süreli bilgilendirme mesajları göstermek için kullanılır. Snackbar, Toast'a göre daha etkileşimli ve modern bir çözümdür.",
              "content": "## Toast / Snackbar\n\nToast kısa süreli mesaj gösterir.\n\nSnackbar, aksiyon butonu eklemeye izin verir ve genellikle View ile ilişkilidir.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Toast ve Snackbar",
                  "code": "Toast.makeText(this, \"Kayıt başarılı\", Toast.LENGTH_SHORT).show()\n\nSnackbar.make(view, \"Silindi\", Snackbar.LENGTH_LONG)\n    .setAction(\"Geri Al\") { }\n    .show()",
                  "explanation": "Toast ve Snackbar kullanım örneği."
                }
              ],
              "keyPoints": [
                "Toast kısa bilgilendirme için kullanılır",
                "Snackbar daha etkileşimlidir",
                "Snackbar aksiyon alabilir"
              ],
              "questions": [
                {
                  "questionId": 240501,
                  "question": "Toast ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kullanıcıdan veri almak",
                    "Kısa süreli bilgilendirme mesajı göstermek",
                    "Activity başlatmak",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Toast, kullanıcıya kısa süreli bilgilendirme mesajları göstermek için kullanılır.",
                  "tags": ["toast", "temel"]
                },
                {
                  "questionId": 240502,
                  "question": "Toast ve Snackbar arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Snackbar daha etkileşimli ve aksiyon butonu alabilir",
                    "Toast daha yavaştır",
                    "Snackbar sadece error için kullanılır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Snackbar, Toast'a göre daha etkileşimlidir ve aksiyon butonu eklenebilir (örneğin Geri Al).",
                  "tags": ["toast", "snackbar", "difference"]
                },
                {
                  "questionId": 240503,
                  "question": "Aşağıdaki kodda Toast ne kadar süre görünür?",
                  "questionType": "multiple_choice",
                  "code": "Toast.makeText(this, \"Kayıt başarılı\", Toast.LENGTH_SHORT).show()",
                  "difficulty": "easy",
                  "options": [
                    "1 saniye",
                    "Kısa süre (yaklaşık 2 saniye)",
                    "Uzun süre (yaklaşık 3.5 saniye)",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Toast.LENGTH_SHORT, Toast'un kısa süre (yaklaşık 2 saniye) görünmesini sağlar. LENGTH_LONG ise yaklaşık 3.5 saniyedir.",
                  "tags": ["toast", "duration"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 240001,
              "question": "Button, EditText ve TextView'in ortak özelliği nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hepsi View sınıfından türer",
                "Hepsi sadece metin gösterir",
                "Hepsi aynı şeydir",
                "Hepsi sadece tıklanabilir"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Button, EditText, TextView ve diğer tüm UI bileşenleri View sınıfından türer.",
              "tags": ["view", "inheritance"]
            },
            {
              "questionId": 240002,
              "question": "Kullanıcıdan şifre girişi almak için EditText'te hangi inputType kullanılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "textEmailAddress",
                "number",
                "textPassword",
                "phone"
              ],
              "correctAnswerIndex": 2,
              "explanation": "android:inputType=\"textPassword\" kullanıldığında girilen karakter gizlenir ve şifre girişi için uygun klavye gösterilir.",
              "tags": ["edittext", "inputtype", "password"]
            },
            {
              "questionId": 240003,
              "question": "Kritik bir silme işlemi öncesinde kullanıcıdan onay almak için hangi bileşen kullanılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Toast",
                "Button",
                "AlertDialog",
                "EditText"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Kritik aksiyonlar öncesinde kullanıcıdan onay almak için AlertDialog kullanılır.",
              "tags": ["alertdialog", "confirmation"]
            },
            {
              "questionId": 240004,
              "question": "Snackbar'ın Toast'a göre avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha hızlıdır",
                "Aksiyon butonu eklenebilir",
                "Daha az bellek kullanır",
                "Daha uzun süre görünür"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Snackbar'a setAction() ile aksiyon butonu eklenebilir (örneğin Geri Al), Toast'ta bu özellik yoktur.",
              "tags": ["snackbar", "advantage"]
            },
            {
              "questionId": 240005,
              "question": "View Binding ile Button'a nasıl erişilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "findViewById(R.id.button)",
                "binding.button",
                "getButton()",
                "button.get()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding kullanıldığında XML'deki view'lara binding.viewId şeklinde doğrudan erişilir.",
              "tags": ["view_binding", "button"]
            },
            {
              "questionId": 240006,
              "question": "EditText'ten girilen değer nasıl alınır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "editText.text",
                "editText.value",
                "editText.text.toString()",
                "editText.getValue()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "EditText'ten girilen değer editText.text.toString() ile String olarak alınır.",
              "tags": ["edittext", "get_text"]
            },
            {
              "questionId": 240007,
              "question": "AlertDialog gösterildiğinde hangi metot çağrılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "build()",
                "create()",
                "show()",
                "display()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "AlertDialog'u ekranda göstermek için show() metodu çağrılır.",
              "tags": ["alertdialog", "show"]
            },
            {
              "questionId": 240008,
              "question": "Bir Button'u programatik olarak tıklanamaz hale getirmek için ne yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "button.visible = false",
                "button.isEnabled = false",
                "button.remove()",
                "button.delete()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "button.isEnabled = false yapıldığında button tıklanamaz (disabled) hale gelir ama görünür kalır.",
              "tags": ["button", "enabled"]
            },
            {
              "questionId": 240009,
              "question": "Toast gösterilirken uygulama kapanırsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hata verir",
                "Toast kaybolur",
                "Uygulama crash olur",
                "Toast sonsuza kadar kalır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Toast, Activity'ye bağlı olmadığı için uygulama kapansa bile belirlenen süre boyunca görünmeye devam edebilir, ancak Activity context kullanıldığında genellikle kaybolur.",
              "tags": ["toast", "lifecycle"]
            },
            {
              "questionId": 240010,
              "question": "Modern Android uygulamalarında bilgilendirme mesajı göstermek için hangisi önerilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "AlertDialog",
                "Toast",
                "Snackbar",
                "Notification"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Modern Android uygulamalarında Material Design'a uygun ve daha etkileşimli olduğu için Snackbar önerilir. Toast hala kullanılsa da Snackbar daha kullanıcı dostudur.",
              "tags": ["snackbar", "best_practice"]
            }
          ]
        },
        {
          "sectionId": 2500,
          "sectionTitle": "Intent & Veri Aktarımı",
          "sectionDescription": "Activity’ler arası geçiş ve veri aktarımı için kullanılan Intent yapıları",
          "order": 5,
          "topics": [
            {
              "topicId": 2501,
              "title": "Explicit Intent",
              "summary": "Explicit Intent, hangi Activity’nin açılacağını açıkça belirttiğimiz intent türüdür. Uygulama içindeki Activity geçişlerinde en sık kullanılan yöntemdir.",
              "content": "## Explicit Intent\n\nExplicit Intent, hedef Activity'nin doğrudan belirtildiği intent türüdür.\n\nGenellikle aynı uygulama içerisindeki ekranlar arasında geçiş yapmak için kullanılır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Explicit Intent Kullanımı",
                  "code": "val intent = Intent(this, DetailActivity::class.java)\nstartActivity(intent)",
                  "explanation": "MainActivity'den DetailActivity'e geçiş."
                }
              ],
              "keyPoints": [
                "Hedef Activity açıkça belirtilir",
                "Uygulama içi geçişlerde kullanılır",
                "En yaygın intent türüdür"
              ],
              "questions": [
                {
                  "questionId": 250101,
                  "question": "Explicit Intent ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Hedef Activity belirsizdir",
                    "Hedef Activity açıkça belirtilir",
                    "Sadece sistem uygulamaları için kullanılır",
                    "Veri aktarımı yapılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Explicit Intent, hedef Activity'nin doğrudan belirtildiği intent türüdür.",
                  "tags": ["intent", "explicit"]
                },
                {
                  "questionId": 250102,
                  "question": "Explicit Intent hangi durumlarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece dış uygulamalara geçiş",
                    "Uygulama içi Activity geçişleri",
                    "Sadece servis başlatma",
                    "Sadece broadcast gönderme"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Explicit Intent, genellikle aynı uygulama içerisindeki Activity'ler arasında geçiş yapmak için kullanılır.",
                  "tags": ["intent", "explicit", "usage"]
                },
                {
                  "questionId": 250103,
                  "question": "Aşağıdaki kodda hangi Activity açılır?",
                  "questionType": "multiple_choice",
                  "code": "val intent = Intent(this, DetailActivity::class.java)\nstartActivity(intent)",
                  "difficulty": "easy",
                  "options": [
                    "MainActivity",
                    "DetailActivity",
                    "Sistem seçer",
                    "Hiçbiri açılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kod, DetailActivity'yi açıkça belirttiği için DetailActivity açılır.",
                  "tags": ["intent", "explicit", "startactivity"]
                },
                {
                  "questionId": 250104,
                  "question": "Explicit Intent oluşturmak için hangi parametre gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece action",
                    "Context ve hedef Activity sınıfı",
                    "Sadece data",
                    "Sadece flag"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Explicit Intent oluşturmak için Context (this) ve hedef Activity'nin sınıfı (DetailActivity::class.java) gereklidir.",
                  "tags": ["intent", "explicit", "parameters"]
                }
              ]
            },
            {
              "topicId": 2502,
              "title": "Implicit Intent",
              "summary": "Implicit Intent, hangi uygulamanın açılacağını belirtmeden, yapılmak istenen işlemi tanımlar. Sistem, bu isteği karşılayabilecek uygulamayı kullanıcıya sunar.",
              "content": "## Implicit Intent\n\nImplicit Intent, belirli bir aksiyon ve veri ile çalışır.\n\nTelefon araması, tarayıcı açma veya paylaşım işlemlerinde sıkça kullanılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Implicit Intent Örneği",
                  "code": "val intent = Intent(Intent.ACTION_VIEW)\nintent.data = Uri.parse(\"https://www.google.com\")\nstartActivity(intent)",
                  "explanation": "Tarayıcı açmak için implicit intent kullanımı."
                }
              ],
              "keyPoints": [
                "Hedef uygulama belirtilmez",
                "Aksiyon ve data ile çalışır",
                "Sistem uygun uygulamayı seçer"
              ],
              "questions": [
                {
                  "questionId": 250201,
                  "question": "Implicit Intent ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Hedef Activity açıkça belirtilir",
                    "Yapılmak istenen işlem tanımlanır, sistem uygun uygulamayı seçer",
                    "Sadece aynı uygulama içinde kullanılır",
                    "Veri aktarımı yapılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Implicit Intent, hangi uygulamanın açılacağını belirtmeden, yapılmak istenen işlemi (action) tanımlar. Sistem uygun uygulamayı kullanıcıya sunar.",
                  "tags": ["intent", "implicit"]
                },
                {
                  "questionId": 250202,
                  "question": "Implicit Intent hangi durumlarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece kendi uygulamam içinde",
                    "Telefon araması, tarayıcı açma, paylaşım gibi sistem aksiyonlarında",
                    "Sadece veritabanı işlemlerinde",
                    "Sadece animasyon göstermede"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Implicit Intent, telefon araması, tarayıcı açma, e-posta gönderme veya paylaşım gibi sistem seviyesi aksiyonlar için kullanılır.",
                  "tags": ["intent", "implicit", "usage"]
                },
                {
                  "questionId": 250203,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val intent = Intent(Intent.ACTION_VIEW)\nintent.data = Uri.parse(\"https://www.google.com\")\nstartActivity(intent)",
                  "difficulty": "medium",
                  "options": [
                    "Google uygulamasını açar",
                    "Tarayıcıda Google'ı açar",
                    "E-posta gönderir",
                    "Telefon açar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ACTION_VIEW action'ı ve URL data'sı ile tarayıcı açılır ve Google web sitesi gösterilir.",
                  "tags": ["intent", "implicit", "action_view"]
                },
                {
                  "questionId": 250204,
                  "question": "Implicit Intent'te action ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hedef Activity'yi belirtir",
                    "Yapılacak işlemi tanımlar",
                    "Sadece veri taşır",
                    "Layout belirler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Action, yapılacak işlemi tanımlar (ACTION_VIEW, ACTION_DIAL, ACTION_SEND vb.). Sistem bu action'ı işleyebilecek uygulamaları bulur.",
                  "tags": ["intent", "implicit", "action"]
                },
                {
                  "questionId": 250205,
                  "question": "Bir URL'yi paylaşmak için hangi action kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "ACTION_VIEW",
                    "ACTION_DIAL",
                    "ACTION_SEND",
                    "ACTION_CALL"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "ACTION_SEND, metin, URL veya dosya paylaşmak için kullanılır. Kullanıcı paylaşım yapacağı uygulamayı seçebilir.",
                  "tags": ["intent", "implicit", "action_send"]
                }
              ]
            },
            {
              "topicId": 2503,
              "title": "Bundle",
              "summary": "Bundle, key-value mantığıyla çalışan ve Activity’ler arasında veri taşımak için kullanılan bir yapıdır. Intent ile birlikte kullanılır.",
              "content": "## Bundle\n\nBundle, küçük ve basit verilerin taşınması için idealdir.\n\nVeriler key-value şeklinde saklanır.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Bundle ile Veri Gönderme",
                  "code": "val bundle = Bundle()\nbundle.putString(\"username\", \"Ahmet\")\nintent.putExtras(bundle)\nstartActivity(intent)",
                  "explanation": "Bundle kullanarak veri aktarımı."
                }
              ],
              "keyPoints": [
                "Key-value mantığı ile çalışır",
                "Intent ile birlikte kullanılır",
                "Küçük veriler için uygundur"
              ],
              "questions": [
                {
                  "questionId": 250301,
                  "question": "Bundle ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Layout oluşturmak",
                    "Activity'ler arasında veri taşımak",
                    "Veritabanı işlemleri",
                    "Network isteği"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bundle, key-value mantığıyla çalışan ve Activity'ler arasında veri taşımak için kullanılan bir yapıdır.",
                  "tags": ["bundle", "data_transfer"]
                },
                {
                  "questionId": 250302,
                  "question": "Bundle nasıl çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Array mantığıyla",
                    "Key-value mantığıyla",
                    "Stack mantığıyla",
                    "Queue mantığıyla"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bundle, key-value (anahtar-değer) çifti olarak veri saklar. putString(\"key\", \"value\") şeklinde kullanılır.",
                  "tags": ["bundle", "key_value"]
                },
                {
                  "questionId": 250303,
                  "question": "Aşağıdaki kodda \"username\" verisinin değeri nedir?",
                  "questionType": "multiple_choice",
                  "code": "val bundle = Bundle()\nbundle.putString(\"username\", \"Ahmet\")\nintent.putExtras(bundle)",
                  "difficulty": "easy",
                  "options": [
                    "bundle",
                    "Ahmet",
                    "username",
                    "intent"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "putString(\"username\", \"Ahmet\") ile \"username\" key'ine \"Ahmet\" değeri atanmıştır.",
                  "tags": ["bundle", "putstring"]
                }
              ]
            },
            {
              "topicId": 2504,
              "title": "Serializable / Parcelable",
              "summary": "Serializable ve Parcelable, karmaşık nesneleri Activity’ler arasında taşımak için kullanılan yöntemlerdir. Parcelable, Android için daha performanslı bir çözümdür.",
              "content": "## Serializable / Parcelable\n\nSerializable Java tabanlıdır ve kullanımı kolaydır.\n\nParcelable ise Android’e özeldir ve daha hızlıdır.\n\nBüyük veri transferlerinde Parcelable tercih edilmelidir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Parcelable Kullanımı",
                  "code": "@Parcelize\ndata class User(val name: String, val age: Int) : Parcelable",
                  "explanation": "Parcelable veri sınıfı tanımı."
                }
              ],
              "keyPoints": [
                "Serializable kullanımı kolaydır",
                "Parcelable daha performanslıdır",
                "Karmaşık nesneler için kullanılır",
                "Android projelerinde Parcelable önerilir"
              ],
              "questions": [
                {
                  "questionId": 250401,
                  "question": "Serializable ve Parcelable ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Layout oluşturmak",
                    "Karmaşık nesneleri Activity'ler arasında taşımak",
                    "Veritabanı işlemleri",
                    "Animasyon oluşturmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Serializable ve Parcelable, karmaşık nesneleri (data class, model) Activity'ler arasında taşımak için kullanılır.",
                  "tags": ["serializable", "parcelable", "data_transfer"]
                },
                {
                  "questionId": 250402,
                  "question": "Serializable ve Parcelable arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Serializable Java tabanlı, Parcelable Android'e özel ve daha hızlı",
                    "Parcelable daha yavaştır",
                    "Serializable sadece String taşır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Serializable Java tabanlıdır ve kullanımı kolaydır. Parcelable ise Android'e özeldir ve daha performanslıdır.",
                  "tags": ["serializable", "parcelable", "difference"]
                },
                {
                  "questionId": 250403,
                  "question": "Android projelerinde hangi yöntem önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Serializable",
                    "Parcelable",
                    "İkisi de aynı",
                    "Hiçbiri kullanılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android projelerinde performans avantajı nedeniyle Parcelable önerilir.",
                  "tags": ["parcelable", "best_practice"]
                },
                {
                  "questionId": 250404,
                  "question": "Aşağıdaki Parcelable kullanımında @Parcelize ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": "@Parcelize\ndata class User(val name: String, val age: Int) : Parcelable",
                  "difficulty": "hard",
                  "options": [
                    "Sadece görsel amaçlı",
                    "Parcelable implementasyonunu otomatik oluşturur",
                    "Veritabanı işlemleri için",
                    "Network isteği için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de @Parcelize annotation'ı, Parcelable implementasyonunu otomatik olarak oluşturur, böylece manuel kod yazmaya gerek kalmaz.",
                  "tags": ["parcelable", "parcelize", "kotlin"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 250001,
              "question": "Explicit ve Implicit Intent arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "Explicit hedef Activity belirtir, Implicit action tanımlar",
                "Implicit daha hızlıdır",
                "Explicit sadece sistem uygulamaları için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Explicit Intent hedef Activity'yi açıkça belirtir, Implicit Intent ise yapılacak işlemi (action) tanımlar ve sistem uygun uygulamayı seçer.",
              "tags": ["intent", "explicit", "implicit"]
            },
            {
              "questionId": 250002,
              "question": "Intent ile basit bir String veri göndermek için hangi metot kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "intent.setData()",
                "intent.putExtra()",
                "intent.sendData()",
                "intent.addString()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent ile basit veri göndermek için intent.putExtra(\"key\", \"value\") metodu kullanılır.",
              "tags": ["intent", "putextra"]
            },
            {
              "questionId": 250003,
              "question": "Karşı Activity'de Intent'ten veri nasıl alınır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "intent.getData()",
                "intent.getStringExtra(\"key\")",
                "intent.receive()",
                "intent.fetch()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Karşı Activity'de Intent'ten veri almak için intent.getStringExtra(\"key\"), intent.getIntExtra() gibi metotlar kullanılır.",
              "tags": ["intent", "getextra"]
            },
            {
              "questionId": 250004,
              "question": "Telefon numarası çevirmek (arama ekranını açmak) için hangi action kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "ACTION_CALL",
                "ACTION_DIAL",
                "ACTION_PHONE",
                "ACTION_VIEW"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ACTION_DIAL, telefon arama ekranını açar ve numara gösterir ama izin gerektirmez. ACTION_CALL direkt arar ve izin gerektirir.",
              "tags": ["intent", "implicit", "action_dial"]
            },
            {
              "questionId": 250005,
              "question": "Bundle yerine doğrudan intent.putExtra() kullanmanın avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha hızlıdır",
                "Daha basit ve kısa kod yazılır",
                "Daha fazla veri taşır",
                "Daha güvenlidir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "intent.putExtra() doğrudan kullanıldığında Bundle oluşturmaya gerek kalmaz, kod daha basit ve kısa olur.",
              "tags": ["intent", "bundle", "putextra"]
            },
            {
              "questionId": 250006,
              "question": "Parcelable yerine Serializable kullanmanın dezavantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Kullanımı zordur",
                "Performans açısından daha yavaştır",
                "Sadece String taşır",
                "Android'de çalışmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Serializable, reflection kullandığı için Parcelable'a göre daha yavaştır. Android'de büyük veri transferlerinde Parcelable tercih edilmelidir.",
              "tags": ["serializable", "parcelable", "performance"]
            },
            {
              "questionId": 250007,
              "question": "Bir resim paylaşmak için hangi intent action ve type kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "ACTION_VIEW, text/plain",
                "ACTION_SEND, image/*",
                "ACTION_DIAL, image/png",
                "ACTION_CALL, text/html"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Resim paylaşmak için ACTION_SEND action'ı ve type olarak \"image/*\" veya \"image/png\" kullanılır.",
              "tags": ["intent", "implicit", "share_image"]
            },
            {
              "questionId": 250008,
              "question": "Intent flag'leri ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece veri taşır",
                "Activity'nin nasıl başlatılacağını kontrol eder",
                "Layout belirler",
                "Renk ayarlar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent flag'leri (FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_CLEAR_TOP vb.), Activity'nin nasıl başlatılacağını ve back stack'in nasıl yönetileceğini kontrol eder.",
              "tags": ["intent", "flags"]
            },
            {
              "questionId": 250009,
              "question": "MainActivity'den DetailActivity'e geçerken hem Intent hem de finish() çağrılırsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hata verir",
                "DetailActivity açılır ve MainActivity yok olur",
                "Hiçbir şey olmaz",
                "Uygulama kapanır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "startActivity(intent) ile DetailActivity açılır, finish() ile MainActivity yok edilir. Back tuşuna basıldığında MainActivity'e dönülemez.",
              "tags": ["intent", "finish"]
            },
            {
              "questionId": 250010,
              "question": "Intent.createChooser() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Activity oluşturur",
                "Kullanıcıya hangi uygulamayı kullanacağını seçme şansı verir",
                "Veritabanı oluşturur",
                "Layout oluşturur"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent.createChooser(), implicit intent için her seferinde kullanıcıya hangi uygulamayı kullanacağını seçme şansı verir (varsayılan uygulama ayarlanmış olsa bile).",
              "tags": ["intent", "chooser"]
            }
          ]
        },
        {
          "sectionId": 2600,
          "sectionTitle": "Veri Saklama",
          "sectionDescription": "Android uygulamalarda kullanıcı verilerinin yerel olarak saklanması yöntemleri",
          "order": 6,
          "topics": [
            {
              "topicId": 2601,
              "title": "SharedPreferences",
              "summary": "SharedPreferences, küçük ve basit verileri anahtar-değer (key-value) mantığıyla saklamak için kullanılan hafif bir veri saklama yöntemidir. Genellikle kullanıcı ayarları ve basit konfigürasyonlar için tercih edilir.",
              "content": "## SharedPreferences\n\nSharedPreferences, kalıcı veri saklama sağlar.\n\nUygulama kapatılsa bile veriler korunur.\n\nBoolean, Int, Float, Long ve String gibi basit veri tiplerini destekler.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "SharedPreferences Kullanımı",
                  "code": "val prefs = getSharedPreferences(\"MyPrefs\", Context.MODE_PRIVATE)\nprefs.edit().putString(\"username\", \"Ahmet\").apply()",
                  "explanation": "SharedPreferences ile veri kaydetme."
                }
              ],
              "keyPoints": [
                "Key-value yapısı kullanır",
                "Küçük veriler için uygundur",
                "Kalıcı veri saklar",
                "Basit ve hızlıdır"
              ],
              "questions": [
                {
                  "questionId": 260101,
                  "question": "SharedPreferences ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Büyük dosyaları saklamak",
                    "Küçük ve basit verileri key-value mantığıyla saklamak",
                    "Veritabanı oluşturmak",
                    "Network isteği yapmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SharedPreferences, küçük ve basit verileri anahtar-değer (key-value) mantığıyla saklamak için kullanılır.",
                  "tags": ["sharedpreferences", "temel"]
                },
                {
                  "questionId": 260102,
                  "question": "SharedPreferences hangi veri tiplerini destekler?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece String",
                    "Boolean, Int, Float, Long ve String",
                    "Sadece Int",
                    "Tüm nesne türleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SharedPreferences, Boolean, Int, Float, Long ve String gibi basit veri tiplerini destekler.",
                  "tags": ["sharedpreferences", "data_types"]
                },
                {
                  "questionId": 260103,
                  "question": "Aşağıdaki kodda \"username\" anahtarına hangi değer kaydedilir?",
                  "questionType": "multiple_choice",
                  "code": "val prefs = getSharedPreferences(\"MyPrefs\", Context.MODE_PRIVATE)\nprefs.edit().putString(\"username\", \"Ahmet\").apply()",
                  "difficulty": "easy",
                  "options": [
                    "MyPrefs",
                    "Ahmet",
                    "username",
                    "prefs"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "putString(\"username\", \"Ahmet\") ile \"username\" anahtarına \"Ahmet\" değeri kaydedilir.",
                  "tags": ["sharedpreferences", "putstring"]
                },
                {
                  "questionId": 260104,
                  "question": "SharedPreferences'ta kayıtlı veri uygulama kapatıldığında ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Silinir",
                    "Korunur, kalıcıdır",
                    "Sadece 1 gün saklanır",
                    "Rastgele olarak silinir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SharedPreferences kalıcı veri saklar. Uygulama kapatılsa bile veriler korunur.",
                  "tags": ["sharedpreferences", "persistence"]
                },
                {
                  "questionId": 260105,
                  "question": "SharedPreferences'tan veri okumak için hangi metot kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "prefs.getString(\"key\", defaultValue)",
                    "prefs.readString(\"key\")",
                    "prefs.fetch(\"key\")",
                    "prefs.load(\"key\")"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "SharedPreferences'tan veri okumak için getString(\"key\", defaultValue), getInt(), getBoolean() gibi metotlar kullanılır. İkinci parametre default değerdir.",
                  "tags": ["sharedpreferences", "getstring"]
                }
              ]
            },
            {
              "topicId": 2602,
              "title": "Internal Storage",
              "summary": "Internal Storage, uygulamaya özel dosyaların cihazın dahili hafızasında saklanmasını sağlar. Bu veriler yalnızca ilgili uygulama tarafından erişilebilir.",
              "content": "## Internal Storage\n\nInternal Storage güvenli bir veri saklama yöntemidir.\n\nDosyalar uygulamaya özeldir ve başka uygulamalar erişemez.\n\nUygulama silindiğinde veriler de silinir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Internal Storage Dosya Yazma",
                  "code": "openFileOutput(\"data.txt\", Context.MODE_PRIVATE).use {\n    it.write(\"Merhaba\".toByteArray())\n}",
                  "explanation": "Internal Storage'a dosya yazma örneği."
                }
              ],
              "keyPoints": [
                "Uygulamaya özeldir",
                "Güvenlidir",
                "Dosya bazlı veri saklar",
                "Uygulama silinince veriler silinir"
              ],
              "questions": [
                {
                  "questionId": 260201,
                  "question": "Internal Storage ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece resim saklamak",
                    "Uygulamaya özel dosyaları güvenli şekilde saklamak",
                    "Sadece network isteği",
                    "Sadece SharedPreferences"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Internal Storage, uygulamaya özel dosyaların cihazın dahili hafızasında güvenli şekilde saklanmasını sağlar.",
                  "tags": ["internal_storage", "temel"]
                },
                {
                  "questionId": 260202,
                  "question": "Internal Storage'da saklanan verilere başka uygulamalar erişebilir mi?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet, herkes erişebilir",
                    "Hayır, sadece ilgili uygulama erişebilir",
                    "Sadece sistem uygulamaları erişebilir",
                    "Kullanıcı izni ile erişilebilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Internal Storage'da saklanan dosyalar uygulamaya özeldir ve başka uygulamalar erişemez. Bu güvenli bir veri saklama yöntemidir.",
                  "tags": ["internal_storage", "security"]
                },
                {
                  "questionId": 260203,
                  "question": "Uygulama silindiğinde Internal Storage'daki veriler ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Korunur",
                    "Cihazda kalır",
                    "Otomatik olarak silinir",
                    "Cloud'a yüklenir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Uygulama silindiğinde Internal Storage'daki tüm veriler de otomatik olarak silinir.",
                  "tags": ["internal_storage", "lifecycle"]
                },
                {
                  "questionId": 260204,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "openFileOutput(\"data.txt\", Context.MODE_PRIVATE).use {\n    it.write(\"Merhaba\".toByteArray())\n}",
                  "difficulty": "medium",
                  "options": [
                    "External Storage'a dosya yazar",
                    "Internal Storage'a data.txt dosyası oluşturur ve \"Merhaba\" yazar",
                    "Veritabanına veri ekler",
                    "Network'e veri gönderir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "openFileOutput ile Internal Storage'a data.txt dosyası oluşturulur ve \"Merhaba\" metni yazılır.",
                  "tags": ["internal_storage", "file_write"]
                }
              ]
            },
            {
              "topicId": 2603,
              "title": "External Storage (Kavramsal)",
              "summary": "External Storage, cihazın ortak depolama alanını kullanarak veri saklamayı ifade eder. Diğer uygulamalar ve kullanıcı tarafından erişilebilir olduğu için güvenlik açısından dikkatli kullanılmalıdır.",
              "content": "## External Storage\n\nExternal Storage genellikle medya dosyaları için kullanılır.\n\nAndroid 10 ve sonrası sürümlerde scoped storage kavramı ile erişim kısıtlanmıştır.\n\nİzin (permission) gerektirebilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [],
              "keyPoints": [
                "Ortak depolama alanıdır",
                "Diğer uygulamalar erişebilir",
                "Permission gerektirebilir",
                "Medya dosyaları için uygundur"
              ],
              "questions": [
                {
                  "questionId": 260301,
                  "question": "External Storage ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece uygulamaya özel alan",
                    "Cihazın ortak depolama alanı",
                    "Sadece cloud storage",
                    "Sadece SharedPreferences"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "External Storage, cihazın ortak depolama alanını kullanarak veri saklamayı ifade eder.",
                  "tags": ["external_storage", "temel"]
                },
                {
                  "questionId": 260302,
                  "question": "External Storage genellikle hangi tür dosyalar için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece şifreler",
                    "Medya dosyaları (resim, video, müzik)",
                    "Sadece kod dosyaları",
                    "Sadece veritabanı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "External Storage genellikle medya dosyaları (resim, video, müzik) için kullanılır çünkü bu dosyalara diğer uygulamalar da erişebilir.",
                  "tags": ["external_storage", "media"]
                },
                {
                  "questionId": 260303,
                  "question": "Android 10 ve sonrası sürümlerde External Storage erişimi nasıl değişti?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Tamamen kaldırıldı",
                    "Scoped storage kavramı ile erişim kısıtlandı",
                    "Hiçbir değişiklik olmadı",
                    "Sadece root cihazlar erişebilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android 10 ve sonrası sürümlerde scoped storage kavramı ile External Storage erişimi kısıtlanmış ve daha güvenli hale getirilmiştir.",
                  "tags": ["external_storage", "scoped_storage"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 260001,
              "question": "Kullanıcı ayarlarını (tema, dil tercihi) saklamak için hangi yöntem en uygundur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Internal Storage",
                "External Storage",
                "SharedPreferences",
                "Veritabanı"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Kullanıcı ayarları gibi küçük ve basit veriler için SharedPreferences en uygun yöntemdir.",
              "tags": ["sharedpreferences", "use_case"]
            },
            {
              "questionId": 260002,
              "question": "Internal Storage ve External Storage arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "Internal uygulamaya özel, External ortak alan",
                "Internal daha yavaştır",
                "External daha güvenlidir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Internal Storage uygulamaya özeldir ve güvenlidir. External Storage ise ortak depolama alanıdır ve diğer uygulamalar tarafından erişilebilir.",
              "tags": ["internal_storage", "external_storage", "difference"]
            },
            {
              "questionId": 260003,
              "question": "SharedPreferences ile büyük bir liste veya karmaşık nesne saklamak uygun mudur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, en uygun yöntem",
                "Hayır, SharedPreferences küçük ve basit veriler içindir",
                "Sadece String liste için uygun",
                "Fark etmez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SharedPreferences küçük ve basit veriler için tasarlanmıştır. Büyük listeler veya karmaşık nesneler için veritabanı (Room) veya dosya sistemi kullanılmalıdır.",
              "tags": ["sharedpreferences", "limitation"]
            },
            {
              "questionId": 260004,
              "question": "SharedPreferences'a veri yazarken commit() ve apply() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "commit() senkron, apply() asenkron çalışır",
                "apply() daha yavaştır",
                "commit() kullanımdan kaldırıldı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "commit() senkron çalışır ve boolean döner, apply() asenkron çalışır ve daha hızlıdır. Genellikle apply() tercih edilir.",
              "tags": ["sharedpreferences", "commit_apply"]
            },
            {
              "questionId": 260005,
              "question": "Hassas verileri (şifre, token) saklamak için hangi yöntem en güvenlidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "SharedPreferences (düz metin)",
                "External Storage",
                "EncryptedSharedPreferences veya Keystore",
                "Sadece RAM'de tutmak"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Hassas veriler için EncryptedSharedPreferences veya Android Keystore kullanılmalıdır. Düz SharedPreferences güvenli değildir.",
              "tags": ["security", "encrypted"]
            },
            {
              "questionId": 260006,
              "question": "Internal Storage'da saklanan dosyaları kullanıcı manuel olarak görebilir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, dosya yöneticisinden kolayca",
                "Hayır, normal koşullarda erişemez",
                "Sadece root cihazlarda",
                "Sadece USB ile bağlanınca"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Internal Storage uygulamaya özeldir ve normal koşullarda kullanıcı manuel olarak erişemez. Root cihazlarda veya özel araçlarla erişilebilir.",
              "tags": ["internal_storage", "access"]
            },
            {
              "questionId": 260007,
              "question": "SharedPreferences dosyası cihazda nerede saklanır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "External Storage",
                "SD Kart",
                "Internal Storage (app data klasörü)",
                "Cloud"
              ],
              "correctAnswerIndex": 2,
              "explanation": "SharedPreferences dosyası, Internal Storage'da uygulamanın data klasöründe XML dosyası olarak saklanır (/data/data/paket_adi/shared_prefs/).",
              "tags": ["sharedpreferences", "location"]
            },
            {
              "questionId": 260008,
              "question": "Context.MODE_PRIVATE ne anlama gelir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Herkes erişebilir",
                "Sadece ilgili uygulama erişebilir",
                "Sadece sistem erişebilir",
                "Sadece internet üzerinden erişilebilir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Context.MODE_PRIVATE, dosyanın veya SharedPreferences'ın sadece ilgili uygulama tarafından erişilebilir olduğunu belirtir.",
              "tags": ["mode_private", "context"]
            },
            {
              "questionId": 260009,
              "question": "External Storage'a erişim için izin (permission) gerekli midir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hayır, hiçbir zaman",
                "Evet, genellikle READ/WRITE_EXTERNAL_STORAGE",
                "Sadece resim için",
                "Sadece video için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "External Storage'a erişim için genellikle READ_EXTERNAL_STORAGE ve WRITE_EXTERNAL_STORAGE izinleri gereklidir. Android 10+'da scoped storage ile bazı durumlarda izin gerekmez.",
              "tags": ["external_storage", "permission"]
            },
            {
              "questionId": 260010,
              "question": "Hangi veri saklama yöntemi en hızlıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Veritabanı",
                "External Storage",
                "SharedPreferences (küçük veriler için)",
                "Network isteği"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Küçük ve basit veriler için SharedPreferences en hızlı yöntemdir çünkü hafiftir ve doğrudan bellekte çalışır.",
              "tags": ["performance", "comparison"]
            }
          ]
        }
      ],
      "interviewQuestions": []
    },
    {
      "categoryId": 3,
      "categoryTitle": "Android Orta - İleri Seviye",
      "categoryDescription": "Modern Android geliştirme teknikleri",
      "order": 3,
      "sections": [
        {
        "sectionId": 3100,
        "sectionTitle": "RecyclerView",
        "sectionDescription": "Liste ve grid yapılarında performanslı veri gösterimi için kullanılan RecyclerView bileşeninin detaylı incelenmesi",
        "order": 1,
        "topics": [
          {
            "topicId": 3101,
            "title": "RecyclerView Mantığı",
            "summary": "RecyclerView, büyük veri listelerini performanslı şekilde göstermek için kullanılan modern bir listeleme bileşenidir. Görünmeyen item'ları yeniden kullanarak (recycle) bellek ve performans avantajı sağlar.",
            "content": "## RecyclerView Mantığı\n\nRecyclerView, View recycling mantığı ile çalışır.\n\nEkranda görünmeyen item'lar yok edilmez, yeniden kullanılır.\n\nBu yapı özellikle uzun listelerde yüksek performans sağlar.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "RecyclerView Tanımı",
                "code": "val recyclerView = findViewById<RecyclerView>(R.id.recyclerView)\nrecyclerView.layoutManager = LinearLayoutManager(this)",
                "explanation": "RecyclerView için LayoutManager tanımlaması."
              }
            ],
            "keyPoints": [
              "View recycling kullanır",
              "Performanslıdır",
              "Büyük listeler için uygundur",
              "LayoutManager ile çalışır"
            ],
            "questions": [
              {
                "questionId": 311001,
                "question": "RecyclerView hangi problemi çözmek için tasarlanmıştır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Tek View göstermek",
                  "Animasyon eklemek",
                  "Büyük veri listelerini verimli göstermek",
                  "Fragment geçişi yapmak"
                ],
                "correctAnswerIndex": 2,
                "explanation": "RecyclerView, büyük veri listelerini minimum bellek ve yüksek performansla göstermek için geliştirilmiştir.",
                "tags": ["recyclerview", "temel"]
              },
              {
                "questionId": 311002,
                "question": "RecyclerView’da View’lar nasıl yeniden kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Yeni View oluşturarak",
                  "ViewHolder cache mekanizmasıyla",
                  "Fragment yeniden başlatılarak",
                  "LayoutInflater ile sürekli inflate ederek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "RecyclerView, ViewHolder’ları yeniden kullanarak performansı artırır.",
                "tags": ["recyclerview", "performance"]
              },
              {
                "questionId": 311003,
                "question": "RecyclerView’da LayoutManager neden zorunludur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Veri kaynağı belirlemek için",
                  "Item click yönetimi için",
                  "Item’ların ekranda nasıl yerleşeceğini belirlemek için",
                  "Lifecycle kontrolü için"
                ],
                "correctAnswerIndex": 2,
                "explanation": "LayoutManager olmadan RecyclerView item’ların nasıl yerleşeceğini bilemez.",
                "tags": ["layoutmanager", "recyclerview"]
              }
            ]
          },
          {
            "topicId": 3102,
            "title": "Adapter",
            "summary": "Adapter, RecyclerView ile veri kaynağı arasındaki bağlantıyı sağlar. Her bir item için hangi layout'un kullanılacağını ve verinin nasıl bağlanacağını belirler.",
            "content": "## Adapter\n\nAdapter, RecyclerView'ın kalbidir.\n\nVeri setini ViewHolder ile bağlar.\n\nonCreateViewHolder, onBindViewHolder ve getItemCount metotlarını içerir.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Adapter Yapısı",
                "code": "class MyAdapter(private val list: List<String>) : RecyclerView.Adapter<MyViewHolder>() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)\n        return MyViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        holder.bind(list[position])\n    }\n\n    override fun getItemCount() = list.size\n}",
                "explanation": "RecyclerView Adapter temel yapısı."
              }
            ],
            "keyPoints": [
              "Veri ile UI arasındaki köprüdür",
              "ViewHolder kullanır",
              "Performans için gereklidir",
              "Liste güncellemelerini yönetir"
            ],
            "questions": [
              {
                "questionId": 312001,
                "question": "Adapter’ın temel görevi nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "UI tasarlamak",
                  "Veri ile View’ları bağlamak",
                  "Lifecycle yönetmek",
                  "Navigation yapmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Adapter, veri kaynağı ile RecyclerView item’ları arasında köprü görevi görür.",
                "tags": ["adapter", "recyclerview"]
              },
              {
                "questionId": 312002,
                "question": "RecyclerView.Adapter içinde zorunlu olan metot hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "onCreate",
                  "getItemCount",
                  "onPause",
                  "onDestroy"
                ],
                "correctAnswerIndex": 1,
                "explanation": "getItemCount(), RecyclerView’da kaç item olacağını belirtir ve zorunludur.",
                "tags": ["adapter", "method"]
              },
              {
                "questionId": 312003,
                "question": "onCreateViewHolder metodu ne zaman çağrılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Her scroll’da",
                  "Yeni ViewHolder oluşturulması gerektiğinde",
                  "Liste güncellendiğinde",
                  "Activity destroy edildiğinde"
                ],
                "correctAnswerIndex": 1,
                "explanation": "onCreateViewHolder, yeni bir ViewHolder oluşturulması gerektiğinde çağrılır.",
                "tags": ["adapter", "viewholder"]
              },
              {
                "questionId": 312004,
                "question": "ListAdapter neden normal Adapter’a göre tercih edilir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Daha az kod yazıldığı için",
                  "DiffUtil’u otomatik yönettiği için",
                  "XML gerektirmediği için",
                  "Fragment ile çalıştığı için"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ListAdapter, DiffUtil entegrasyonunu otomatik yaparak performanslı liste güncellemeleri sağlar.",
                "tags": ["listadapter", "diffutil"]
              }
            ]
          },
          {
            "topicId": 3103,
            "title": "ViewHolder",
            "summary": "ViewHolder, RecyclerView item'larının görünüm referanslarını tutarak findViewById çağrılarını minimize eder ve performansı artırır.",
            "content": "## ViewHolder\n\nHer item için ViewHolder oluşturulur.\n\nView referanslarını cache'ler.\n\nRecyclerView performansının temel parçalarındandır.",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "ViewHolder Tanımı",
                "code": "class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    fun bind(text: String) {\n        itemView.findViewById<TextView>(R.id.textView).text = text\n    }\n}",
                "explanation": "RecyclerView ViewHolder örneği."
              }
            ],
            "keyPoints": [
              "View referanslarını tutar",
              "Performansı artırır",
              "Adapter ile birlikte çalışır",
              "Her item için kullanılır"
            ],
            "questions": [
              {
                "questionId": 313001,
                "question": "ViewHolder’ın temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veri saklamak",
                  "View referanslarını tutmak",
                  "Navigation yönetmek",
                  "Fragment oluşturmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ViewHolder, View referanslarını tutarak tekrar tekrar findViewById çağrılmasını önler.",
                "tags": ["viewholder", "performance"]
              },
              {
                "questionId": 313002,
                "question": "ViewHolder performansa nasıl katkı sağlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Bellek kullanımını artırarak",
                  "UI thread’i bloke ederek",
                  "View aramalarını azaltarak",
                  "Veri kopyalayarak"
                ],
                "correctAnswerIndex": 2,
                "explanation": "ViewHolder, View aramalarını azaltarak RecyclerView performansını artırır.",
                "tags": ["viewholder", "optimization"]
              },
              {
                "questionId": 313003,
                "question": "RecyclerView’da ViewHolder kullanılmazsa ne olur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Uygulama crash olur",
                  "Performans düşer",
                  "Liste görünmez",
                  "Adapter çalışmaz"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ViewHolder kullanılmazsa sürekli View araması yapılır ve performans ciddi şekilde düşer.",
                "tags": ["viewholder", "performance"]
              }
            ]
          },
          {
            "topicId": 3104,
            "title": "DiffUtil (Opsiyonel)",
            "summary": "DiffUtil, RecyclerView listelerindeki değişiklikleri minimum maliyetle hesaplayarak sadece değişen item'ların güncellenmesini sağlar.",
            "content": "## DiffUtil\n\nListe güncellemelerinde performans sağlar.\n\nnotifyDataSetChanged yerine önerilir.\n\nÖzellikle büyük listelerde fark yaratır.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "DiffUtil Kullanımı",
                "code": "class MyDiffUtil : DiffUtil.ItemCallback<Item>() {\n    override fun areItemsTheSame(oldItem: Item, newItem: Item) = oldItem.id == newItem.id\n\n    override fun areContentsTheSame(oldItem: Item, newItem: Item) = oldItem == newItem\n}",
                "explanation": "DiffUtil ile liste karşılaştırma."
              }
            ],
            "keyPoints": [
              "Performanslı liste güncelleme sağlar",
              "Sadece değişen item'ları günceller",
              "notifyDataSetChanged yerine kullanılır",
              "Large listelerde önerilir"
            ],
            "questions": [
              {
                "questionId": 314001,
                "question": "DiffUtil’un temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Liste sıralamak",
                  "Veri saklamak",
                  "Liste farklarını hesaplamak",
                  "UI çizmek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "DiffUtil, eski ve yeni liste arasındaki farkları hesaplar.",
                "tags": ["diffutil", "recyclerview"]
              },
              {
                "questionId": 314002,
                "question": "DiffUtil hangi durumda performans avantajı sağlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Tüm liste değiştiğinde",
                  "Sadece birkaç item değiştiğinde",
                  "Liste boşken",
                  "Tek item varken"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Sadece değişen item’lar güncellendiği için performans artar.",
                "tags": ["diffutil", "performance"]
              },
              {
                "questionId": 314003,
                "question": "areItemsTheSame metodu neyi kontrol eder?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "İçerik eşitliğini",
                  "Referans eşitliğini",
                  "Item kimliğini",
                  "Liste boyutunu"
                ],
                "correctAnswerIndex": 2,
                "explanation": "areItemsTheSame, iki item’ın aynı kimliğe sahip olup olmadığını kontrol eder.",
                "tags": ["diffutil", "callback"]
              },
              {
                "questionId": 314004,
                "question": "areContentsTheSame ne zaman false döner?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Item ID değiştiğinde",
                  "Liste boşken",
                  "Item içeriği değiştiğinde",
                  "Adapter null olduğunda"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Item’ın içeriği değiştiğinde areContentsTheSame false döner.",
                "tags": ["diffutil", "update"]
              },
              {
                "questionId": 314005,
                "question": "DiffUtil yanlış kullanılırsa ne olur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Crash oluşur",
                  "Yanlış animasyonlar görülür",
                  "Uygulama açılmaz",
                  "Veri silinir"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Yanlış karşılaştırmalar UI’da hatalı animasyonlara neden olabilir.",
                "tags": ["diffutil", "bug"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 310001,
            "question": "RecyclerView’un temel amacı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Tek bir View göstermek",
              "Az sayıda veriyi statik göstermek",
              "Büyük veri listelerini performanslı göstermek",
              "Fragment geçişlerini yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "RecyclerView, büyük veri listelerini minimum bellek kullanımıyla performanslı şekilde göstermek için tasarlanmıştır.",
            "tags": ["recyclerview", "temel"]
          },
          {
            "questionId": 310002,
            "question": "RecyclerView’da liste düzenini belirleyen bileşen hangisidir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Adapter",
              "ViewHolder",
              "LayoutManager",
              "DiffUtil"
            ],
            "correctAnswerIndex": 2,
            "explanation": "LayoutManager, RecyclerView’daki item’ların dikey, yatay veya grid şeklinde nasıl yerleşeceğini belirler.",
            "tags": ["layoutmanager", "recyclerview"]
          },
          {
            "questionId": 310003,
            "question": "Adapter’ın temel görevi nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Veri saklamak",
              "View’ları çizmek",
              "Veri ile View’ları bağlamak",
              "Lifecycle yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Adapter, veri kaynağı ile RecyclerView item’ları arasındaki bağlantıyı sağlar.",
            "tags": ["adapter", "recyclerview"]
          },
          {
            "questionId": 310004,
            "question": "ViewHolder neden kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "UI tasarımı yapmak için",
              "Veritabanı bağlantısı için",
              "findViewById çağrılarını azaltmak için",
              "Fragment yönetimi için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewHolder, View referanslarını tutarak gereksiz findViewById çağrılarını azaltır ve performansı artırır.",
            "tags": ["viewholder", "performance"]
          },
          {
            "questionId": 310005,
            "question": "RecyclerView.Adapter içinde zorunlu olan metot hangisidir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "onClick",
              "getItemCount",
              "onResume",
              "notifyDataSetChanged"
            ],
            "correctAnswerIndex": 1,
            "explanation": "getItemCount(), RecyclerView’ın kaç item göstereceğini belirtir ve zorunludur.",
            "tags": ["adapter", "method"]
          },
          {
            "questionId": 310006,
            "question": "onBindViewHolder metodu ne zaman çağrılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "RecyclerView oluşturulurken",
              "Yeni ViewHolder oluşturulurken",
              "Item ekrana bağlanırken",
              "Liste temizlenirken"
            ],
            "correctAnswerIndex": 2,
            "explanation": "onBindViewHolder, item ekrana bağlanırken verinin ViewHolder’a aktarılması için çağrılır.",
            "tags": ["adapter", "binding"]
          },
          {
            "questionId": 310007,
            "question": "notifyDataSetChanged neden önerilmez?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Deprecated olduğu için",
              "Senkron çalıştığı için",
              "Tüm listeyi yeniden çizdiği için",
              "Sadece küçük listelerde çalıştığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "notifyDataSetChanged tüm listeyi yeniler, bu da performans kaybına yol açar.",
            "tags": ["performance", "recyclerview"]
          },
          {
            "questionId": 310008,
            "question": "DiffUtil’un temel amacı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Listeyi sıralamak",
              "Veri kaydetmek",
              "Liste farklarını hesaplamak",
              "View oluşturmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "DiffUtil, eski ve yeni liste arasındaki farkları hesaplayarak sadece değişen item’ların güncellenmesini sağlar.",
            "tags": ["diffutil", "performance"]
          },
          {
            "questionId": 310009,
            "question": "DiffUtil kullanmanın en büyük avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Kodun kısalması",
              "Bellek kullanımının artması",
              "Daha az UI güncellemesi",
              "Lifecycle yönetimi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "DiffUtil, sadece değişen item’ları güncelleyerek performansı ciddi şekilde artırır.",
            "tags": ["diffutil", "optimization"]
          },
          {
            "questionId": 310010,
            "question": "RecyclerView neden ListView’a göre daha performanslıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Daha az XML kullanır",
              "View recycling ve ViewHolder zorunlu olduğu için",
              "Sadece küçük listelerde çalıştığı için",
              "Fragment ile çalıştığı için"
            ],
            "correctAnswerIndex": 1,
            "explanation": "RecyclerView, zorunlu ViewHolder ve gelişmiş recycling mekanizması sayesinde ListView’dan daha performanslıdır.",
            "tags": ["recyclerview", "performance"]
          }
        ]
      },
      {
        "sectionId": 3200,
        "sectionTitle": "Fragment & Navigation",
        "sectionDescription": "Fragment yapısı ve Android Navigation Component kullanarak ekranlar arası geçişlerin yönetilmesi",
        "order": 2,
        "topics": [
          {
            "topicId": 3201,
            "title": "Fragment",
            "summary": "Fragment, bir Activity içerisinde yer alan, kendi yaşam döngüsüne sahip modüler UI bileşenleridir. Tek bir Activity içinde birden fazla Fragment kullanılabilir.",
            "content": "## Fragment\n\nFragment'ler yeniden kullanılabilir UI parçalarıdır.\n\nActivity'lere bağımlı olarak çalışırlar.\n\nModern Android mimarisinde tek Activity - çok Fragment yaklaşımı yaygındır.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Fragment Tanımı",
                "code": "class HomeFragment : Fragment(R.layout.fragment_home)",
                "explanation": "Basit bir Fragment tanımı."
              }
            ],
            "keyPoints": [
              "Activity içinde çalışır",
              "Modüler UI sağlar",
              "Kendi lifecycle'ına sahiptir",
              "Yeniden kullanılabilir"
            ],
            "questions": [
              {
                "questionId": 320101,
                "question": "Fragment nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Bağımsız çalışan bir Activity",
                  "Activity içinde çalışan modüler UI bileşeni",
                  "Sadece arka plan işlemleri için kullanılan sınıf",
                  "Veritabanı yönetim sınıfı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Fragment, Activity içerisinde çalışan ve kendi yaşam döngüsüne sahip modüler UI bileşenidir.",
                "tags": ["fragment", "ui", "temel"]
              },
              {
                "questionId": 320102,
                "question": "Modern Android mimarisinde önerilen yapı hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Çok Activity - az Fragment",
                  "Tek Activity - çok Fragment",
                  "Her ekran için ayrı Activity",
                  "Fragment kullanmamak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Google, modern mimaride tek Activity içinde birden fazla Fragment kullanılmasını önerir.",
                "tags": ["fragment", "architecture", "best_practice"]
              },
              {
                "questionId": 320103,
                "question": "Fragment’ler neden yeniden kullanılabilir kabul edilir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Statik oldukları için",
                  "Activity’den bağımsız çalıştıkları için",
                  "Farklı Activity’lerde kullanılabildikleri için",
                  "Sadece XML içerdiği için"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Fragment’ler farklı Activity’lerde veya farklı layout yapılarında yeniden kullanılabilir.",
                "tags": ["fragment", "reusability", "ui"]
              },
              {
                "questionId": 320104,
                "question": "Fragment doğrudan ekranda çalışabilir mi?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Evet",
                  "Hayır, Activity’ye ihtiyaç duyar",
                  "Sadece Navigation Component ile",
                  "Sadece XML içinde"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Fragment’ler tek başına çalışamaz, mutlaka bir Activity’ye bağlı olmalıdır.",
                "tags": ["fragment", "activity", "lifecycle"]
              }
            ]
          },
          {
            "topicId": 3202,
            "title": "Fragment Lifecycle",
            "summary": "Fragment Lifecycle, Fragment'in oluşturulmasından yok edilmesine kadar geçen yaşam döngüsünü ifade eder. Activity lifecycle'dan daha karmaşıktır.",
            "content": "## Fragment Lifecycle\n\nonCreate, onCreateView, onViewCreated, onDestroyView gibi metotlar içerir.\n\nUI ve veri işlemleri doğru lifecycle aşamasında yapılmalıdır.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Lifecycle Metodu",
                "code": "override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n}",
                "explanation": "UI işlemleri için önerilen lifecycle metodu."
              }
            ],
            "keyPoints": [
              "Activity lifecycle'dan farklıdır",
              "onDestroyView kritik öneme sahiptir",
              "Memory leak riskleri vardır",
              "Doğru kullanım performansı artırır"
            ],
            "questions": [
              {
                "questionId": 320201,
                "question": "Fragment lifecycle neden Activity lifecycle’dan daha karmaşıktır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Daha az metodu olduğu için",
                  "View lifecycle ve Fragment lifecycle ayrı olduğu için",
                  "Sadece XML ile çalıştığı için",
                  "Async çalıştığı için"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Fragment’lerde View lifecycle ve Fragment lifecycle ayrı yönetildiği için daha karmaşıktır.",
                "tags": ["fragment_lifecycle", "lifecycle", "temel"]
              },
              {
                "questionId": 320202,
                "question": "UI işlemleri için Fragment’te en uygun lifecycle metodu hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "onCreate",
                  "onAttach",
                  "onViewCreated",
                  "onDestroy"
                ],
                "correctAnswerIndex": 2,
                "explanation": "onViewCreated, View tamamen hazır olduktan sonra çağrıldığı için UI işlemleri burada yapılmalıdır.",
                "tags": ["fragment_lifecycle", "ui", "best_practice"]
              },
              {
                "questionId": 320203,
                "question": "onDestroyView metodunun temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Fragment’i tamamen yok etmek",
                  "View referanslarını temizlemek",
                  "Activity’yi kapatmak",
                  "Navigation işlemini durdurmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "onDestroyView, View ile ilgili referansların temizlenmesi için kullanılır.",
                "tags": ["fragment_lifecycle", "memory", "view"]
              },
              {
                "questionId": 320204,
                "question": "Fragment lifecycle yanlış yönetilirse en büyük risk nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Crash",
                  "Memory leak",
                  "Navigation hatası",
                  "Veri kaybı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Yanlış lifecycle yönetimi memory leak oluşmasına neden olabilir.",
                "tags": ["fragment_lifecycle", "memory_leak", "advanced"]
              }
            ]
          },
          {
            "topicId": 3203,
            "title": "Navigation Component",
            "summary": "Navigation Component, Fragment'ler arası geçişleri güvenli, okunabilir ve merkezi bir şekilde yönetmeyi sağlar.",
            "content": "## Navigation Component\n\nNavigation Graph ile ekranlar tanımlanır.\n\nBackStack otomatik yönetilir.\n\nFragment geçişleri sadeleşir.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "Fragment Geçişi",
                "code": "findNavController().navigate(R.id.action_home_to_detail)",
                "explanation": "Navigation Component ile ekran geçişi."
              }
            ],
            "keyPoints": [
              "Merkezi navigasyon yönetimi",
              "BackStack otomatik yönetilir",
              "Fragment geçişleri kolaylaşır",
              "Best practice olarak önerilir"
            ],
            "questions": [
              {
                "questionId": 320301,
                "question": "Navigation Component’in temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veritabanı yönetmek",
                  "Fragment’ler arası geçişleri merkezi şekilde yönetmek",
                  "UI tasarlamak",
                  "Network isteklerini yönetmek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, Fragment’ler arası geçişleri merkezi, güvenli ve okunabilir şekilde yönetmek için kullanılır.",
                "tags": ["navigation_component", "navigation", "temel"]
              },
              {
                "questionId": 320302,
                "question": "Navigation Component hangi dosya ile ekran geçişlerini tanımlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "AndroidManifest.xml",
                  "navigation_graph.xml",
                  "styles.xml",
                  "build.gradle"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Graph XML dosyası, Fragment’ler ve aralarındaki geçişleri tanımlar.",
                "tags": ["navigation_component", "navigation_graph", "xml"]
              },
              {
                "questionId": 320303,
                "question": "Navigation Component kullanmanın en büyük avantajlarından biri nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Daha fazla kod yazmak",
                  "BackStack yönetimini otomatik yapması",
                  "Performansı düşürmesi",
                  "Sadece Activity ile çalışması"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, BackStack yönetimini otomatik yaparak hata riskini azaltır.",
                "tags": ["navigation_component", "backstack", "advantage"]
              },
              {
                "questionId": 320304,
                "question": "findNavController() fonksiyonu ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "View oluşturmak",
                  "Fragment silmek",
                  "Navigation işlemini başlatmak",
                  "Layout inflate etmek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "findNavController(), Navigation Component üzerinden ekran geçişlerini başlatmak için kullanılır.",
                "tags": ["navigation_component", "navcontroller", "advanced"]
              }
            ]
          },
          {
            "topicId": 3204,
            "title": "Safe Args",
            "summary": "Safe Args, Navigation Component ile Fragment'ler arasında tip güvenli veri aktarımı yapılmasını sağlar.",
            "content": "## Safe Args\n\nCompile-time güvenlik sağlar.\n\nYanlış key kullanımını engeller.\n\nParcelable ve Serializable destekler.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Safe Args Kullanımı",
                "code": "val action = HomeFragmentDirections.actionHomeToDetail(userId)\nfindNavController().navigate(action)",
                "explanation": "Safe Args ile veri gönderme."
              }
            ],
            "keyPoints": [
              "Tip güvenlidir",
              "Runtime hataları azaltır",
              "Navigation Component ile çalışır",
              "Önerilen veri aktarım yöntemidir"
            ],
            "questions": [
              {
                "questionId": 320301,
                "question": "Navigation Component’in temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veritabanı yönetmek",
                  "Fragment’ler arası geçişleri merkezi şekilde yönetmek",
                  "UI tasarlamak",
                  "Network isteklerini yönetmek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, Fragment’ler arası geçişleri merkezi, güvenli ve okunabilir şekilde yönetmek için kullanılır.",
                "tags": ["navigation_component", "navigation", "temel"]
              },
              {
                "questionId": 320302,
                "question": "Navigation Component hangi dosya ile ekran geçişlerini tanımlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "AndroidManifest.xml",
                  "navigation_graph.xml",
                  "styles.xml",
                  "build.gradle"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Graph XML dosyası, Fragment’ler ve aralarındaki geçişleri tanımlar.",
                "tags": ["navigation_component", "navigation_graph", "xml"]
              },
              {
                "questionId": 320303,
                "question": "Navigation Component kullanmanın en büyük avantajlarından biri nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Daha fazla kod yazmak",
                  "BackStack yönetimini otomatik yapması",
                  "Performansı düşürmesi",
                  "Sadece Activity ile çalışması"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, BackStack yönetimini otomatik yaparak hata riskini azaltır.",
                "tags": ["navigation_component", "backstack", "advantage"]
              },
              {
                "questionId": 320304,
                "question": "findNavController() fonksiyonu ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "View oluşturmak",
                  "Fragment silmek",
                  "Navigation işlemini başlatmak",
                  "Layout inflate etmek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "findNavController(), Navigation Component üzerinden ekran geçişlerini başlatmak için kullanılır.",
                "tags": ["navigation_component", "navcontroller", "advanced"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 320001,
            "question": "Fragment’lerin en büyük avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Daha fazla kod yazmak",
              "Modüler ve yeniden kullanılabilir UI sunması",
              "Sadece XML kullanması",
              "Activity ihtiyacını kaldırması"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Fragment’ler modüler yapıları sayesinde yeniden kullanılabilir UI sunar.",
            "tags": ["fragment", "ui", "modular"]
          },
          {
            "questionId": 320002,
            "question": "Navigation Component neden önerilir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "BackStack yönetimini otomatik yaptığı için",
              "Daha yavaş çalıştığı için",
              "Sadece XML kullandığı için",
              "Activity’leri kaldırdığı için"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Navigation Component, BackStack yönetimini otomatik yaparak hata riskini azaltır.",
            "tags": ["navigation_component", "best_practice"]
          },
          {
            "questionId": 320003,
            "question": "Fragment’te memory leak riski en çok hangi durumda oluşur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "onCreate içinde işlem yapmak",
              "View referanslarını onDestroyView’da temizlememek",
              "Navigation kullanmak",
              "Safe Args kullanmak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "View referansları onDestroyView’da temizlenmezse memory leak oluşabilir.",
            "tags": ["fragment", "memory_leak", "lifecycle"]
          },
          {
            "questionId": 320004,
            "question": "Safe Args kullanmanın temel faydası nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Daha hızlı navigation",
              "Tip güvenli veri aktarımı",
              "Daha az XML",
              "Daha az Fragment"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe Args, Fragment’ler arası veri aktarımında tip güvenliği sağlar.",
            "tags": ["safe_args", "type_safety"]
          },
          {
            "questionId": 320005,
            "question": "Navigation Graph nerede tanımlanır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Java/Kotlin sınıfında",
              "res/navigation klasöründe",
              "AndroidManifest.xml içinde",
              "res/layout içinde"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Graph, res/navigation klasörü altında XML olarak tanımlanır.",
            "tags": ["navigation_graph", "xml", "navigation"]
          },
          {
            "questionId": 320006,
            "question": "Fragment’ler hangi bileşene bağımlıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Service",
              "BroadcastReceiver",
              "Activity",
              "ViewModel"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fragment’ler çalışabilmek için bir Activity’ye ihtiyaç duyar.",
            "tags": ["fragment", "activity", "dependency"]
          },
          {
            "questionId": 320007,
            "question": "Navigation Component kullanmadan Fragment geçişi nasıl yapılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Intent ile",
              "FragmentTransaction ile",
              "Safe Args ile",
              "ViewBinding ile"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Component olmadan FragmentTransaction kullanılarak geçiş yapılır.",
            "tags": ["fragment", "fragment_transaction", "navigation"]
          },
          {
            "questionId": 320008,
            "question": "Safe Args olmadan veri aktarımı genellikle ne ile yapılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Intent extras",
              "Bundle",
              "ViewModel",
              "SharedPreferences"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Fragment’ler arasında veri aktarımı genellikle Bundle ile yapılır.",
            "tags": ["bundle", "fragment", "data_transfer"]
          },
          {
            "questionId": 320009,
            "question": "Navigation Component BackStack’i nasıl yönetir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Manuel",
              "Otomatik",
              "Service ile",
              "Broadcast ile"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Component BackStack’i otomatik olarak yönetir.",
            "tags": ["navigation_component", "backstack"]
          },
          {
            "questionId": 320010,
            "question": "Safe Args neden compile-time güvenlik sağlar?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Reflection kullandığı için",
              "Otomatik key oluşturduğu için",
              "Generated class’lar ile çalıştığı için",
              "Runtime kontrol yaptığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Safe Args, compile-time’da oluşturulan sınıflar sayesinde tip güvenliği sağlar.",
            "tags": ["safe_args", "compile_time", "advanced"]
          }
        ]
      },
      {
        "sectionId": 3300,
        "sectionTitle": "Veritabanı (Room)",
        "sectionDescription": "Android uygulamalarda yerel veritabanı kullanımı ve Room kütüphanesinin temel bileşenleri",
        "order": 3,
        "topics": [
          {
            "topicId": 3301,
            "title": "SQLite Temelleri",
            "summary": "SQLite, Android cihazlarda yerleşik olarak bulunan hafif ve ilişkisel bir veritabanıdır. Tablolar, satırlar ve sütunlar üzerinden veri saklar. Android'de uzun süreli ve kalıcı veri saklamak için kullanılır.",
            "content": "## SQLite Temelleri\n\nSQLite ilişkisel bir veritabanıdır.\n\nSQL sorguları ile veri ekleme, silme, güncelleme ve okuma işlemleri yapılır.\n\nRoom, SQLite üzerinde çalışan bir soyutlama katmanıdır.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Android'e gömülü gelir",
              "İlişkisel veritabanıdır",
              "SQL tabanlıdır",
              "Room altyapı olarak SQLite kullanır"
            ],
            "questions": []
          },
          {
            "topicId": 3302,
            "title": "Entity",
            "summary": "Entity, Room veritabanında bir tabloyu temsil eden Kotlin sınıfıdır. Her Entity sınıfı bir tabloya, her property ise bir sütuna karşılık gelir.",
            "content": "## Entity\n\n@Entity anotasyonu ile tanımlanır.\n\nPrimary key zorunludur.\n\nVeritabanı şemasını temsil eder.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Entity Örneği",
                "code": "@Entity\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val name: String,\n    val age: Int\n)",
                "explanation": "User tablosunu temsil eden bir Entity sınıfı."
              }
            ],
            "keyPoints": [
              "Tabloyu temsil eder",
              "PrimaryKey zorunludur",
              "data class olarak tanımlanır",
              "@Entity anotasyonu kullanılır"
            ],
            "questions": []
          },
          {
            "topicId": 3303,
            "title": "DAO",
            "summary": "DAO (Data Access Object), veritabanı işlemlerinin tanımlandığı arayüzdür. SQL sorguları bu katmanda yazılır ve veriye erişim buradan sağlanır.",
            "content": "## DAO\n\n@Dao anotasyonu ile tanımlanır.\n\nInsert, Delete, Update ve Query metotları içerir.\n\nVeri erişim katmanıdır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "DAO Örneği",
                "code": "@Dao\ninterface UserDao {\n    @Insert\n    suspend fun insert(user: User)\n\n    @Query(\"SELECT * FROM User\")\n    suspend fun getAllUsers(): List<User>\n}",
                "explanation": "User tablosu için DAO tanımı."
              }
            ],
            "keyPoints": [
              "Veri erişim katmanıdır",
              "SQL sorguları burada yazılır",
              "Interface olarak tanımlanır",
              "Suspend fonksiyonlarla çalışabilir"
            ],
            "questions": []
          },
          {
            "topicId": 3304,
            "title": "Database",
            "summary": "Database sınıfı, Room veritabanının ana erişim noktasıdır. Entity ve DAO'ları bir araya getirir ve singleton olarak kullanılır.",
            "content": "## Database\n\n@Database anotasyonu ile tanımlanır.\n\nAbstract class olmalıdır.\n\nVeritabanı versiyonlamasını yönetir.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Database Tanımı",
                "code": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}",
                "explanation": "Room Database tanımı."
              }
            ],
            "keyPoints": [
              "RoomDatabase'den türetilir",
              "Singleton olarak kullanılır",
              "DAO'lara erişim sağlar",
              "Version yönetimi içerir"
            ],
            "questions": []
          },
          {
            "topicId": 3305,
            "title": "CRUD İşlemleri",
            "summary": "CRUD işlemleri, Create (Ekle), Read (Oku), Update (Güncelle) ve Delete (Sil) işlemlerini ifade eder. Room ile bu işlemler anotasyonlar sayesinde kolayca yapılır.",
            "content": "## CRUD İşlemleri\n\nInsert, Query, Update ve Delete anotasyonları kullanılır.\n\nSuspend fonksiyonlarla arka planda çalıştırılmalıdır.",
            "difficulty": "medium",
            "order": 5,
            "codeExamples": [
              {
                "title": "CRUD Örneği",
                "code": "@Update\nsuspend fun updateUser(user: User)\n\n@Delete\nsuspend fun deleteUser(user: User)",
                "explanation": "Room ile güncelleme ve silme işlemleri."
              }
            ],
            "keyPoints": [
              "CRUD = Create, Read, Update, Delete",
              "Room anotasyonları ile yapılır",
              "Suspend fonksiyon önerilir",
              "Ana thread bloklanmamalıdır"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": []
      },
      {
        "sectionId": 3400,
        "sectionTitle": "MVVM Mimarisi",
        "sectionDescription": "Android uygulamalarda sürdürülebilir, test edilebilir ve okunabilir mimari yapı kurmak için kullanılan MVVM yaklaşımı",
        "order": 4,
        "topics": [
          {
            "topicId": 3401,
            "title": "MVVM Nedir",
            "summary": "MVVM (Model-View-ViewModel), kullanıcı arayüzü ile iş mantığını birbirinden ayırmayı amaçlayan bir mimari tasarım desenidir. Kodun daha okunabilir, test edilebilir ve sürdürülebilir olmasını sağlar.",
            "content": "## MVVM Nedir\n\nMVVM üç ana bileşenden oluşur:\n\n- Model: Veri katmanı\n- View: UI katmanı\n- ViewModel: İş mantığı ve state yönetimi\n\nAndroid'de Google tarafından önerilen mimaridir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Katmanlı mimari sağlar",
              "UI ve iş mantığını ayırır",
              "Test edilebilirliği artırır",
              "Modern Android için önerilir"
            ],
            "questions": []
          },
          {
            "topicId": 3402,
            "title": "ViewModel",
            "summary": "ViewModel, UI ile ilişkili verileri saklayan ve yöneten bileşendir. Configuration change (ekran döndürme gibi) durumlarında verinin kaybolmasını engeller.",
            "content": "## ViewModel\n\nViewModel, lifecycle-aware bir bileşendir.\n\nUI logic burada tutulur.\n\nActivity ve Fragment'tan bağımsızdır.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "ViewModel Tanımı",
                "code": "class MainViewModel : ViewModel() {\n    val counter = MutableLiveData<Int>()\n}",
                "explanation": "Basit bir ViewModel örneği."
              }
            ],
            "keyPoints": [
              "Lifecycle-aware çalışır",
              "UI verisini tutar",
              "Configuration change'lerde silinmez",
              "Business logic içerir"
            ],
            "questions": []
          },
          {
            "topicId": 3403,
            "title": "LiveData",
            "summary": "LiveData, lifecycle-aware ve gözlemlenebilir bir veri tutucudur. UI katmanı, veri değişikliklerini otomatik olarak takip eder.",
            "content": "## LiveData\n\nObserver pattern kullanır.\n\nLifecycle'a duyarlıdır.\n\nMemory leak riskini azaltır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "LiveData Kullanımı",
                "code": "viewModel.counter.observe(viewLifecycleOwner) {\n    textView.text = it.toString()\n}",
                "explanation": "LiveData gözlemlenmesi."
              }
            ],
            "keyPoints": [
              "Observer pattern kullanır",
              "Lifecycle-aware'dır",
              "UI otomatik güncellenir",
              "Thread-safe veri akışı sağlar"
            ],
            "questions": []
          },
          {
            "topicId": 3404,
            "title": "Repository",
            "summary": "Repository, veri kaynaklarını (API, Room, Cache) tek bir noktadan yöneten katmandır. ViewModel'in veri kaynağına doğrudan erişmesini engeller.",
            "content": "## Repository\n\nTek sorumluluk prensibini destekler.\n\nVeri kaynaklarını soyutlar.\n\nViewModel ile data source arasında köprü görevi görür.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Repository Örneği",
                "code": "class UserRepository(private val dao: UserDao) {\n    suspend fun getUsers() = dao.getAllUsers()\n}",
                "explanation": "Room kullanan basit bir Repository örneği."
              }
            ],
            "keyPoints": [
              "Veri kaynaklarını soyutlar",
              "ViewModel bağımlılığını azaltır",
              "Test yazımını kolaylaştırır",
              "Clean Architecture'a uygundur"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": []
      },
      {
        "sectionId": 3500,
        "sectionTitle": "Networking",
        "sectionDescription": "Android uygulamalarda internet üzerinden veri alışverişi yapmak için kullanılan temel networking kavramları ve araçlar",
        "order": 5,
        "topics": [
          {
            "topicId": 3501,
            "title": "REST API",
            "summary": "REST API, istemci ve sunucu arasında HTTP protokolü üzerinden veri alışverişi yapılmasını sağlayan mimari bir yaklaşımdır. Genellikle JSON formatında veri iletimi kullanılır.",
            "content": "## REST API\n\nREST, stateless bir mimaridir.\n\nKaynaklar URL üzerinden erişilir.\n\nMobil uygulamalar backend servislerle genellikle REST API üzerinden haberleşir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Stateless mimari kullanır",
              "HTTP protokolü üzerinden çalışır",
              "JSON en yaygın veri formatıdır",
              "Mobil-backend iletişimin temelidir"
            ],
            "questions": []
          },
          {
            "topicId": 3502,
            "title": "Retrofit",
            "summary": "Retrofit, Android ve Java/Kotlin projelerinde REST API çağrılarını kolay ve güvenli şekilde yapmayı sağlayan popüler bir networking kütüphanesidir.",
            "content": "## Retrofit\n\nInterface tabanlı çalışır.\n\nHTTP isteklerini annotation'lar ile tanımlar.\n\nOkHttp üzerine kuruludur.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Retrofit Interface",
                "code": "interface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List<User>\n}",
                "explanation": "Basit bir Retrofit API tanımı."
              }
            ],
            "keyPoints": [
              "Interface tabanlıdır",
              "Coroutine ve RxJava desteği vardır",
              "OkHttp ile birlikte çalışır",
              "API çağrılarını sadeleştirir"
            ],
            "questions": []
          },
          {
            "topicId": 3503,
            "title": "HTTP İstek Türleri",
            "summary": "HTTP istek türleri, istemcinin sunucuya ne tür bir işlem yapmak istediğini belirtir. En yaygın olanları GET, POST, PUT ve DELETE'tir.",
            "content": "## HTTP İstek Türleri\n\nGET: Veri almak\nPOST: Veri göndermek\nPUT: Veri güncellemek\nDELETE: Veri silmek",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "POST İsteği",
                "code": "@POST(\"users\")\nsuspend fun createUser(@Body user: User): Response<User>",
                "explanation": "Retrofit ile POST isteği örneği."
              }
            ],
            "keyPoints": [
              "GET veri almak için kullanılır",
              "POST veri ekler",
              "PUT veri günceller",
              "DELETE veri siler"
            ],
            "questions": []
          },
          {
            "topicId": 3504,
            "title": "JSON Parsing",
            "summary": "JSON Parsing, sunucudan gelen JSON formatındaki verinin Kotlin nesnelerine dönüştürülmesi işlemidir. Retrofit genellikle Gson veya Moshi ile birlikte kullanılır.",
            "content": "## JSON Parsing\n\nJSON, anahtar-değer yapısına sahiptir.\n\nModel class'lar ile parse edilir.\n\nOtomatik dönüşüm sağlar.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Data Class",
                "code": "data class User(\n    val id: Int,\n    val name: String\n)",
                "explanation": "JSON verisini temsil eden data class."
              }
            ],
            "keyPoints": [
              "JSON en yaygın veri formatıdır",
              "Data class ile eşleştirilir",
              "Gson / Moshi kullanılır",
              "Retrofit ile otomatik parse edilir"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": []
      },
      {
        "sectionId": 3600,
        "sectionTitle": "Firebase",
        "sectionDescription": "Google Firebase kullanarak backend ihtiyacı olmadan kimlik doğrulama, veritabanı, dosya depolama ve güvenlik yönetimi",
        "order": 6,
        "topics": [
          {
            "topicId": 3601,
            "title": "Authentication",
            "summary": "Firebase Authentication, kullanıcıların e-posta/şifre, Google, Facebook gibi yöntemlerle güvenli bir şekilde giriş yapmasını sağlayan kimlik doğrulama servisidir.",
            "content": "## Authentication\n\nKullanıcı yönetimini kolaylaştırır.\n\nHazır giriş yöntemleri sunar.\n\nBackend yazmaya gerek kalmaz.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Email ile Giriş",
                "code": "FirebaseAuth.getInstance()\n    .signInWithEmailAndPassword(email, password)",
                "explanation": "Firebase ile e-posta ve şifre kullanarak giriş işlemi."
              }
            ],
            "keyPoints": [
              "Hazır authentication altyapısı sunar",
              "Email, Google, Facebook desteği vardır",
              "Güvenli kullanıcı yönetimi sağlar",
              "Kolay entegrasyon sunar"
            ],
            "questions": []
          },
          {
            "topicId": 3602,
            "title": "Firestore",
            "summary": "Firestore, NoSQL tabanlı, gerçek zamanlı veri senkronizasyonu sağlayan bulut veritabanıdır. Koleksiyon ve doküman yapısı ile çalışır.",
            "content": "## Firestore\n\nNoSQL mimarisi kullanır.\n\nGerçek zamanlı veri güncellemeleri sunar.\n\nOffline desteklidir.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Veri Ekleme",
                "code": "FirebaseFirestore.getInstance()\n    .collection(\"users\")\n    .add(user)",
                "explanation": "Firestore'a veri ekleme örneği."
              }
            ],
            "keyPoints": [
              "NoSQL tabanlıdır",
              "Gerçek zamanlı çalışır",
              "Offline desteği vardır",
              "Koleksiyon-doküman yapısı kullanır"
            ],
            "questions": []
          },
          {
            "topicId": 3603,
            "title": "Storage",
            "summary": "Firebase Storage, kullanıcıların yüklediği görsel, video ve dosyaları güvenli bir şekilde saklamak için kullanılan bulut depolama servisidir.",
            "content": "## Storage\n\nDosya depolama için kullanılır.\n\nBüyük dosyalar için uygundur.\n\nAuthentication ile entegre çalışır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "Dosya Yükleme",
                "code": "FirebaseStorage.getInstance()\n    .reference\n    .child(\"images/photo.jpg\")\n    .putFile(uri)",
                "explanation": "Firebase Storage'a dosya yükleme."
              }
            ],
            "keyPoints": [
              "Dosya ve medya depolama sağlar",
              "Güvenli erişim sunar",
              "Authentication ile birlikte çalışır",
              "Yüksek ölçeklenebilirlik sunar"
            ],
            "questions": []
          },
          {
            "topicId": 3604,
            "title": "Security Rules",
            "summary": "Firebase Security Rules, Firestore ve Storage üzerinde kimlerin hangi verilere erişebileceğini tanımlamak için kullanılan güvenlik kurallarıdır.",
            "content": "## Security Rules\n\nYetkilendirme ve doğrulama sağlar.\n\nAuthentication bilgileri ile çalışır.\n\nVeri güvenliği için kritiktir.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Basit Firestore Kuralı",
                "code": "allow read, write: if request.auth != null;",
                "explanation": "Sadece giriş yapmış kullanıcıların erişmesine izin veren kural."
              }
            ],
            "keyPoints": [
              "Veri güvenliğini sağlar",
              "Authentication ile entegredir",
              "Yetkisiz erişimi engeller",
              "Prod ortamda mutlaka tanımlanmalıdır"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": []
      },
      {
        "sectionId": 3700,
        "sectionTitle": "Konum & Harita",
        "sectionDescription": "Android uygulamalarda kullanıcı konumunu almak, harita üzerinde göstermek ve rota işlemleri yapmak",
        "order": 7,
        "topics": [
          {
            "topicId": 3701,
            "title": "Google Maps",
            "summary": "Google Maps SDK, Android uygulamalarında harita gösterimi ve harita üzerinde etkileşimli işlemler yapılmasını sağlayan resmi Google servisidir.",
            "content": "## Google Maps\n\nGoogle Maps SDK kullanılarak harita uygulamaya entegre edilir.\n\nAPI Key gerektirir.\n\nMarker, kamera hareketleri ve rota çizimi desteklenir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Harita Hazırlama",
                "code": "override fun onMapReady(googleMap: GoogleMap) {\n    map = googleMap\n}",
                "explanation": "Google Maps hazır olduğunda çağrılan metot."
              }
            ],
            "keyPoints": [
              "Google Maps SDK kullanılır",
              "API Key zorunludur",
              "Harita etkileşimleri desteklenir",
              "Modern uygulamalarda yaygındır"
            ],
            "questions": []
          },
          {
            "topicId": 3702,
            "title": "Location Permission",
            "summary": "Android'de kullanıcı konumuna erişmek için runtime permission mekanizması kullanılır. Kullanıcının açık izni olmadan konum bilgisi alınamaz.",
            "content": "## Location Permission\n\nACCESS_FINE_LOCATION ve ACCESS_COARSE_LOCATION izinleri kullanılır.\n\nAndroid 6.0 sonrası runtime permission zorunludur.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Permission Kontrolü",
                "code": "if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)\n    != PackageManager.PERMISSION_GRANTED) {\n    requestPermissions(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), 100)\n}",
                "explanation": "Konum izni kontrolü ve isteme."
              }
            ],
            "keyPoints": [
              "Runtime permission zorunludur",
              "Kullanıcı onayı gerekir",
              "Fine ve Coarse location farkı vardır",
              "Yanlış kullanım crash'e yol açabilir"
            ],
            "questions": []
          },
          {
            "topicId": 3703,
            "title": "Marker",
            "summary": "Marker, Google Maps üzerinde belirli bir konumu işaretlemek için kullanılan görsel işaretleyicilerdir.",
            "content": "## Marker\n\nHarita üzerinde konum göstermek için kullanılır.\n\nBaşlık ve açıklama eklenebilir.",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "Marker Ekleme",
                "code": "val location = LatLng(41.0082, 28.9784)\nmap.addMarker(MarkerOptions().position(location).title(\"İstanbul\"))",
                "explanation": "Harita üzerine marker ekleme."
              }
            ],
            "keyPoints": [
              "Konum işaretlemek için kullanılır",
              "Başlık ve açıklama eklenebilir",
              "Kullanıcı etkileşimine açıktır",
              "Birden fazla marker eklenebilir"
            ],
            "questions": []
          },
          {
            "topicId": 3704,
            "title": "Route",
            "summary": "Route (rota), iki veya daha fazla nokta arasındaki yolun harita üzerinde çizilmesini ifade eder. Genellikle Directions API ile birlikte kullanılır.",
            "content": "## Route\n\nPolyline kullanılarak çizilir.\n\nDirections API ile rota bilgisi alınır.\n\nNavigasyon uygulamalarında yaygındır.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Polyline Çizimi",
                "code": "map.addPolyline(\n    PolylineOptions().add(startLatLng, endLatLng)\n)",
                "explanation": "İki nokta arasında rota çizimi."
              }
            ],
            "keyPoints": [
              "Polyline ile çizilir",
              "Directions API gerektirir",
              "Navigasyon uygulamalarında kullanılır",
              "Performans dikkat edilmelidir"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": []
      }
      ],
      "interviewQuestions": []
    },
    {
      "categoryId": 4,
      "categoryTitle": "Android İleri Seviye & Profesyonel",
      "categoryDescription": "Modern Android uygulamalarında performans, ölçeklenebilirlik ve profesyonel mimari kurmak için ileri seviye konular",
      "order": 4,
      "sections": [
        {
          "sectionId": 4100,
          "sectionTitle": "Coroutines & Asenkron Programlama",
          "sectionDescription": "Android uygulamalarda asenkron işlemleri güvenli, okunabilir ve performanslı şekilde yönetmek için Kotlin Coroutines kullanımı",
          "order": 1,
          "topics": [
            {
              "topicId": 4101,
              "title": "Asenkron Programlama Nedir",
              "summary": "Asenkron programlama, uzun süren işlemlerin (network, veritabanı vb.) ana thread'i bloklamadan arka planda çalıştırılmasını sağlar. Android'de UI performansı için kritik öneme sahiptir.",
              "content": "## Asenkron Programlama\n\nAndroid'de ana thread UI işlemlerini yürütür.\n\nUzun süren işlemler ANR hatasına yol açabilir.\n\nAsenkron yapı performans ve kullanıcı deneyimi sağlar.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "UI thread bloklanmamalıdır",
                "Network ve DB işlemleri arka planda çalışmalıdır",
                "Yanlış kullanım ANR hatasına sebep olur",
                "Asenkron yapı UX'i iyileştirir"
              ],
              "questions": []
            },
            {
              "topicId": 4102,
              "title": "Coroutine Nedir",
              "summary": "Coroutine, Kotlin tarafından sunulan hafif ve güçlü bir asenkron programlama çözümüdür. Callback ve Thread karmaşasını ortadan kaldırır.",
              "content": "## Coroutine\n\nCoroutine'ler lightweight yapılardır.\n\nThread yönetimini geliştiriciden alır.\n\nOkunabilir ve güvenli kod yazmayı sağlar.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Basit Coroutine",
                  "code": "GlobalScope.launch {\n    delay(1000)\n    println(\"Coroutine çalıştı\")\n}",
                  "explanation": "Basit bir coroutine başlatma örneği."
                }
              ],
              "keyPoints": [
                "Thread'e göre daha hafiftir",
                "Callback hell'i ortadan kaldırır",
                "Suspend fonksiyonlar kullanılır",
                "Modern Android'in temelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4103,
              "title": "Suspend Fonksiyonlar",
              "summary": "Suspend fonksiyonlar, coroutine içerisinde çalışabilen ve execution'ı askıya alabilen özel fonksiyonlardır.",
              "content": "## Suspend Fonksiyonlar\n\nSuspend fonksiyonlar coroutine context içinde çağrılır.\n\nThread bloklamaz.\n\nAsenkron işlemler için kullanılır.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Suspend Fonksiyon",
                  "code": "suspend fun fetchData() {\n    delay(1000)\n}",
                  "explanation": "Suspend fonksiyon örneği."
                }
              ],
              "keyPoints": [
                "Sadece coroutine içinde çağrılır",
                "Thread'i bloklamaz",
                "delay() gibi suspend fonksiyonlar içerir",
                "Asenkron yapının temelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4104,
              "title": "Coroutine Scope & Dispatcher",
              "summary": "Coroutine Scope, coroutine'in yaşam döngüsünü; Dispatcher ise hangi thread üzerinde çalışacağını belirler.",
              "content": "## Scope & Dispatcher\n\nScope lifecycle ile ilişkilidir.\n\nDispatcher thread yönetimini sağlar.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Dispatcher Kullanımı",
                  "code": "viewModelScope.launch(Dispatchers.IO) {\n    repository.getData()\n}",
                  "explanation": "IO dispatcher ile coroutine çalıştırma."
                }
              ],
              "keyPoints": [
                "viewModelScope lifecycle-aware'dır",
                "Dispatchers.IO: network & DB",
                "Dispatchers.Main: UI",
                "Yanlış dispatcher crash'e yol açabilir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4200,
          "sectionTitle": "Flow & StateFlow",
          "sectionDescription": "Kotlin Flow ile reaktif veri akışı yönetimi ve StateFlow kullanarak UI state yönetimi",
          "order": 2,
          "topics": [
            {
              "topicId": 4201,
              "title": "Flow Nedir",
              "summary": "Flow, Kotlin Coroutines tabanlı soğuk (cold) veri akışı sağlayan reaktif bir yapıdır. Zaman içerisinde birden fazla veri yayını yapabilir.",
              "content": "## Flow Nedir\n\nFlow, async data stream sağlar.\n\nCold stream'dir (collect edilmeden çalışmaz).\n\nCoroutine ile uyumludur.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Flow",
                  "code": "fun numbersFlow(): Flow<Int> = flow {\n    emit(1)\n    emit(2)\n    emit(3)\n}",
                  "explanation": "Basit bir Flow örneği."
                }
              ],
              "keyPoints": [
                "Cold stream'dir",
                "Coroutine tabanlıdır",
                "Birden fazla değer yayabilir",
                "Asenkron veri akışı sağlar"
              ],
              "questions": []
            },
            {
              "topicId": 4202,
              "title": "Flow Collect",
              "summary": "collect, Flow'dan gelen verileri dinlemek ve işlemek için kullanılan suspend fonksiyondur.",
              "content": "## Collect\n\nFlow collect edilmeden çalışmaz.\n\nSuspend fonksiyondur.\n\nCoroutine scope içinde çağrılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Flow Collect",
                  "code": "lifecycleScope.launch {\n    numbersFlow().collect {\n        println(it)\n    }\n}",
                  "explanation": "Flow collect örneği."
                }
              ],
              "keyPoints": [
                "Suspend fonksiyondur",
                "Coroutine scope gerektirir",
                "Flow başlatır",
                "UI lifecycle ile birlikte çalışır"
              ],
              "questions": []
            },
            {
              "topicId": 4203,
              "title": "StateFlow Nedir",
              "summary": "StateFlow, her zaman güncel bir state tutan ve yeni observer'lara son değeri anında ileten sıcak (hot) bir Flow türüdür.",
              "content": "## StateFlow\n\nHot stream'dir.\n\nHer zaman bir initial değeri vardır.\n\nUI state yönetimi için idealdir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "StateFlow Tanımı",
                  "code": "private val _uiState = MutableStateFlow(0)\nval uiState: StateFlow<Int> = _uiState",
                  "explanation": "StateFlow tanımlama."
                }
              ],
              "keyPoints": [
                "Hot stream'dir",
                "Initial value zorunludur",
                "Son değeri saklar",
                "UI state için kullanılır"
              ],
              "questions": []
            },
            {
              "topicId": 4204,
              "title": "Flow vs LiveData",
              "summary": "Flow ve LiveData benzer amaçlara hizmet etse de Flow daha esnek ve güçlüdür. Modern Android geliştirmede Flow tercih edilir.",
              "content": "## Flow vs LiveData\n\nFlow coroutine tabanlıdır.\n\nLiveData lifecycle-aware'dır.\n\nStateFlow lifecycle bağımsızdır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Flow daha esnektir",
                "LiveData XML uyumludur",
                "StateFlow lifecycle'dan bağımsızdır",
                "Modern projelerde Flow önerilir"
              ],
              "questions": []
            },
            {
              "topicId": 4205,
              "title": "ViewModel + StateFlow Kullanımı",
              "summary": "StateFlow genellikle ViewModel içinde tanımlanır ve UI tarafından observe edilir.",
              "content": "## ViewModel + StateFlow\n\nUI state ViewModel'de tutulur.\n\nLifecycle ile collect edilir.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "StateFlow Observe",
                  "code": "lifecycleScope.launch {\n    viewModel.uiState.collect {\n        textView.text = it.toString()\n    }\n}",
                  "explanation": "UI tarafında StateFlow collect edilmesi."
                }
              ],
              "keyPoints": [
                "StateFlow ViewModel'de tutulur",
                "UI sadece observe eder",
                "Tek yönlü data flow sağlar",
                "MVVM ile uyumludur"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4300,
          "sectionTitle": "Dependency Injection (Hilt)",
          "sectionDescription": "Bağımlılıkları merkezi ve yönetilebilir şekilde sağlamak için kullanılan Hilt tabanlı Dependency Injection yapısı",
          "order": 3,
          "topics": [
            {
              "topicId": 4301,
              "title": "Dependency Injection Nedir",
              "summary": "Dependency Injection (DI), bir sınıfın ihtiyaç duyduğu bağımlılıkları kendisinin oluşturması yerine dışarıdan almasını sağlayan tasarım desenidir.",
              "content": "## Dependency Injection Nedir\n\nDI, sıkı bağımlılıkları azaltır.\n\nKodun test edilebilirliğini artırır.\n\nBakımı ve ölçeklenebilirliği kolaylaştırır.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Sıkı bağımlılığı azaltır",
                "Test yazımını kolaylaştırır",
                "Kod tekrarını önler",
                "Clean Architecture için gereklidir"
              ],
              "questions": []
            },
            {
              "topicId": 4302,
              "title": "Hilt Nedir",
              "summary": "Hilt, Android için geliştirilmiş, Dagger üzerine kurulu resmi Dependency Injection kütüphanesidir.",
              "content": "## Hilt Nedir\n\nGoogle tarafından önerilir.\n\nAndroid bileşenleriyle entegredir.\n\nBoilerplate kodu azaltır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Hilt Kurulumu",
                  "code": "@HiltAndroidApp\nclass MyApplication : Application()",
                  "explanation": "Application seviyesinde Hilt başlatma."
                }
              ],
              "keyPoints": [
                "Dagger tabanlıdır",
                "Android'e özeldir",
                "Otomatik lifecycle yönetimi sağlar",
                "Resmi DI çözümüdür"
              ],
              "questions": []
            },
            {
              "topicId": 4303,
              "title": "Hilt Modülleri",
              "summary": "Hilt modülleri, bağımlılıkların nasıl oluşturulacağını tanımlayan sınıflardır.",
              "content": "## Hilt Modülleri\n\n@Module anotasyonu ile tanımlanır.\n\n@Provides veya @Binds kullanılır.\n\nSingleton gibi scope'lar desteklenir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Hilt Module Örneği",
                  "code": "@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n    @Provides\n    fun provideApi(): ApiService {\n        return ApiService.create()\n    }\n}",
                  "explanation": "Basit bir Hilt modül tanımı."
                }
              ],
              "keyPoints": [
                "Bağımlılık tanımı yapılır",
                "Singleton scope desteklenir",
                "Merkezi yapı sağlar",
                "Test için mock edilebilir"
              ],
              "questions": []
            },
            {
              "topicId": 4304,
              "title": "Hilt ile ViewModel Kullanımı",
              "summary": "Hilt, ViewModel bağımlılıklarını otomatik olarak sağlayarak constructor injection kullanımını mümkün kılar.",
              "content": "## ViewModel + Hilt\n\nConstructor injection desteklenir.\n\n@HiltViewModel anotasyonu kullanılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Hilt ViewModel",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel()",
                  "explanation": "Hilt ile ViewModel injection."
                }
              ],
              "keyPoints": [
                "Constructor injection kullanılır",
                "ViewModel daha test edilebilir olur",
                "Boilerplate azalır",
                "MVVM ile tam uyumludur"
              ],
              "questions": []
            },
            {
              "topicId": 4305,
              "title": "Hilt Scope'ları",
              "summary": "Hilt scope'ları, bağımlılıkların yaşam döngüsünü belirlemek için kullanılır.",
              "content": "## Hilt Scope\n\n@Singleton\n\n@ActivityScoped\n\n@ViewModelScoped gibi scope'lar vardır.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Lifecycle bazlı yönetim sağlar",
                "Bellek kullanımını optimize eder",
                "Yanlış instance oluşumunu önler",
                "Performansı artırır"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4400,
          "sectionTitle": "Clean Architecture",
          "sectionDescription": "Uygulamanın katmanlara ayrılarak daha sürdürülebilir, test edilebilir ve ölçeklenebilir hale getirilmesini sağlayan mimari yaklaşım",
          "order": 4,
          "topics": [
            {
              "topicId": 4401,
              "title": "Clean Architecture Nedir",
              "summary": "Clean Architecture, uygulamayı katmanlara ayırarak bağımlılıkların tek yönlü olmasını sağlayan bir mimari yaklaşımdır.",
              "content": "## Clean Architecture Nedir\n\nBu mimari, iş kurallarını framework ve UI bağımlılıklarından ayırır.\n\nMerkezde domain katmanı bulunur.\n\nDış katmanlar iç katmanlara bağımlıdır, tersi mümkün değildir.",
              "difficulty": "hard",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Katmanlı yapı sunar",
                "Bağımlılıklar tek yönlüdür",
                "İş mantığı UI'dan bağımsızdır",
                "Test yazımı kolaylaşır"
              ],
              "questions": []
            },
            {
              "topicId": 4402,
              "title": "Katmanlar (Presentation, Domain, Data)",
              "summary": "Clean Architecture, uygulamayı üç ana katmana ayırır: Presentation, Domain ve Data.",
              "content": "## Clean Architecture Katmanları\n\n- Presentation: UI ve ViewModel\n- Domain: UseCase ve Entity\n- Data: Repository ve veri kaynakları\n\nHer katmanın sorumluluğu nettir.",
              "difficulty": "hard",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "Presentation UI logic içerir",
                "Domain saf Kotlin'dir",
                "Data veri kaynaklarını yönetir",
                "Katmanlar arası bağımlılık sınırlandırılmıştır"
              ],
              "questions": []
            },
            {
              "topicId": 4403,
              "title": "Domain Katmanı",
              "summary": "Domain katmanı, uygulamanın iş kurallarını ve UseCase yapılarını içerir.",
              "content": "## Domain Katmanı\n\nFramework bağımlılığı yoktur.\n\nSaf Kotlin kodu içerir.\n\nUygulamanın kalbidir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "UseCase Örneği",
                  "code": "class GetUsersUseCase(private val repository: UserRepository) {\n    suspend operator fun invoke() = repository.getUsers()\n}",
                  "explanation": "Domain katmanında bir UseCase örneği."
                }
              ],
              "keyPoints": [
                "Framework bağımsızdır",
                "Business logic burada yer alır",
                "Test edilmesi çok kolaydır",
                "Uzun vadede stabil yapı sağlar"
              ],
              "questions": []
            },
            {
              "topicId": 4404,
              "title": "Data Katmanı",
              "summary": "Data katmanı, veri kaynaklarını (API, Room, Cache) yöneten katmandır.",
              "content": "## Data Katmanı\n\nRepository implementasyonları burada bulunur.\n\nRemote ve local data source'lar ayrılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Repository Implementasyonu",
                  "code": "class UserRepositoryImpl(\n    private val api: ApiService\n) : UserRepository {\n    override suspend fun getUsers() = api.getUsers()\n}",
                  "explanation": "Data katmanında repository implementasyonu."
                }
              ],
              "keyPoints": [
                "Veri kaynaklarını soyutlar",
                "API ve Room ayrımı yapılır",
                "Domain ile interface üzerinden konuşur",
                "Mocklama kolaydır"
              ],
              "questions": []
            },
            {
              "topicId": 4405,
              "title": "Presentation Katmanı",
              "summary": "Presentation katmanı, UI ve kullanıcı etkileşimlerini yöneten katmandır.",
              "content": "## Presentation Katmanı\n\nActivity, Fragment ve ViewModel içerir.\n\nSadece UI logic bulunur.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [
                {
                  "title": "ViewModel + UseCase",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val getUsersUseCase: GetUsersUseCase\n) : ViewModel()",
                  "explanation": "Presentation katmanında ViewModel örneği."
                }
              ],
              "keyPoints": [
                "UI ile sınırlıdır",
                "Business logic içermez",
                "UseCase kullanır",
                "MVVM ile birlikte çalışır"
              ],
              "questions": []
            },
            {
              "topicId": 4406,
              "title": "Clean Architecture + MVVM",
              "summary": "Clean Architecture, MVVM ile birlikte kullanıldığında güçlü ve sürdürülebilir bir yapı ortaya çıkar.",
              "content": "## Clean Architecture + MVVM\n\nMVVM, Presentation katmanında kullanılır.\n\nUseCase'ler ViewModel tarafından çağrılır.",
              "difficulty": "hard",
              "order": 6,
              "codeExamples": [],
              "keyPoints": [
                "Modern Android için ideal yapı",
                "Test edilebilirlik maksimumdur",
                "Büyük projelerde tercih edilir",
                "Senior seviye mimaridir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4500,
          "sectionTitle": "Coroutines",
          "sectionDescription": "Asenkron işlemleri daha okunabilir, güvenli ve performanslı şekilde yönetmek için kullanılan Kotlin Coroutine yapısı",
          "order": 5,
          "topics": [
            {
              "topicId": 4501,
              "title": "Coroutines Nedir",
              "summary": "Coroutines, uzun süren işlemleri (network, database vb.) ana thread'i bloklamadan çalıştırmayı sağlayan Kotlin'in asenkron programlama çözümüdür.",
              "content": "## Coroutines Nedir\n\nCoroutines, callback ve RxJava gibi yapılara modern bir alternatiftir.\n\nKodun senkron gibi okunmasını sağlar ancak asenkron çalışır.\n\nAndroid'de performans ve kullanıcı deneyimi için kritik öneme sahiptir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Asenkron işlemleri basitleştirir",
                "Callback hell sorununu çözer",
                "Okunabilir kod yapısı sağlar",
                "Android tarafından resmi olarak desteklenir"
              ],
              "questions": []
            },
            {
              "topicId": 4502,
              "title": "CoroutineScope ve Lifecycle",
              "summary": "CoroutineScope, coroutine'lerin hangi yaşam döngüsüne bağlı çalışacağını belirler.",
              "content": "## CoroutineScope\n\nAndroid'de en sık kullanılan scope'lar:\n\n- viewModelScope\n- lifecycleScope\n- GlobalScope (önerilmez)\n\nLifecycle-aware scope'lar memory leak riskini azaltır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "viewModelScope Kullanımı",
                  "code": "viewModelScope.launch {\n    val users = repository.getUsers()\n}",
                  "explanation": "ViewModel yok edildiğinde coroutine otomatik iptal edilir."
                }
              ],
              "keyPoints": [
                "Lifecycle'a duyarlı çalışır",
                "Memory leak riskini azaltır",
                "GlobalScope önerilmez",
                "UI güvenliğini artırır"
              ],
              "questions": []
            },
            {
              "topicId": 4503,
              "title": "Dispatchers",
              "summary": "Dispatchers, coroutine'in hangi thread üzerinde çalışacağını belirler.",
              "content": "## Dispatchers\n\n- Dispatchers.Main → UI işlemleri\n- Dispatchers.IO → Network / Database\n- Dispatchers.Default → CPU yoğun işlemler\n\nYanlış dispatcher kullanımı performans sorunlarına yol açar.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Dispatcher Kullanımı",
                  "code": "withContext(Dispatchers.IO) {\n    dao.getAllUsers()\n}",
                  "explanation": "IO işlemleri ana thread dışında çalıştırılır."
                }
              ],
              "keyPoints": [
                "Thread yönetimini kolaylaştırır",
                "UI thread bloklanmaz",
                "Doğru dispatcher performansı artırır",
                "Yanlış kullanım ANR'a sebep olabilir"
              ],
              "questions": []
            },
            {
              "topicId": 4504,
              "title": "launch ve async",
              "summary": "launch ve async, coroutine başlatmak için kullanılan iki temel builder'dır.",
              "content": "## launch vs async\n\n- launch → Sonuç dönmez\n- async → Deferred<T> döner\n\nasync genellikle paralel işlemler için kullanılır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "async / await",
                  "code": "val result = async { api.getData() }\nresult.await()",
                  "explanation": "async sonucu await ile alınır."
                }
              ],
              "keyPoints": [
                "launch fire-and-forget",
                "async sonuç döner",
                "await ile senkron bekleme yapılır",
                "Yanlış kullanım memory leak doğurabilir"
              ],
              "questions": []
            },
            {
              "topicId": 4505,
              "title": "Exception Handling",
              "summary": "Coroutine'lerde hata yönetimi structured concurrency prensibine göre yapılır.",
              "content": "## Coroutine Exception Handling\n\ntry-catch ve CoroutineExceptionHandler kullanılır.\n\nSupervisorJob ile child coroutine hataları izole edilebilir.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "try-catch Kullanımı",
                  "code": "viewModelScope.launch {\n    try {\n        api.getData()\n    } catch (e: Exception) {\n        // hata yönetimi\n    }\n}",
                  "explanation": "Coroutine içinde hata yakalama."
                }
              ],
              "keyPoints": [
                "Structured concurrency önemlidir",
                "Hatalar scope'a yayılabilir",
                "SupervisorJob izolasyon sağlar",
                "Doğru hata yönetimi crash'i önler"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4600,
          "sectionTitle": "Testing",
          "sectionDescription": "Android uygulamalarda hataları erken yakalamak, sürdürülebilir ve güvenilir kod yazmak için kullanılan test yaklaşımları",
          "order": 6,
          "topics": [
            {
              "topicId": 4601,
              "title": "Testing Nedir ve Neden Önemlidir",
              "summary": "Testing, yazılan kodun beklenen şekilde çalışıp çalışmadığını doğrulamak için yapılan kontrollü test süreçleridir. Hataları erken yakalamayı ve kod kalitesini artırmayı sağlar.",
              "content": "## Testing Nedir\n\nTest yazmak, uygulamanın davranışlarını otomatik olarak kontrol etmeyi sağlar.\n\nBüyük projelerde regresyon hatalarını önler.\n\nProfesyonel yazılım geliştirme süreçlerinin vazgeçilmezidir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Hataları erken yakalar",
                "Kod kalitesini artırır",
                "Refactor sürecini güvenli hale getirir",
                "Profesyonel projelerde zorunludur"
              ],
              "questions": []
            },
            {
              "topicId": 4602,
              "title": "Unit Test",
              "summary": "Unit Test, uygulamadaki en küçük test edilebilir birimlerin (fonksiyon, ViewModel vb.) izole şekilde test edilmesini sağlar.",
              "content": "## Unit Test\n\nAndroid'de genellikle ViewModel ve business logic test edilir.\n\nJUnit ve Mockito sık kullanılan araçlardır.\n\nUI'dan bağımsız çalışır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "ViewModel Unit Test",
                  "code": "@Test\nfun counter_increases_correctly() {\n    val vm = MainViewModel()\n    vm.increase()\n    assertEquals(1, vm.counter.value)\n}",
                  "explanation": "ViewModel fonksiyonunun doğru çalıştığını test eder."
                }
              ],
              "keyPoints": [
                "UI bağımsız test edilir",
                "Hızlı çalışır",
                "ViewModel için idealdir",
                "Regression hatalarını önler"
              ],
              "questions": []
            },
            {
              "topicId": 4603,
              "title": "Mocking (Mockito)",
              "summary": "Mocking, gerçek bağımlılıkların yerine sahte (mock) nesneler kullanarak test yazmayı sağlar.",
              "content": "## Mocking\n\nRepository, API veya database bağımlılıkları mock'lanır.\n\nTest izolasyonu sağlar.\n\nMockito Android'de sık kullanılır.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Mockito Kullanımı",
                  "code": "val repo = mock(UserRepository::class.java)\n`when`(repo.getUsers()).thenReturn(listOf())",
                  "explanation": "Repository davranışı taklit edilir."
                }
              ],
              "keyPoints": [
                "Bağımlılıkları izole eder",
                "Test senaryolarını kontrol etmeyi sağlar",
                "Gerçek API çağrısı yapılmaz",
                "Test stabilitesini artırır"
              ],
              "questions": []
            },
            {
              "topicId": 4604,
              "title": "UI Test (Espresso)",
              "summary": "UI Test, uygulamanın kullanıcı arayüzünün doğru çalışıp çalışmadığını otomatik olarak test etmeyi sağlar.",
              "content": "## UI Test\n\nEspresso Android'in resmi UI test aracıdır.\n\nKullanıcı etkileşimlerini simüle eder.\n\nGerçek cihaz veya emülatör üzerinde çalışır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Espresso Örneği",
                  "code": "onView(withId(R.id.button)).perform(click())",
                  "explanation": "Butona tıklama işlemi test edilir."
                }
              ],
              "keyPoints": [
                "Gerçek kullanıcı davranışını test eder",
                "UI hatalarını yakalar",
                "Yavaş çalışır ama etkilidir",
                "Release öncesi kritik öneme sahiptir"
              ],
              "questions": []
            },
            {
              "topicId": 4605,
              "title": "Test Pyramid",
              "summary": "Test Pyramid, test stratejisinde hangi test türüne ne kadar ağırlık verilmesi gerektiğini tanımlar.",
              "content": "## Test Pyramid\n\n- Unit Test → Çok\n- Integration Test → Orta\n- UI Test → Az\n\nBu yapı test maliyetini optimize eder.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Unit test ağırlıklı olmalı",
                "UI test sayısı sınırlı tutulmalı",
                "Bakım maliyetini düşürür",
                "Doğru test stratejisi sağlar"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4700,
          "sectionTitle": "Performance & Memory Management",
          "sectionDescription": "Android uygulamalarda performans sorunlarını tespit etmek, bellek yönetimini doğru yapmak ve ANR/crash risklerini azaltmak",
          "order": 7,
          "topics": [
            {
              "topicId": 4701,
              "title": "Performance Nedir",
              "summary": "Performance, bir Android uygulamasının hızlı, akıcı ve kaynakları verimli kullanarak çalışmasıdır. Kötü performans kullanıcı kaybına yol açar.",
              "content": "## Performance\n\nAndroid'de performans; CPU, memory, disk ve network kullanımına bağlıdır.\n\nAkıcı UI için ana thread'in bloklanmaması gerekir.\n\nGoogle Play puanlamasını doğrudan etkiler.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Akıcı UI kullanıcı deneyimini artırır",
                "Ana thread bloklanmamalıdır",
                "Performans doğrudan Play Store puanını etkiler",
                "Profiling ile ölçülmelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4702,
              "title": "ANR (Application Not Responding)",
              "summary": "ANR, ana thread uzun süre bloklandığında Android tarafından uygulamanın durdurulmasıdır.",
              "content": "## ANR\n\nGenellikle network, database veya heavy işlem ana thread'de yapıldığında oluşur.\n\n5 saniyeden uzun UI bloklanması ANR sebebidir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Yanlış Kullanım",
                  "code": "Thread.sleep(6000)",
                  "explanation": "Ana thread'de bekleme ANR oluşturur."
                }
              ],
              "keyPoints": [
                "Ana thread bloklanmamalı",
                "Uzun işlemler background thread'e taşınmalı",
                "Coroutines / WorkManager kullanılmalı",
                "ANR Play Console'da raporlanır"
              ],
              "questions": []
            },
            {
              "topicId": 4703,
              "title": "Memory Leak",
              "summary": "Memory leak, artık kullanılmayan nesnelerin bellekten temizlenmemesi durumudur ve uygulamanın yavaşlamasına veya çökmesine neden olur.",
              "content": "## Memory Leak\n\nEn sık nedenler:\n\n- Static Activity referansı\n- Yanlış Context kullanımı\n- Lifecycle'a bağlı olmayan observer'lar",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Yanlış Context Kullanımı",
                  "code": "object Manager {\n    lateinit var context: Context\n}",
                  "explanation": "Activity context'i tutulursa leak oluşur."
                }
              ],
              "keyPoints": [
                "Context dikkatli kullanılmalı",
                "Lifecycle-aware bileşenler tercih edilmeli",
                "LeakCanary ile tespit edilebilir",
                "Static referanslardan kaçınılmalı"
              ],
              "questions": []
            },
            {
              "topicId": 4704,
              "title": "Garbage Collection",
              "summary": "Garbage Collector, kullanılmayan nesneleri bellekten otomatik olarak temizleyen mekanizmadır.",
              "content": "## Garbage Collection\n\nSık GC çalışması performans düşüşüne neden olur.\n\nAşırı nesne oluşturmak GC baskısı yaratır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Aşırı nesne üretiminden kaçınılmalı",
                "Reusable objeler tercih edilmeli",
                "GC UI thread'i etkileyebilir",
                "Profiling ile izlenmelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4705,
              "title": "Android Profiler",
              "summary": "Android Profiler, CPU, memory ve network kullanımını analiz etmek için kullanılan resmi Android Studio aracıdır.",
              "content": "## Android Profiler\n\nGerçek zamanlı performans ölçümü sağlar.\n\nMemory leak ve ANR analizinde kullanılır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "CPU, Memory, Network analiz edilir",
                "Gerçek cihazda ölçüm önerilir",
                "Bottleneck tespiti yapılır",
                "Performans iyileştirme için şarttır"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4800,
          "sectionTitle": "Modularization (Multi-Module Android)",
          "sectionDescription": "Büyük Android projelerinde kodun yönetilebilirliğini, test edilebilirliğini ve build performansını artırmak için kullanılan çok modüllü mimari yaklaşımı",
          "order": 8,
          "topics": [
            {
              "topicId": 4801,
              "title": "Modularization Nedir",
              "summary": "Modularization, bir Android uygulamasını bağımsız ve yeniden kullanılabilir modüllere bölme yaklaşımıdır. Büyük projelerde karmaşıklığı azaltır.",
              "content": "## Modularization Nedir\n\nUygulama tek bir module yerine birden fazla module ayrılır.\n\nHer modül belirli bir sorumluluğa sahiptir.\n\nTakım çalışmasını ve ölçeklenebilirliği artırır.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Kod karmaşıklığını azaltır",
                "Takım çalışmasını kolaylaştırır",
                "Bağımlılık yönetimini iyileştirir",
                "Büyük projeler için idealdir"
              ],
              "questions": []
            },
            {
              "topicId": 4802,
              "title": "Module Türleri",
              "summary": "Android projelerinde farklı amaçlara hizmet eden çeşitli modül türleri bulunur.",
              "content": "## Module Türleri\n\n- App Module\n- Library Module\n- Feature Module (Dynamic Feature)\n\nHer modül farklı sorumluluklar üstlenir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "App module uygulamanın giriş noktasıdır",
                "Library module yeniden kullanılabilir kod içerir",
                "Feature module opsiyonel özellikler sunar",
                "Dynamic Feature ile indirme boyutu küçülür"
              ],
              "questions": []
            },
            {
              "topicId": 4803,
              "title": "Gradle Module Yapısı",
              "summary": "Multi-module projelerde Gradle, modüller arası bağımlılıkları ve build sürecini yönetir.",
              "content": "## Gradle Module Yapısı\n\nsettings.gradle dosyası modülleri tanımlar.\n\nModüller arası bağımlılıklar implementation(project()) ile eklenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Module Bağımlılığı",
                  "code": "implementation(project(\":core\"))",
                  "explanation": "core modülünü app modülüne dahil eder."
                }
              ],
              "keyPoints": [
                "Modüller arası bağımlılık açıkça tanımlanır",
                "Yanlış bağımlılık circular dependency oluşturabilir",
                "Build süresi optimize edilir",
                "Gradle yapılandırması kritik öneme sahiptir"
              ],
              "questions": []
            },
            {
              "topicId": 4804,
              "title": "Clean Architecture ile Modularization",
              "summary": "Clean Architecture, modüller arası bağımlılıkların tek yönlü olmasını sağlar ve kodun test edilebilirliğini artırır.",
              "content": "## Clean Architecture & Modules\n\nGenellikle şu yapı kullanılır:\n\n- data\n- domain\n- ui\n\nDomain katmanı hiçbir Android bağımlılığı içermez.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Bağımlılıklar içe doğru olmalıdır",
                "Domain katmanı saf Kotlin içerir",
                "Test yazımı kolaylaşır",
                "Uzun vadeli sürdürülebilirlik sağlar"
              ],
              "questions": []
            },
            {
              "topicId": 4805,
              "title": "Modularization Avantajları ve Dezavantajları",
              "summary": "Multi-module mimari birçok avantaj sunsa da yanlış kullanımda karmaşıklık yaratabilir.",
              "content": "## Avantajlar & Dezavantajlar\n\nAvantajlar:\n- Daha hızlı build\n- Daha temiz kod\n\nDezavantajlar:\n- İlk kurulum karmaşıktır\n- Küçük projeler için gereksiz olabilir",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Büyük projelerde ciddi fayda sağlar",
                "Küçük projelerde overengineering olabilir",
                "Doğru planlama şarttır",
                "Senior seviye mimari bilgisidir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        }
      ]
    }
  ]
}

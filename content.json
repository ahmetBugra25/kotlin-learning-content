{
  "version": "1.0.0",
  "lastUpdate": "2025-01-06T10:00:00Z",
  "categories": [
    {
      "categoryId": 1,
      "categoryTitle": "Kotlin Programlama Dili",
      "categoryDescription": "Kotlin dilinin temel ve ileri seviye özellikleri",
      "order": 1,
      "sections": [
        {
        "sectionId": 101,
        "sectionTitle": "Kotlin'e Giriş",
        "sectionDescription": "Bu bölümde Kotlin programlama dilinin ne olduğu ve hangi alanlarda kullanıldığı hakkında temel bilgiler verilmektedir.",
        "order": 1,
        "topics": [
            {
            "topicId": 1001,
            "title": "Kotlin Nedir",
            "summary": "Kotlin, JetBrains tarafından geliştirilen, modern, güvenli ve okunabilirliği yüksek bir programlama dilidir. JVM üzerinde çalışır ve Java ile %100 uyumludur. Null safety, kısa söz dizimi ve fonksiyonel programlama desteği sayesinde hataları azaltır ve geliştirme sürecini hızlandırır. Günümüzde Android uygulama geliştirmenin resmi dili olarak kabul edilmektedir.",
            "content": "## Kotlin Nedir?\n\nKotlin, JetBrains tarafından geliştirilmiş modern bir programlama dilidir.\n\n- Java ile %100 uyumludur\n- Null safety ile hataları azaltır\n- Daha az kod ile daha fazla iş yapılmasını sağlar\n\nAndroid geliştirme başta olmak üzere backend, web ve multiplatform projelerde kullanılır.",
            "difficulty": "easy",
            "order": 1,
            "codeExamples": [
                {
                "title": "Basit Kotlin Kodu",
                "code": "fun main() {\n    println(\"Hello Kotlin\")\n}",
                "explanation": "Kotlin'de ana fonksiyon fun anahtar kelimesi ile tanımlanır ve println ile konsola çıktı verilir."
                }
            ],
            "keyPoints": [
                "JetBrains tarafından geliştirilmiştir",
                "Java ile %100 uyumludur",
                "Null safety özelliği vardır",
                "Android'in resmi dilidir"
            ],
            "questions": []
            },
            {
            "topicId": 1002,
            "title": "Kotlin Nerelerde Kullanılır",
            "summary": "Kotlin, başta Android mobil uygulama geliştirme olmak üzere birçok alanda kullanılır. Backend tarafında (Spring Boot, Ktor), masaüstü uygulamalarda, web geliştirmede (Kotlin/JS) ve çoklu platform projelerinde (Kotlin Multiplatform) tercih edilir. Java ile uyumlu olması sayesinde mevcut Java projelerine kolayca entegre edilebilir.",
            "content": "",
            "difficulty": "easy",
            "order": 2,
            "codeExamples": [],
            "keyPoints": [
                "Android uygulama geliştirme",
                "Backend (Spring Boot, Ktor)",
                "Web (Kotlin/JS)",
                "Multiplatform projeler",
                "Mevcut Java projeleri"
            ],
            "questions": []
            }
        ],
        "sectionMixedQuestions": []
        },
        {
          "sectionId": 102,
          "sectionTitle": "Değişkenler ve Veri Tipleri",
          "sectionDescription": "",
          "order": 2,
          "topics": [
            {
            "topicId": 1101,
            "title": "var ve val",
            "summary": "Kotlin'de değişken tanımlamak için var ve val anahtar kelimeleri kullanılır. var ile tanımlanan değişkenlerin değeri sonradan değiştirilebilirken, val ile tanımlanan değişkenler yalnızca bir kez atanabilir. Güvenli ve okunabilir kod yazımı için mümkün olduğunca val kullanılması önerilir.",
            "content": "## var ve val\n\nKotlin'de değişken tanımlamak için iki temel anahtar kelime bulunur:\n\n- **val (value)**: Değeri sonradan değiştirilemeyen, immutable değişkenlerdir.\n- **var (variable)**: Değeri sonradan değiştirilebilen, mutable değişkenlerdir.\n\nKotlin'de best practice olarak, değişmeyecek değerler için **val**, gerçekten değişmesi gereken durumlarda **var** kullanılması önerilir. Bu yaklaşım hem kod güvenliğini artırır hem de hataları azaltır.\n\nÖnemli bir detay olarak; val ile tanımlanan bir referans değiştirilemez ancak eğer referans bir mutable nesne tutuyorsa, nesnenin içeriği değiştirilebilir.",
            "difficulty": "easy",
            "order": 1,
            "codeExamples": [
                {
                "title": "Temel var ve val Kullanımı",
                "code": "val name = \"Ahmet\"\nvar age = 25\n\nage = 26      // Geçerli\n// name = \"Mehmet\"  // HATA",
                "explanation": "val ile tanımlanan name değişkeni yeniden atanamaz. var ile tanımlanan age değişkeni ise güncellenebilir."
                },
                {
                "title": "val ve Mutable Nesne",
                "code": "val numbers = mutableListOf(1, 2, 3)\nnumbers.add(4)\n\nprintln(numbers)",
                "explanation": "numbers referansı val olsa bile, mutable bir liste tuttuğu için listenin içeriği değiştirilebilir."
                }
            ],
            "keyPoints": [
                "val değiştirilemez (immutable)",
                "var değiştirilebilir (mutable)",
                "Varsayılan olarak val tercih edilmelidir",
                "val referansı değişmez, içeriği mutable olabilir",
                "Daha güvenli ve okunabilir kod için val kullanımı önerilir"
            ],
            "questions": [
                {
                "questionId": 110101,
                "question": "Kotlin'de değeri sonradan değiştirilemeyen değişken hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "var",
                    "val",
                    "let",
                    "const"
                ],
                "correctAnswerIndex": 1,
                "explanation": "val anahtar kelimesi ile tanımlanan değişkenler immutable'dır ve bir kez atandıktan sonra değiştirilemez.",
                "tags": ["val", "var", "basics"]
                },
                {
                "questionId": 110102,
                "question": "Aşağıdakilerden hangisi var için doğrudur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "Bir kez atanır ve değiştirilemez",
                    "Sadece sınıf içinde kullanılır",
                    "Değeri sonradan değiştirilebilir",
                    "Sadece sabit değerler için kullanılır"
                ],
                "correctAnswerIndex": 2,
                "explanation": "var ile tanımlanan değişkenlerin değeri program çalışırken değiştirilebilir.",
                "tags": ["var", "basics"]
                },
                {
                "questionId": 110103,
                "question": "Aşağıdaki kodda hangi satır hata verir?",
                "questionType": "multiple_choice",
                "code": "val x = 10\nvar y = 20\nx = 15\ny = 25",
                "difficulty": "medium",
                "options": [
                    "Satır 1",
                    "Satır 2",
                    "Satır 3",
                    "Satır 4"
                ],
                "correctAnswerIndex": 2,
                "explanation": "x değişkeni val ile tanımlandığı için yeniden değer atanamaz. Bu nedenle Satır 3 compile-time hatası verir.",
                "tags": ["val", "compile-error"]
                },
                {
                "questionId": 110104,
                "question": "Aşağıdakilerden hangisi Kotlin best practice'lerine daha uygundur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Her zaman var kullanmak",
                    "Değişmeyecek değerler için val kullanmak",
                    "Sadece global değişkenlerde val kullanmak",
                    "val ve var arasında fark yoktur"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Değişmeyecek değerler için val kullanmak kod güvenliğini ve okunabilirliği artırır.",
                "tags": ["best-practice", "val"]
                },
                {
                "questionId": 110105,
                "question": "val ile tanımlanan mutable bir liste için aşağıdakilerden hangisi doğrudur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Listeye eleman eklenemez",
                    "Liste referansı değiştirilebilir",
                    "Listenin içeriği değiştirilebilir",
                    "Compile-time hatası oluşur"
                ],
                "correctAnswerIndex": 2,
                "explanation": "val referansı değiştirilemez ancak mutable bir nesne tutuyorsa, nesnenin içeriği değiştirilebilir.",
                "tags": ["val", "collections", "mutable"]
                }
            ]
            },
            {
            "topicId": 1102,
            "title": "Int ve Long",
            "summary": "Kotlin'de Int ve Long, tam sayı (integer) değerleri temsil eden veri tipleridir. Int 32-bit, Long ise 64-bit bellek alanı kullanır. Daha büyük sayılarla çalışılması gereken durumlarda Long tercih edilir. Kotlin'de sayı taşmalarını önlemek ve performansı korumak için uygun veri tipi seçilmelidir.",
            "content": "## Int ve Long\n\nKotlin'de tam sayılar için en sık kullanılan veri tipleri **Int** ve **Long**'dur.\n\n- **Int**: 32-bit signed tam sayı tipidir. -2,147,483,648 ile 2,147,483,647 arasında değer alabilir.\n- **Long**: 64-bit signed tam sayı tipidir. Çok daha büyük sayılarla çalışmak için kullanılır.\n\nKotlin'de sayısal sabitler varsayılan olarak **Int** kabul edilir. Bir sayının Long olduğunu belirtmek için sonuna **L** veya **l** eklenmelidir.\n\nDoğru veri tipini seçmek hem bellek kullanımı hem de uygulama performansı açısından önemlidir.",
            "difficulty": "easy",
            "order": 2,
            "codeExamples": [
                {
                "title": "Int ve Long Tanımlama",
                "code": "val age: Int = 25\nval distance: Long = 1_000_000L",
                "explanation": "Int 32-bit, Long 64-bit veri tipidir. Long değerlerde L takısı kullanılır."
                },
                {
                "title": "Varsayılan Int Davranışı",
                "code": "val number = 100\nval bigNumber = 10000000000L",
                "explanation": "Kotlin'de sayısal sabitler varsayılan olarak Int kabul edilir. Daha büyük değerler için Long kullanılır."
                }
            ],
            "keyPoints": [
                "Int 32-bit tam sayı tipidir",
                "Long 64-bit tam sayı tipidir",
                "Varsayılan tam sayı tipi Int'tir",
                "Long değerler L takısı ile belirtilir",
                "Büyük sayılar için Long tercih edilmelidir"
            ],
            "questions": [
                {
                "questionId": 110201,
                "question": "Kotlin'de varsayılan tam sayı veri tipi hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "Long",
                    "Short",
                    "Int",
                    "Byte"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Kotlin'de sayısal sabitler varsayılan olarak Int veri tipi kabul edilir.",
                "tags": ["int", "basics"]
                },
                {
                "questionId": 110202,
                "question": "Aşağıdakilerden hangisi Long tipinde bir değerdir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "100",
                    "5000",
                    "9999999999L",
                    "42"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Long değerler L takısı ile belirtilir.",
                "tags": ["long", "basics"]
                },
                {
                "questionId": 110203,
                "question": "Int veri tipinin maksimum değeri yaklaşık olarak hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "2 milyar",
                    "4 milyar",
                    "9 kentilyon",
                    "Sınırsız"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Int 32-bit olduğu için maksimum değeri yaklaşık 2.1 milyardır.",
                "tags": ["int", "range"]
                },
                {
                "questionId": 110204,
                "question": "Aşağıdaki kodlardan hangisi compile-time hatası verir?",
                "questionType": "multiple_choice",
                "code": "val number: Int = 10000000000",
                "difficulty": "medium",
                "options": [
                    "Kod hata vermez",
                    "Runtime hatası verir",
                    "Compile-time hatası verir",
                    "Long'a otomatik dönüşür"
                ],
                "correctAnswerIndex": 2,
                "explanation": "10000000000 Int aralığını aştığı için compile-time hatası oluşur.",
                "tags": ["int", "error"]
                },
                {
                "questionId": 110205,
                "question": "Aşağıdakilerden hangisi Int yerine Long kullanılmasını gerektirir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Kullanıcı yaşı",
                    "Ürün adedi",
                    "Dosya boyutu (byte)",
                    "Sınıf öğrenci sayısı"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Dosya boyutları çok büyük olabileceği için Long kullanımı daha uygundur.",
                "tags": ["long", "use-case"]
                }
            ]
            },
            {
              "topicId": 1103,
              "title": "Float ve Double",
              "summary": "Float ve Double, Kotlin'de ondalıklı (virgüllü) sayıları temsil eden veri tipleridir. Float 32-bit, Double ise 64-bit hassasiyete sahiptir. Kotlin'de ondalıklı sayılar varsayılan olarak Double kabul edilir. Daha yüksek hassasiyet gereken durumlarda Double tercih edilir.",
              "content": "## Float ve Double\n\nKotlin'de ondalıklı sayılarla çalışmak için **Float** ve **Double** veri tipleri kullanılır.\n\n- **Float**: 32-bit hassasiyete sahiptir. Daha az bellek kullanır ancak doğruluk düşüktür.\n- **Double**: 64-bit hassasiyete sahiptir. Daha yüksek doğruluk sunar ve Kotlin'de varsayılan ondalıklı sayı tipidir.\n\nFloat değerler tanımlanırken sonuna **F** veya **f** eklenmelidir. Aksi halde Kotlin bu değeri Double olarak kabul eder.\n\nFinansal hesaplamalar, ölçümler ve hassas sonuçlar gerektiren işlemlerde genellikle Double tercih edilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Float ve Double Tanımlama",
                  "code": "val piDouble: Double = 3.14159\nval piFloat: Float = 3.14F",
                  "explanation": "Float değerlerde F takısı zorunludur. Aksi halde değer Double kabul edilir."
                },
                {
                  "title": "Varsayılan Double Davranışı",
                  "code": "val number = 2.5\nval preciseNumber = 2.5F",
                  "explanation": "Ondalıklı sayılar varsayılan olarak Double tipindedir."
                }
              ],
              "keyPoints": [
                "Float 32-bit hassasiyete sahiptir",
                "Double 64-bit hassasiyete sahiptir",
                "Varsayılan ondalıklı sayı tipi Double'dır",
                "Float değerler F takısı ile belirtilir",
                "Hassas hesaplamalar için Double tercih edilir"
              ],
              "questions": [
                {
                  "questionId": 110301,
                  "question": "Kotlin'de varsayılan ondalıklı sayı veri tipi hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Float",
                    "Double",
                    "Int",
                    "Long"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de ondalıklı sayılar varsayılan olarak Double kabul edilir.",
                  "tags": ["double", "basics"]
                },
                {
                  "questionId": 110302,
                  "question": "Aşağıdakilerden hangisi Float tipinde bir değerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "3.14",
                    "2.5",
                    "1.0",
                    "3.14F"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Float değerler F veya f takısı ile belirtilir.",
                  "tags": ["float", "basics"]
                },
                {
                  "questionId": 110303,
                  "question": "Float ve Double arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Float daha hassastır",
                    "Double daha az bellek kullanır",
                    "Double daha yüksek hassasiyet sunar",
                    "Aralarında fark yoktur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Double 64-bit olduğu için Float'a göre daha yüksek hassasiyet sunar.",
                  "tags": ["precision", "comparison"]
                },
                {
                  "questionId": 110304,
                  "question": "Aşağıdaki kodlardan hangisi compile-time hatası verir?",
                  "questionType": "multiple_choice",
                  "code": "val value: Float = 2.5",
                  "difficulty": "medium",
                  "options": [
                    "Kod hata vermez",
                    "Runtime hatası verir",
                    "Compile-time hatası verir",
                    "Otomatik Float'a dönüşür"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "2.5 varsayılan olarak Double olduğu için Float'a atanamaz. F takısı gereklidir.",
                  "tags": ["float", "error"]
                },
                {
                  "questionId": 110305,
                  "question": "Aşağıdaki kullanım senaryolarından hangisinde Double tercih edilmelidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Ekran parlaklığı değeri",
                    "Sıcaklık ölçümü",
                    "Para hesaplamaları",
                    "Sayaç artışı"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Para ve hassas hesaplamalarda Double tercih edilir (daha doğrusu BigDecimal ama Float kullanılmamalıdır).",
                  "tags": ["double", "use-case"]
                }
              ]
            },
            {
              "topicId": 1104,
              "title": "String",
              "summary": "String, Kotlin'de metinsel ifadeleri temsil eden veri tipidir. Karakter dizilerinden oluşur ve immutable (değiştirilemez) yapıdadır. Kotlin'de String'ler güçlü fonksiyonlar, string interpolation ve çok satırlı yazım desteği sunar.",
              "content": "## String\n\nKotlin'de **String**, metin verilerini temsil eder ve **immutable** bir veri tipidir. Yani bir String oluşturulduktan sonra içeriği değiştirilemez.\n\nKotlin String'leri birçok hazır fonksiyon ile birlikte gelir. Ayrıca **string interpolation** sayesinde değişkenler doğrudan metin içinde kullanılabilir.\n\nKotlin'de String oluşturmanın iki temel yolu vardır:\n\n- Çift tırnak (\" \") ile tek satırlı String\n- Üç tırnak (\"\"\" \"\"\") ile çok satırlı String\n\nString işlemleri güvenli, okunabilir ve performanslı bir şekilde yapılabilir.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "String Tanımlama",
                  "code": "val name: String = \"Ahmet\"\nval city = \"Erzurum\"",
                  "explanation": "String değerler çift tırnak içinde tanımlanır. Kotlin type inference sayesinde türü otomatik belirler."
                },
                {
                  "title": "String Interpolation",
                  "code": "val age = 25\nval message = \"Yaşım $age\"\nval result = \"5 + 3 = ${5 + 3}\"",
                  "explanation": "$ işareti ile değişkenler, ${} ile ifadeler String içine gömülebilir."
                },
                {
                  "title": "Çok Satırlı String",
                  "code": "val text = \"\"\"\n    Kotlin öğreniyorum\n    Android geliştiriyorum\n\"\"\".trimIndent()",
                  "explanation": "Üç tırnak kullanılarak çok satırlı String tanımlanabilir."
                }
              ],
              "keyPoints": [
                "String immutable bir veri tipidir",
                "Metinsel veriler için kullanılır",
                "String interpolation desteklenir",
                "Çok satırlı String yazımı mümkündür",
                "Birçok hazır fonksiyon içerir (length, contains, substring)"
              ],
              "questions": [
                {
                  "questionId": 110401,
                  "question": "Kotlin'de String veri tipi hangi özelliğe sahiptir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Mutable",
                    "Immutable",
                    "Sadece okunur",
                    "Null olabilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de String immutable'dır, yani oluşturulduktan sonra değiştirilemez.",
                  "tags": ["string", "basics"]
                },
                {
                  "questionId": 110402,
                  "question": "String interpolation için hangi sembol kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "#",
                    "$",
                    "%",
                    "&"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de $ sembolü ile String interpolation yapılır.",
                  "tags": ["string", "interpolation"]
                },
                {
                  "questionId": 110403,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val name = \"Ali\"\nprintln(\"Merhaba $name\")",
                  "difficulty": "easy",
                  "options": [
                    "Merhaba name",
                    "Merhaba $name",
                    "Merhaba Ali",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "$name ifadesi String içine gömülür ve değeri yazdırılır.",
                  "tags": ["string", "output"]
                },
                {
                  "questionId": 110404,
                  "question": "Çok satırlı String tanımlamak için hangi yapı kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "\" \"",
                    "''' '''",
                    "\"\"\" \"\"\"",
                    "` `"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de üç tırnak (\"\"\" \"\"\") çok satırlı String tanımlamak için kullanılır.",
                  "tags": ["string", "multiline"]
                },
                {
                  "questionId": 110405,
                  "question": "Aşağıdakilerden hangisi String fonksiyonu değildir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "length",
                    "contains",
                    "substring",
                    "add"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "String sınıfında add() fonksiyonu yoktur.",
                  "tags": ["string", "functions"]
                }
              ]
            },
            {
              "topicId": 1105,
              "title": "Boolean",
              "summary": "Boolean, Kotlin'de mantıksal (doğru/yanlış) değerleri temsil eden veri tipidir. Sadece true veya false değerlerini alabilir ve genellikle koşul ifadelerinde, karşılaştırmalarda ve kontrol yapılarında kullanılır.",
              "content": "## Boolean\n\nKotlin'de **Boolean** veri tipi, mantıksal ifadeleri temsil eder ve yalnızca iki değer alabilir: **true** veya **false**.\n\nBoolean'lar genellikle **if**, **when**, **while** gibi kontrol yapılarında ve karşılaştırma işlemlerinde kullanılır. Ayrıca mantıksal operatörlerle (&&, ||, !) birlikte güçlü kontrol mekanizmaları sağlar.\n\nBoolean ifadeler, uygulamanın akışını kontrol etmek için temel yapı taşlarından biridir.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Boolean Tanımlama",
                  "code": "val isActive: Boolean = true\nval isAdmin = false",
                  "explanation": "Boolean değişkenler true veya false değerlerini alabilir."
                },
                {
                  "title": "Karşılaştırma Sonucu Boolean",
                  "code": "val age = 18\nval isAdult = age >= 18",
                  "explanation": "Karşılaştırma işlemleri Boolean sonuç döner."
                },
                {
                  "title": "Mantıksal Operatörler",
                  "code": "val hasAccount = true\nval isLoggedIn = false\n\nval canAccess = hasAccount && isLoggedIn",
                  "explanation": "&& (AND), || (OR) ve ! (NOT) operatörleri Boolean işlemlerinde kullanılır."
                }
              ],
              "keyPoints": [
                "Boolean sadece true veya false değerlerini alır",
                "Kontrol yapılarının temelini oluşturur",
                "Karşılaştırma işlemleri Boolean döner",
                "Mantıksal operatörlerle birlikte kullanılır",
                "Uygulama akışını kontrol etmek için kritiktir"
              ],
              "questions": [
                {
                  "questionId": 110501,
                  "question": "Boolean veri tipi hangi değerleri alabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "1 ve 0",
                    "true ve false",
                    "Evet ve Hayır",
                    "On ve Off"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Boolean veri tipi sadece true ve false değerlerini alabilir.",
                  "tags": ["boolean", "basics"]
                },
                {
                  "questionId": 110502,
                  "question": "Aşağıdaki karşılaştırmalardan hangisi Boolean döner?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "5 + 3",
                    "10 * 2",
                    "8 > 3",
                    "7 - 4"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Karşılaştırma işlemleri Boolean (true/false) döner.",
                  "tags": ["boolean", "comparison"]
                },
                {
                  "questionId": 110503,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val isOpen = true\nval isAdmin = false\nprintln(isOpen && isAdmin)",
                  "difficulty": "medium",
                  "options": [
                    "true",
                    "false",
                    "Compile-time hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "&& operatörü AND işlemi yapar. true && false sonucu false olur.",
                  "tags": ["boolean", "operators"]
                },
                {
                  "questionId": 110504,
                  "question": "Mantıksal OR işlemi hangi operatör ile yapılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "&&",
                    "||",
                    "!",
                    "=="
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "|| operatörü mantıksal OR (veya) işlemi yapar.",
                  "tags": ["boolean", "operators"]
                },
                {
                  "questionId": 110505,
                  "question": "Aşağıdakilerden hangisi Boolean operatörü değildir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "&&",
                    "||",
                    "!",
                    "+"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "+ operatörü aritmetik işlemler içindir, Boolean işlemi yapmaz.",
                  "tags": ["boolean", "operators"]
                }
              ]
            },
            {
              "topicId": 1106,
              "title": "Tip Dönüşümleri",
              "summary": "Tip dönüşümleri, bir veri tipinin başka bir veri tipine çevrilmesi işlemidir. Kotlin'de veri kaybını ve hataları önlemek için otomatik dönüşümler yerine açık (explicit) tip dönüşümleri kullanılır.",
              "content": "## Tip Dönüşümleri\n\nKotlin'de veri tipleri arasında **otomatik dönüşüm yapılmaz**. Bu, özellikle Java'dan gelen geliştiriciler için önemli bir farktır.\n\nKotlin, güvenliği artırmak için dönüşümlerin **açıkça belirtilmesini (explicit conversion)** ister. Bunun için her veri tipinin sağladığı dönüşüm fonksiyonları kullanılır.\n\nEn sık kullanılan dönüşüm fonksiyonları:\n- toInt()\n- toLong()\n- toFloat()\n- toDouble()\n- toString()\n- toBoolean()\n\nBu yaklaşım, runtime hatalarını azaltır ve kodun daha okunabilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 6,
              "codeExamples": [
                {
                  "title": "Sayısal Tip Dönüşümü",
                  "code": "val number: Int = 10\nval longNumber: Long = number.toLong()",
                  "explanation": "Int tipi doğrudan Long'a atanamaz, toLong() fonksiyonu kullanılmalıdır."
                },
                {
                  "title": "String'den Sayıya Dönüşüm",
                  "code": "val text = \"123\"\nval value = text.toInt()",
                  "explanation": "String içeriği sayıya uygunsa toInt() ile dönüştürülebilir."
                },
                {
                  "title": "Hatalı Dönüşüm Örneği",
                  "code": "val text = \"abc\"\n// val number = text.toInt() // Runtime hatası",
                  "explanation": "Sayısal olmayan bir String, toInt() ile dönüştürülürse runtime hatası oluşur."
                },
                {
                  "title": "Güvenli Dönüşüm",
                  "code": "val text = \"abc\"\nval number = text.toIntOrNull()",
                  "explanation": "toIntOrNull() dönüşüm başarısız olursa null döner ve uygulama çökmez."
                }
              ],
              "keyPoints": [
                "Kotlin'de otomatik tip dönüşümü yoktur",
                "Dönüşümler explicit olarak yapılır",
                "toInt(), toDouble() gibi fonksiyonlar kullanılır",
                "Hatalı dönüşümler runtime hatası oluşturur",
                "toIntOrNull() gibi güvenli fonksiyonlar tercih edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 110601,
                  "question": "Kotlin'de Int bir değişken doğrudan Long'a atanabilir mi?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet, otomatik dönüşür",
                    "Hayır, toLong() kullanılmalıdır",
                    "Sadece val ile tanımlanırsa",
                    "Sadece var ile tanımlanırsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin otomatik tip dönüşümüne izin vermez. Açık dönüşüm gerekir.",
                  "tags": ["type-conversion", "basics"]
                },
                {
                  "questionId": 110602,
                  "question": "Aşağıdakilerden hangisi güvenli tip dönüşümü sağlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "toInt()",
                    "toLong()",
                    "toIntOrNull()",
                    "toDouble()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "toIntOrNull() dönüşüm başarısız olursa null döner.",
                  "tags": ["type-conversion", "null-safety"]
                },
                {
                  "questionId": 110603,
                  "question": "Aşağıdaki kod çalıştırıldığında ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val text = \"abc\"\nval number = text.toInt()\nprintln(number)",
                  "difficulty": "medium",
                  "options": [
                    "0 yazdırır",
                    "null yazdırır",
                    "Compile-time hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Sayısal olmayan bir String toInt() ile dönüştürülürse runtime hatası oluşur.",
                  "tags": ["type-conversion", "runtime"]
                },
                {
                  "questionId": 110604,
                  "question": "Aşağıdakilerden hangisi String'e dönüşüm yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "toInt()",
                    "toFloat()",
                    "toString()",
                    "toBoolean()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "toString() metodu değeri String'e çevirir.",
                  "tags": ["type-conversion", "string"]
                },
                {
                  "questionId": 110605,
                  "question": "Kotlin'de neden otomatik tip dönüşümü yoktur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performans düşüklüğü",
                    "Derleyici hatası",
                    "Kod güvenliğini artırmak",
                    "Java ile uyumsuzluk"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Açık tip dönüşümü, veri kaybını ve beklenmeyen hataları önler.",
                  "tags": ["type-conversion", "best-practices"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 12001,
            "question": "Kotlin'de değiştirilemeyen (immutable) değişken tanımlamak için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "var",
              "val",
              "let",
              "const"
            ],
            "correctAnswerIndex": 1,
            "explanation": "val ile tanımlanan değişkenler immutable'dır ve bir kez değer atandıktan sonra değiştirilemez.",
            "tags": ["val", "var"]
          },
          {
            "questionId": 12002,
            "question": "Aşağıdaki kodlardan hangisi derleme (compile-time) hatası verir?",
            "questionType": "multiple_choice",
            "code": "val number = 10\nnumber = 20",
            "difficulty": "easy",
            "options": [
              "Kod hatasız çalışır",
              "Runtime hatası verir",
              "Compile-time hatası verir",
              "Sadece uyarı verir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "val ile tanımlanan değişkenlere yeniden değer atanamaz. Bu nedenle compile-time hatası oluşur.",
            "tags": ["val", "compile-error"]
          },
          {
            "questionId": 12003,
            "question": "Kotlin'de aşağıdaki tam sayı tiplerinden hangisi daha fazla bellek kullanır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Int",
              "Short",
              "Long",
              "Byte"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Long 64-bit, Int ise 32-bit bellek kullanır. Bu nedenle Long daha fazla bellek tüketir.",
            "tags": ["int", "long"]
          },
          {
            "questionId": 12004,
            "question": "Aşağıdaki ifadelerden hangisi Double veri tipine aittir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "10",
              "10L",
              "10.5",
              "true"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Ondalıklı (kesirli) sayılar varsayılan olarak Double tipindedir.",
            "tags": ["double", "float"]
          },
          {
            "questionId": 12005,
            "question": "Kotlin'de Float tipinde bir sayı tanımlamak için hangi kullanım doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "val x = 10.5",
              "val x = 10.5D",
              "val x = 10.5F",
              "val x = Float(10.5)"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de Float tanımlamak için sayı sonuna 'F' eklenmelidir.",
            "tags": ["float", "double"]
          },
          {
            "questionId": 12006,
            "question": "Kotlin'de String birleştirme için hangi yöntem kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "+ operatörü",
              "$ operatörü",
              "& operatörü",
              "% operatörü"
            ],
            "correctAnswerIndex": 0,
            "explanation": "String'ler + operatörü ile birleştirilebilir. Ayrıca string template de kullanılabilir.",
            "tags": ["string"]
          },
          {
            "questionId": 12007,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val name = \"Ahmet\"\nprintln(\"Merhaba $name\")",
            "difficulty": "easy",
            "options": [
              "Merhaba name",
              "Merhaba $name",
              "Merhaba Ahmet",
              "Compile hatası"
            ],
            "correctAnswerIndex": 2,
            "explanation": "String template sayesinde $name ifadesi değişkenin değeriyle değiştirilir.",
            "tags": ["string", "template"]
          },
          {
            "questionId": 12008,
            "question": "Kotlin'de Boolean veri tipi hangi değerleri alabilir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "0 ve 1",
              "\"true\" ve \"false\"",
              "true ve false",
              "yes ve no"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Boolean veri tipi yalnızca true veya false değerlerini alır.",
            "tags": ["boolean"]
          },
          {
            "questionId": 12009,
            "question": "Aşağıdaki dönüşümlerden hangisi Kotlin'de doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "val x: Int = \"10\"",
              "val x = 10.toString()",
              "val x: String = 10",
              "val x = Int(\"10\")"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de tip dönüşümleri açık yapılır. toString() doğru bir kullanımdır.",
            "tags": ["type-conversion"]
          },
          {
            "questionId": 12010,
            "question": "Kotlin'de neden otomatik (implicit) tip dönüşümü yoktur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Performansı düşürdüğü için",
              "Okunabilirliği azalttığı için",
              "Tip güvenliğini artırmak için",
              "Sadece Java uyumluluğu için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin, tip güvenliğini artırmak ve olası hataları önlemek için implicit type casting yapmaz.",
            "tags": ["type-safety", "conversion"]
          }
        ]
        },
        {
          "sectionId": 103,
          "sectionTitle": "Kontrol Yapıları",
          "sectionDescription": "",
          "order": 3,
          "topics": [
            {
              "topicId": 1201,
              "title": "if / else",
              "summary": "if / else yapıları, Kotlin'de koşullu durumları kontrol etmek için kullanılır. Belirli bir şart sağlandığında çalışacak kod bloklarını tanımlamaya olanak tanır ve uygulama akışını yönlendirmek için temel bir kontrol mekanizmasıdır.",
              "content": "## if / else\n\nKotlin'de **if / else**, belirli koşullara göre kodun çalışıp çalışmayacağını kontrol etmek için kullanılır.\n\nKoşul ifadesi her zaman **Boolean** (true / false) olmalıdır. Kotlin'de if yapısı sadece bir kontrol mekanizması değil, aynı zamanda **bir ifade (expression)** olarak da kullanılabilir. Bu sayede if bloğu bir değer döndürebilir.\n\nBu özellik, Kotlin kodlarını daha kısa ve okunabilir hale getirir.\n\nif / else yapıları tek başına veya iç içe (nested) şekilde kullanılabilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit if Kullanımı",
                  "code": "val age = 20\n\nif (age >= 18) {\n    println(\"Reşit\")\n}",
                  "explanation": "Koşul true ise if bloğu çalışır."
                },
                {
                  "title": "if - else Kullanımı",
                  "code": "val age = 16\n\nif (age >= 18) {\n    println(\"Reşit\")\n} else {\n    println(\"Reşit değil\")\n}",
                  "explanation": "Koşul false olduğunda else bloğu çalışır."
                },
                {
                  "title": "if Expression Olarak Kullanımı",
                  "code": "val score = 75\n\nval result = if (score >= 60) {\n    \"Geçti\"\n} else {\n    \"Kaldı\"\n}",
                  "explanation": "Kotlin'de if bir değer döndürebilir ve değişkene atanabilir."
                },
                {
                  "title": "else if Kullanımı",
                  "code": "val note = 85\n\nval grade = if (note >= 90) {\n    \"AA\"\n} else if (note >= 80) {\n    \"BB\"\n} else {\n    \"CC\"\n}",
                  "explanation": "Birden fazla koşul else if ile kontrol edilebilir."
                }
              ],
              "keyPoints": [
                "Koşul mutlaka Boolean olmalıdır",
                "if bir expression olarak kullanılabilir",
                "else if ile çoklu koşullar kontrol edilir",
                "Kod okunabilirliği için süslü parantez önerilir",
                "Kontrol yapılarının temelidir"
              ],
              "questions": [
                {
                  "questionId": 120101,
                  "question": "if koşulu hangi türde değer almalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Int",
                    "String",
                    "Boolean",
                    "Any"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "if koşulu true veya false dönen bir ifade olmalıdır.",
                  "tags": ["if", "basics"]
                },
                {
                  "questionId": 120102,
                  "question": "Kotlin'de if yapısının önemli farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece kontrol yapısıdır",
                    "Sadece döngülerle çalışır",
                    "Bir ifade (expression) olarak değer döndürebilir",
                    "Sadece else ile kullanılır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de if bir expression'dır ve değer döndürebilir.",
                  "tags": ["if", "expression"]
                },
                {
                  "questionId": 120103,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val x = 10\nval y = 20\n\nval max = if (x > y) x else y\nprintln(max)",
                  "difficulty": "medium",
                  "options": [
                    "10",
                    "20",
                    "true",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "x > y false olduğu için else bloğu çalışır ve y değeri yazdırılır.",
                  "tags": ["if", "expression"]
                },
                {
                  "questionId": 120104,
                  "question": "else if ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Tek koşul varsa",
                    "Birden fazla koşul kontrol edilecekse",
                    "Sadece Boolean false ise",
                    "if kullanılamıyorsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Birden fazla koşul kontrol edilecekse else if kullanılır.",
                  "tags": ["if", "conditions"]
                },
                {
                  "questionId": 120105,
                  "question": "Aşağıdakilerden hangisi Kotlin'de geçerli bir if ifadesidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "if (x = 5)",
                    "if x > 5",
                    "if (x > 5) println(x)",
                    "if x > 5 then"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de koşul parantez içinde yazılır ve doğru sözdizimi gerekir.",
                  "tags": ["if", "syntax"]
                }
              ]
            },            
            {
              "topicId": 1202,
              "title": "when",
              "summary": "when yapısı, Kotlin'de çoklu koşulları kontrol etmek için kullanılan güçlü bir kontrol yapısıdır. Java'daki switch yapısının gelişmiş bir versiyonudur ve hem değer hem de koşul bazlı kontroller yapabilir.",
              "content": "## when\n\nKotlin'de **when**, bir değişkenin veya ifadenin farklı durumlara göre değerlendirilmesini sağlar. Java'daki switch yapısına benzer ancak çok daha esnek ve güçlüdür.\n\nwhen sadece sabit değerlerle değil; aralıklar, koleksiyonlar, tip kontrolleri ve Boolean koşullarla da çalışabilir. Ayrıca **if gibi bir expression** olarak kullanılarak değer döndürebilir.\n\nwhen yapısı, okunabilirliği artırır ve çoklu if-else bloklarının yerini alabilir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Basit when Kullanımı",
                  "code": "val day = 3\n\nwhen (day) {\n    1 -> println(\"Pazartesi\")\n    2 -> println(\"Salı\")\n    3 -> println(\"Çarşamba\")\n    else -> println(\"Geçersiz gün\")\n}",
                  "explanation": "Değer, eşleşen case'e göre çalışır."
                },
                {
                  "title": "Birden Fazla Değerle when",
                  "code": "val number = 2\n\nwhen (number) {\n    1, 3, 5 -> println(\"Tek\")\n    2, 4, 6 -> println(\"Çift\")\n}",
                  "explanation": "Tek bir case içinde birden fazla değer kontrol edilebilir."
                },
                {
                  "title": "when Expression Olarak Kullanımı",
                  "code": "val score = 85\n\nval result = when (score) {\n    in 90..100 -> \"AA\"\n    in 80..89 -> \"BB\"\n    else -> \"CC\"\n}",
                  "explanation": "when bir expression olarak değer döndürebilir."
                },
                {
                  "title": "Koşulsuz when Kullanımı",
                  "code": "val age = 20\n\nwhen {\n    age < 18 -> println(\"Reşit değil\")\n    age >= 18 -> println(\"Reşit\")\n}",
                  "explanation": "Koşulsuz when, Boolean ifadelerle çalışır."
                }
              ],
              "keyPoints": [
                "switch yerine kullanılır",
                "Birden fazla değeri aynı anda kontrol edebilir",
                "Aralıklar (in) ile çalışabilir",
                "Expression olarak değer döndürebilir",
                "Koşulsuz when kullanımı mümkündür"
              ],
              "questions": [
                {
                  "questionId": 120201,
                  "question": "when yapısı hangi kontrol yapısının yerine kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "if",
                    "for",
                    "switch",
                    "while"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "when, Java'daki switch yapısının gelişmiş halidir.",
                  "tags": ["when", "basics"]
                },
                {
                  "questionId": 120202,
                  "question": "Kotlin'de when yapısının önemli avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece sabit değerlerle çalışır",
                    "Expression olarak değer döndürebilir",
                    "Sadece Int ile çalışır",
                    "if yerine kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "when bir expression'dır ve değer döndürebilir.",
                  "tags": ["when", "expression"]
                },
                {
                  "questionId": 120203,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val x = 7\n\nval result = when (x) {\n    in 1..5 -> \"Düşük\"\n    in 6..10 -> \"Yüksek\"\n    else -> \"Bilinmiyor\"\n}\nprintln(result)",
                  "difficulty": "medium",
                  "options": [
                    "Düşük",
                    "Yüksek",
                    "Bilinmiyor",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "7 değeri 6..10 aralığında olduğu için \"Yüksek\" yazdırılır.",
                  "tags": ["when", "range"]
                },
                {
                  "questionId": 120204,
                  "question": "Koşulsuz when ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sabit değerler kontrol edilecekse",
                    "Boolean ifadelerle kontrol yapılacaksa",
                    "Sadece String değerler için",
                    "when kullanılamıyorsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Koşulsuz when, Boolean ifadelerle çalışır.",
                  "tags": ["when", "conditions"]
                },
                {
                  "questionId": 120205,
                  "question": "Aşağıdakilerden hangisi when yapısında kullanılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Int",
                    "Sadece String",
                    "Sabit değerler",
                    "Sabitler, aralıklar ve koşullar"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "when; sabitler, aralıklar, koleksiyonlar ve koşullarla çalışabilir.",
                  "tags": ["when", "advanced"]
                }
              ]
            },
            {
              "topicId": 1203,
              "title": "for Döngüsü",
              "summary": "for döngüsü, Kotlin'de belirli bir aralıkta veya koleksiyon üzerinde tekrar eden işlemleri gerçekleştirmek için kullanılır. Sayaç kontrollü ve koleksiyon tabanlı döngüler için en yaygın kullanılan yapıdır.",
              "content": "## for Döngüsü\n\nKotlin'de **for döngüsü**, bir aralık (range) veya koleksiyon (Array, List, Set, Map) üzerinde dolaşmak için kullanılır.\n\nKotlin'de klasik index tabanlı for yerine daha okunabilir ve güvenli yapılar tercih edilir. Range ifadeleri, step, downTo ve until gibi anahtar kelimelerle güçlü bir kullanım sunar.\n\nfor döngüsü özellikle listeleme, veri işleme ve tekrar eden görevler için idealdir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Basit for Döngüsü",
                  "code": "for (i in 1..5) {\n    println(i)\n}",
                  "explanation": "1'den 5'e kadar (5 dahil) döner."
                },
                {
                  "title": "until Kullanımı",
                  "code": "for (i in 0 until 5) {\n    println(i)\n}",
                  "explanation": "0'dan 4'e kadar döner. 5 dahil değildir."
                },
                {
                  "title": "step ve downTo Kullanımı",
                  "code": "for (i in 10 downTo 0 step 2) {\n    println(i)\n}",
                  "explanation": "10'dan 0'a doğru 2'şer azalarak döner."
                },
                {
                  "title": "Koleksiyon Üzerinde for",
                  "code": "val names = listOf(\"Ali\", \"Ayşe\", \"Mehmet\")\n\nfor (name in names) {\n    println(name)\n}",
                  "explanation": "Liste elemanları üzerinde tek tek dolaşır."
                }
              ],
              "keyPoints": [
                "Range veya koleksiyon üzerinde çalışır",
                "until, downTo ve step desteklenir",
                "Index hatalarını azaltır",
                "Okunabilir ve güvenlidir",
                "Koleksiyon işlemlerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 120301,
                  "question": "Aşağıdaki for döngüsü kaç kez çalışır?",
                  "questionType": "multiple_choice",
                  "code": "for (i in 1..3) {\n    println(i)\n}",
                  "difficulty": "easy",
                  "options": [
                    "2",
                    "3",
                    "4",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "1..3 aralığı 1, 2 ve 3 değerlerini kapsar.",
                  "tags": ["for", "range"]
                },
                {
                  "questionId": 120302,
                  "question": "until anahtar kelimesinin farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Başlangıç değerini almaz",
                    "Bitiş değerini dahil etmez",
                    "Sadece geriye doğru çalışır",
                    "step ile kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "until, bitiş değerini dahil etmez.",
                  "tags": ["for", "until"]
                },
                {
                  "questionId": 120303,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "for (i in 5 downTo 1) {\n    print(i)\n}",
                  "difficulty": "medium",
                  "options": [
                    "12345",
                    "54321",
                    "01234",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "downTo geriye doğru sayar.",
                  "tags": ["for", "downTo"]
                },
                {
                  "questionId": 120304,
                  "question": "Bir koleksiyon üzerinde dolaşmak için hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "for (i = 0; i < list.size; i++)",
                    "for (item in list)",
                    "while (list)",
                    "loop (list)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de koleksiyonlar doğrudan for-in ile gezilir.",
                  "tags": ["for", "collections"]
                },
                {
                  "questionId": 120305,
                  "question": "step anahtar kelimesi ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Döngüyü durdurur",
                    "Adım sayısını belirler",
                    "Sadece ileri sayar",
                    "Bitiş değerini değiştirir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "step, döngünün kaçar kaçar ilerleyeceğini belirler.",
                  "tags": ["for", "step"]
                }
              ]
            },
            {
              "topicId": 1204,
              "title": "while / do-while Döngüsü",
              "summary": "while ve do-while döngüleri, koşul doğru olduğu sürece çalışan kontrol yapılarıdır. while döngüsünde koşul başta kontrol edilirken, do-while döngüsünde döngü en az bir kez çalışır.",
              "content": "## while ve do-while Döngüsü\n\nKotlin'de **while döngüsü**, koşul doğru olduğu sürece çalışır. Koşul döngünün başında kontrol edilir.\n\n**do-while döngüsü** ise koşulu sonda kontrol eder. Bu sayede döngü bloğu **en az bir kez** çalıştırılır.\n\nBu döngüler genellikle tekrar sayısı önceden bilinmeyen durumlarda, kullanıcıdan veri alma, API'den cevap bekleme gibi senaryolarda kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Basit while Döngüsü",
                  "code": "var i = 1\n\nwhile (i <= 5) {\n    println(i)\n    i++\n}",
                  "explanation": "Koşul doğru olduğu sürece döngü çalışır."
                },
                {
                  "title": "Yanlış Koşulda while",
                  "code": "var x = 10\n\nwhile (x < 5) {\n    println(x)\n}",
                  "explanation": "Koşul baştan false olduğu için döngü hiç çalışmaz."
                },
                {
                  "title": "do-while Döngüsü",
                  "code": "var y = 10\n\ndo {\n    println(y)\n} while (y < 5)",
                  "explanation": "Koşul false olsa bile do-while en az bir kez çalışır."
                },
                {
                  "title": "Kullanıcıdan Veri Alma Senaryosu",
                  "code": "var password: String\n\ndo {\n    password = readLine() ?: \"\"\n} while (password.length < 6)",
                  "explanation": "Şifre en az 6 karakter olana kadar döngü devam eder."
                }
              ],
              "keyPoints": [
                "while döngüsünde koşul başta kontrol edilir",
                "do-while döngüsü en az bir kez çalışır",
                "Tekrar sayısı bilinmeyen durumlar için uygundur",
                "Yanlış koşulda while hiç çalışmayabilir",
                "Sonsuz döngülere dikkat edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 120401,
                  "question": "while döngüsünün temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "En az bir kez çalışır",
                    "Koşul sonda kontrol edilir",
                    "Koşul doğru olduğu sürece çalışır",
                    "Sadece sayılarla çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "while döngüsü koşul true olduğu sürece çalışır.",
                  "tags": ["while"]
                },
                {
                  "questionId": 120402,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "var i = 5\n\nwhile (i < 3) {\n    println(i)\n}",
                  "difficulty": "easy",
                  "options": [
                    "5",
                    "3",
                    "Hiçbir çıktı olmaz",
                    "Sonsuz döngü"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Koşul baştan false olduğu için döngü çalışmaz.",
                  "tags": ["while"]
                },
                {
                  "questionId": 120403,
                  "question": "do-while döngüsünün farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Koşul başta kontrol edilir",
                    "Sadece Boolean ile çalışır",
                    "En az bir kez çalışır",
                    "Sonsuz döngü oluşturur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "do-while koşuldan bağımsız olarak en az bir kez çalışır.",
                  "tags": ["do-while"]
                },
                {
                  "questionId": 120404,
                  "question": "Aşağıdaki kod kaç kez çalışır?",
                  "questionType": "multiple_choice",
                  "code": "var x = 0\n\ndo {\n    x++\n} while (x < 3)",
                  "difficulty": "medium",
                  "options": [
                    "1",
                    "2",
                    "3",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "x değeri 0,1,2 iken döngü çalışır. Toplam 3 kez.",
                  "tags": ["do-while"]
                },
                {
                  "questionId": 120405,
                  "question": "Sonsuz döngüye sebep olan durum hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Koşulun hiç güncellenmemesi",
                    "Koşulun false olması",
                    "Koşulun başta kontrol edilmesi",
                    "do-while kullanılması"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Koşul değişmezse döngü sonsuza kadar devam edebilir.",
                  "tags": ["while", "do-while"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 13001,
            "question": "Kotlin'de if yapısı hakkında aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece koşul kontrolü için kullanılır, değer döndüremez",
              "Sadece Boolean döndürür",
              "Bir ifade (expression) olarak değer döndürebilir",
              "Sadece Java uyumluluğu için vardır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de if bir expression'dır ve bir değer döndürebilir.",
            "tags": ["if", "else"]
          },
          {
            "questionId": 13002,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val x = 10\nval result = if (x > 5) \"Büyük\" else \"Küçük\"\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "Küçük",
              "Büyük",
              "true",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "x değeri 5'ten büyük olduğu için if bloğu çalışır ve \"Büyük\" yazdırılır.",
            "tags": ["if", "else"]
          },
          {
            "questionId": 13003,
            "question": "Kotlin'de when yapısı için aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece switch yerine kullanılır",
              "Sadece Int tipleriyle çalışır",
              "Hem koşul hem değer döndürebilir",
              "Sadece Boolean döndürür"
            ],
            "correctAnswerIndex": 2,
            "explanation": "when, Kotlin'de güçlü bir kontrol yapısıdır ve expression olarak değer döndürebilir.",
            "tags": ["when"]
          },
          {
            "questionId": 13004,
            "question": "Aşağıdaki when bloğunun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val day = 3\nval result = when(day) {\n    1 -> \"Pazartesi\"\n    2 -> \"Salı\"\n    3 -> \"Çarşamba\"\n    else -> \"Bilinmiyor\"\n}\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "Salı",
              "Çarşamba",
              "Pazartesi",
              "Bilinmiyor"
            ],
            "correctAnswerIndex": 1,
            "explanation": "day değeri 3 olduğu için when bloğunda \"Çarşamba\" çalışır.",
            "tags": ["when"]
          },
          {
            "questionId": 13005,
            "question": "Aşağıdaki for döngüsü kaç kez çalışır?",
            "questionType": "multiple_choice",
            "code": "for (i in 1..5) {\n    println(i)\n}",
            "difficulty": "easy",
            "options": [
              "4",
              "5",
              "6",
              "Sonsuz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "1..5 aralığı her iki sınırı da dahil eder, döngü 5 kez çalışır.",
            "tags": ["for"]
          },
          {
            "questionId": 13006,
            "question": "Kotlin'de aşağıdaki aralıklardan hangisi 5 değerini içermez?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "1..5",
              "1 until 5",
              "5 downTo 1",
              "1..10"
            ],
            "correctAnswerIndex": 1,
            "explanation": "until üst sınırı dahil etmez, bu nedenle 5 değeri aralığa dahil değildir.",
            "tags": ["for", "range"]
          },
          {
            "questionId": 13007,
            "question": "Aşağıdaki while döngüsü ile ilgili hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "En az bir kez çalışır",
              "Koşul sağlanmazsa hiç çalışmaz",
              "Sadece Int ile çalışır",
              "for döngüsünden daha hızlıdır"
            ],
            "correctAnswerIndex": 1,
            "explanation": "while döngüsünde koşul başta kontrol edilir, koşul false ise döngü hiç çalışmaz.",
            "tags": ["while"]
          },
          {
            "questionId": 13008,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "var i = 0\nwhile (i < 3) {\n    print(i)\n    i++\n}",
            "difficulty": "easy",
            "options": [
              "012",
              "123",
              "03",
              "Sonsuz döngü"
            ],
            "correctAnswerIndex": 0,
            "explanation": "i değeri 0'dan başlayarak 3'e kadar artırılır ve ekrana 012 yazdırılır.",
            "tags": ["while"]
          },
          {
            "questionId": 13009,
            "question": "Kotlin'de if-else yerine when kullanmanın avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Daha hızlı çalışır",
              "Daha az bellek kullanır",
              "Daha okunabilir ve genişletilebilir yapı sunar",
              "Sadece Boolean destekler"
            ],
            "correctAnswerIndex": 2,
            "explanation": "when, çoklu koşullarda kodun okunabilirliğini ve bakımını artırır.",
            "tags": ["when", "if"]
          },
          {
            "questionId": 13010,
            "question": "Kotlin'de for döngüsünde index'e erişmek için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "withIndex()",
              "getIndex()",
              "indexOf()",
              "forEachIndex()"
            ],
            "correctAnswerIndex": 0,
            "explanation": "withIndex() fonksiyonu, eleman ve index bilgisine birlikte erişim sağlar.",
            "tags": ["for", "index"]
          }
        ]
        },
        {
          "sectionId": 104,
          "sectionTitle": "Koleksiyonlar",
          "sectionDescription": "",
          "order": 4,
          "topics": [
            {
              "topicId": 1301,
              "title": "Array",
              "summary": "Array, aynı türden birden fazla veriyi tek bir değişken altında saklamaya yarayan sabit boyutlu bir veri yapısıdır. Kotlin'de Array'ler index mantığıyla çalışır ve elemanlara 0'dan başlayarak erişilir.",
              "content": "## Array (Dizi)\n\nArray, Kotlin'de belirli sayıda ve **aynı türde** veriyi saklamak için kullanılır. Array'lerin boyutu tanımlandıktan sonra değiştirilemez.\n\nHer eleman bir index numarasına sahiptir ve index'ler **0'dan başlar**. Array'ler genellikle sabit veri listeleri veya performansın önemli olduğu durumlarda tercih edilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Array Tanımlama",
                  "code": "val numbers = arrayOf(1, 2, 3, 4, 5)",
                  "explanation": "Integer türünde bir Array oluşturulur."
                },
                {
                  "title": "Index ile Erişim",
                  "code": "val cities = arrayOf(\"Ankara\", \"İstanbul\", \"İzmir\")\nprintln(cities[0])",
                  "explanation": "Array'in ilk elemanına erişilir."
                },
                {
                  "title": "Array Elemanı Güncelleme",
                  "code": "val ages = arrayOf(18, 20, 25)\nages[1] = 21",
                  "explanation": "Index kullanılarak eleman güncellenebilir."
                },
                {
                  "title": "Array Boyutu",
                  "code": "val names = arrayOf(\"Ali\", \"Veli\")\nprintln(names.size)",
                  "explanation": "Array içindeki eleman sayısını verir."
                },
                {
                  "title": "Döngü ile Array Gezme",
                  "code": "val scores = arrayOf(60, 70, 80)\nfor (score in scores) {\n    println(score)\n}",
                  "explanation": "for döngüsü ile tüm elemanlar gezilir."
                }
              ],
              "keyPoints": [
                "Array sabit boyutludur",
                "Aynı türden veriler saklanır",
                "Index'ler 0'dan başlar",
                "size özelliği eleman sayısını verir",
                "Elemanlar değiştirilebilir ama boyut değiştirilemez"
              ],
              "questions": [
                {
                  "questionId": 130101,
                  "question": "Array nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Farklı türden verileri tutan yapı",
                    "Sabit boyutlu veri koleksiyonu",
                    "Sonsuz eleman tutan liste",
                    "Sadece String tutan yapı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Array sabit boyutlu ve aynı türden verileri tutar.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130102,
                  "question": "Array index'leri kaçtan başlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "1",
                    "-1",
                    "0",
                    "2"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de Array index'leri 0'dan başlar.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130103,
                  "question": "Aşağıdaki kodun çıktısı nedir?",
                  "questionType": "multiple_choice",
                  "code": "val arr = arrayOf(10, 20, 30)\nprintln(arr[1])",
                  "difficulty": "easy",
                  "options": [
                    "10",
                    "20",
                    "30",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Index 1 ikinci elemanı temsil eder.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130104,
                  "question": "Array ile ilgili hangisi yanlıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Boyutu sonradan değiştirilebilir",
                    "Elemanlara index ile erişilir",
                    "Aynı türde veri tutar",
                    "size özelliği vardır"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Array'in boyutu tanımlandıktan sonra değiştirilemez.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130105,
                  "question": "Array hangi durumda daha uygundur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Eleman sayısı sürekli değişiyorsa",
                    "Sabit ve küçük veri listesi varsa",
                    "Farklı türler birlikte tutulacaksa",
                    "Dinamik ekleme çıkarma yapılacaksa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Array sabit boyutlu olduğu için değişmeyen veri listelerinde uygundur.",
                  "tags": ["array"]
                }
              ]
            },
            {
              "topicId": 1302,
              "title": "List ve MutableList",
              "summary": "List ve MutableList, Kotlin'de sıralı veri koleksiyonlarını temsil eder. List değiştirilemez (immutable) bir yapı sunarken, MutableList eleman ekleme, silme ve güncelleme gibi işlemlere izin verir.",
              "content": "## List ve MutableList\n\nKotlin'de List ve MutableList, aynı türden birden fazla veriyi sıralı şekilde saklamak için kullanılır.\n\n- **List**: Değiştirilemez (immutable). Eleman ekleme, silme veya güncelleme yapılamaz.\n- **MutableList**: Değiştirilebilir (mutable). Eleman ekleme, silme ve güncelleme yapılabilir.\n\nBest practice olarak, eğer koleksiyon değişmeyecekse List kullanılması önerilir. Bu yaklaşım kod güvenliğini ve okunabilirliği artırır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "List Tanımlama",
                  "code": "val names = listOf(\"Ali\", \"Veli\", \"Ayşe\")",
                  "explanation": "Değiştirilemez bir List oluşturulur."
                },
                {
                  "title": "MutableList Tanımlama",
                  "code": "val numbers = mutableListOf(1, 2, 3)",
                  "explanation": "Değiştirilebilir bir MutableList oluşturulur."
                },
                {
                  "title": "MutableList'e Eleman Ekleme",
                  "code": "val cities = mutableListOf(\"Ankara\", \"İstanbul\")\ncities.add(\"İzmir\")",
                  "explanation": "MutableList'e add() metodu ile eleman eklenir."
                },
                {
                  "title": "MutableList Eleman Güncelleme",
                  "code": "val ages = mutableListOf(18, 20, 25)\nages[1] = 21",
                  "explanation": "Index kullanılarak eleman güncellenebilir."
                },
                {
                  "title": "List Üzerinde Döngü",
                  "code": "val scores = listOf(60, 70, 80)\nfor (score in scores) {\n    println(score)\n}",
                  "explanation": "for döngüsü ile List elemanları gezilir."
                }
              ],
              "keyPoints": [
                "List immutable'dır, değiştirilemez",
                "MutableList mutable'dır, değiştirilebilir",
                "Index'ler 0'dan başlar",
                "List güvenli ve okunabilir kod sağlar",
                "Değişmeyecek koleksiyonlar için List tercih edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 130201,
                  "question": "List ve MutableList arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "List daha hızlıdır",
                    "MutableList sadece String tutar",
                    "List değiştirilemez, MutableList değiştirilebilir",
                    "Aralarında fark yoktur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "List immutable, MutableList mutable bir koleksiyondur.",
                  "tags": ["list", "mutablelist"]
                },
                {
                  "questionId": 130202,
                  "question": "Aşağıdakilerden hangisi eleman eklemeye izin verir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "listOf",
                    "List",
                    "MutableList",
                    "Array"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "MutableList eleman ekleme ve silmeye izin verir.",
                  "tags": ["mutablelist"]
                },
                {
                  "questionId": 130203,
                  "question": "Aşağıdaki kodda hangi satır hata verir?",
                  "questionType": "multiple_choice",
                  "code": "val list = listOf(1, 2, 3)\nlist.add(4)",
                  "difficulty": "medium",
                  "options": [
                    "Satır 1",
                    "Satır 2",
                    "İkisi de çalışır",
                    "Runtime hatası olur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "listOf ile oluşturulan List immutable olduğu için add() kullanılamaz.",
                  "tags": ["list"]
                },
                {
                  "questionId": 130204,
                  "question": "MutableList ile aşağıdakilerden hangisi yapılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Boyutunu değiştirmek",
                    "Sadece okuma yapmak",
                    "Sabit veri saklamak",
                    "Sadece compile-time'da kullanmak"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "MutableList eleman ekleme, silme ve güncellemeye izin verir.",
                  "tags": ["mutablelist"]
                },
                {
                  "questionId": 130205,
                  "question": "Best practice olarak hangisi önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her zaman MutableList kullanmak",
                    "Değişmeyecekse List kullanmak",
                    "Array yerine her zaman MutableList kullanmak",
                    "List kullanmamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Değişmeyecek koleksiyonlar için List kullanmak kod güvenliğini artırır.",
                  "tags": ["best-practice", "list"]
                }
              ]
            },
            {
              "topicId": 1303,
              "title": "Set",
              "summary": "Set, Kotlin'de benzersiz (unique) elemanlar tutan bir koleksiyon türüdür. Aynı elemandan birden fazla bulunmasına izin vermez ve genellikle tekrar eden verileri engellemek için kullanılır.",
              "content": "## Set\n\nSet, aynı türden benzersiz elemanları saklamak için kullanılan bir koleksiyondur.\n\n- **Set**: Değiştirilemez (immutable)\n- **MutableSet**: Değiştirilebilir (mutable)\n\nSet'lerde elemanların sırası garanti edilmez. Aynı değer birden fazla kez eklenmeye çalışılırsa sadece bir tanesi saklanır.\n\nTekrar eden verileri otomatik olarak filtrelemek için ideal bir yapıdır.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Set Tanımlama",
                  "code": "val numbers = setOf(1, 2, 3, 3, 4)",
                  "explanation": "Set tekrar eden elemanları otomatik olarak tekilleştirir."
                },
                {
                  "title": "MutableSet Tanımlama",
                  "code": "val cities = mutableSetOf(\"Ankara\", \"İstanbul\")",
                  "explanation": "Değiştirilebilir bir MutableSet oluşturulur."
                },
                {
                  "title": "MutableSet'e Eleman Ekleme",
                  "code": "val colors = mutableSetOf(\"Red\", \"Blue\")\ncolors.add(\"Green\")",
                  "explanation": "add() metodu ile yeni eleman eklenebilir."
                },
                {
                  "title": "Tekrar Eden Eleman Ekleme",
                  "code": "val set = mutableSetOf(1, 2, 3)\nset.add(2)\nprintln(set.size)",
                  "explanation": "Aynı eleman tekrar eklense bile Set içinde bir kez bulunur."
                },
                {
                  "title": "Set Üzerinde Döngü",
                  "code": "val fruits = setOf(\"Apple\", \"Banana\", \"Orange\")\nfor (fruit in fruits) {\n    println(fruit)\n}",
                  "explanation": "for döngüsü ile Set elemanları gezilebilir."
                }
              ],
              "keyPoints": [
                "Set benzersiz elemanlar tutar",
                "Aynı eleman Set içinde birden fazla kez bulunamaz",
                "Set immutable, MutableSet mutable'dır",
                "Eleman sırası garanti edilmez",
                "Tekrar eden verileri engellemek için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 130301,
                  "question": "Set koleksiyonunun temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sıralı elemanlar tutar",
                    "Tekrar eden elemanlara izin verir",
                    "Benzersiz elemanlar tutar",
                    "Sadece sayısal veri saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set aynı elemandan yalnızca bir tane tutar.",
                  "tags": ["set"]
                },
                {
                  "questionId": 130302,
                  "question": "Aşağıdakilerden hangisi değiştirilebilir Set oluşturur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "setOf",
                    "listOf",
                    "mutableSetOf",
                    "arrayOf"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "mutableSetOf ile MutableSet oluşturulur.",
                  "tags": ["mutableset"]
                },
                {
                  "questionId": 130303,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val set = setOf(1, 2, 2, 3)\nprintln(set.size)",
                  "difficulty": "medium",
                  "options": [
                    "2",
                    "3",
                    "4",
                    "Compile hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Set tekrar eden elemanları tekilleştirir, bu yüzden size 3 olur.",
                  "tags": ["set"]
                },
                {
                  "questionId": 130304,
                  "question": "Set kullanmanın en uygun olduğu senaryo hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sıralı veri gerektiğinde",
                    "Index ile erişim gerektiğinde",
                    "Tekrar eden verilerin engellenmesi gerektiğinde",
                    "Elemanların sürekli güncellendiği durumlarda"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set, tekrar eden elemanları otomatik olarak engeller.",
                  "tags": ["set", "use-case"]
                },
                {
                  "questionId": 130305,
                  "question": "Set koleksiyonları hakkında hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Set index kullanır",
                    "Set sıralı çalışır",
                    "Set tekrar eden elemanları tutmaz",
                    "Set sadece String saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set aynı elemanı birden fazla kez tutmaz.",
                  "tags": ["set"]
                }
              ]
            },
            {
              "topicId": 1304,
              "title": "Map",
              "summary": "Map, Kotlin'de anahtar-değer (key-value) mantığıyla çalışan bir koleksiyon türüdür. Her anahtar benzersizdir ve bir değere karşılık gelir. Verilere anahtar üzerinden hızlı erişim sağlar.",
              "content": "## Map\n\nMap, verileri anahtar (key) ve değer (value) çiftleri halinde saklar.\n\n- **Map**: Değiştirilemez (immutable)\n- **MutableMap**: Değiştirilebilir (mutable)\n\nMap'lerde anahtarlar benzersizdir. Aynı anahtar tekrar eklenirse eski değer güncellenir. Android geliştirmede JSON verileri, ayarlar ve cache işlemlerinde sıkça kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Map Tanımlama",
                  "code": "val ages = mapOf(\"Ahmet\" to 25, \"Mehmet\" to 30)",
                  "explanation": "mapOf ile değiştirilemez bir Map oluşturulur."
                },
                {
                  "title": "MutableMap Tanımlama",
                  "code": "val scores = mutableMapOf(\"Math\" to 90, \"Physics\" to 85)",
                  "explanation": "mutableMapOf ile değiştirilebilir bir Map oluşturulur."
                },
                {
                  "title": "Map'ten Veri Okuma",
                  "code": "val cities = mapOf(\"TR\" to \"Ankara\", \"FR\" to \"Paris\")\nprintln(cities[\"TR\"])",
                  "explanation": "Anahtar kullanılarak değere erişilir."
                },
                {
                  "title": "MutableMap'e Veri Ekleme",
                  "code": "val prices = mutableMapOf(\"Apple\" to 5)\nprices[\"Banana\"] = 3",
                  "explanation": "Yeni anahtar-değer çifti eklenir."
                },
                {
                  "title": "Aynı Anahtarla Güncelleme",
                  "code": "val map = mutableMapOf(\"A\" to 1)\nmap[\"A\"] = 2\nprintln(map[\"A\"])",
                  "explanation": "Aynı anahtar tekrar eklenirse değer güncellenir."
                }
              ],
              "keyPoints": [
                "Map key-value yapısı ile çalışır",
                "Anahtarlar benzersizdir",
                "Map immutable, MutableMap mutable'dır",
                "Anahtar ile hızlı veri erişimi sağlar",
                "Android'de JSON ve ayar verilerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 130401,
                  "question": "Map koleksiyonunun temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sıralı elemanlar tutar",
                    "Index ile erişim sağlar",
                    "Anahtar-değer yapısıyla çalışır",
                    "Tek tip veri saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map, anahtar-değer (key-value) yapısına sahiptir.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130402,
                  "question": "Aşağıdakilerden hangisi değiştirilebilir Map oluşturur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "mapOf",
                    "listOf",
                    "mutableMapOf",
                    "setOf"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "mutableMapOf ile MutableMap oluşturulur.",
                  "tags": ["mutablemap"]
                },
                {
                  "questionId": 130403,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val map = mapOf(\"A\" to 1, \"A\" to 2)\nprintln(map.size)",
                  "difficulty": "medium",
                  "options": [
                    "1",
                    "2",
                    "Compile hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Map anahtarları benzersizdir. Aynı anahtar tekrar kullanıldığında son değer geçerli olur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130404,
                  "question": "Map'ten veri okumak için hangisi kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "map.getKey()",
                    "map.value()",
                    "map[key]",
                    "map.indexOf()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map'te değerler anahtar kullanılarak map[key] şeklinde okunur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130405,
                  "question": "Map kullanımı için en uygun senaryo hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sıralı veri gerektiğinde",
                    "Index ile erişim gerektiğinde",
                    "Anahtar ile hızlı erişim gerektiğinde",
                    "Tekrar eden veriler gerektiğinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map, anahtar üzerinden hızlı erişim gereken durumlarda kullanılır.",
                  "tags": ["map", "use-case"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 14001,
            "question": "Kotlin'de Array ile List arasındaki temel fark nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Array immutable, List mutable'dır",
              "Array sabit boyutludur, List dinamik boyutludur",
              "Array sadece Int tutar",
              "List sadece String tutar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Array sabit boyutludur, List ise dinamik olarak büyüyüp küçülebilir.",
            "tags": ["array", "list"]
          },
          {
            "questionId": 14002,
            "question": "Aşağıdaki Array tanımının çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val numbers = arrayOf(1, 2, 3)\nprintln(numbers[1])",
            "difficulty": "easy",
            "options": [
              "1",
              "2",
              "3",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Array indexleri 0'dan başlar, index 1 değeri 2'dir.",
            "tags": ["array"]
          },
          {
            "questionId": 14003,
            "question": "Kotlin'de List ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Eleman eklenip çıkarılabilir",
              "Sadece MutableList ile eleman eklenebilir",
              "Index yapısı yoktur",
              "Sadece Int tutar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "List immutable'dır, eleman ekleme/çıkarma işlemleri MutableList ile yapılır.",
            "tags": ["list", "mutablelist"]
          },
          {
            "questionId": 14004,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val list = mutableListOf(10, 20)\nlist.add(30)\nprintln(list.size)",
            "difficulty": "easy",
            "options": [
              "2",
              "3",
              "30",
              "Hata verir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "MutableList'e eleman eklenebilir, toplam eleman sayısı 3 olur.",
            "tags": ["mutablelist"]
          },
          {
            "questionId": 14005,
            "question": "Set koleksiyonunun temel özelliği nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Index yapısı vardır",
              "Aynı elemandan birden fazla olabilir",
              "Tekrarlı elemanlara izin vermez",
              "Sıralı çalışmak zorundadır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Set, duplicate (tekrarlı) elemanlara izin vermez.",
            "tags": ["set"]
          },
          {
            "questionId": 14006,
            "question": "Aşağıdaki Set tanımının çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val set = setOf(1, 2, 2, 3)\nprintln(set.size)",
            "difficulty": "medium",
            "options": [
              "4",
              "3",
              "2",
              "Hata verir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Set tekrarlı elemanları kabul etmez, sadece 1,2,3 tutulur.",
            "tags": ["set"]
          },
          {
            "questionId": 14007,
            "question": "Map koleksiyonunda veriler nasıl tutulur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Index - Value",
              "Key - Value",
              "Value - Value",
              "Key - Key"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Map yapısı key-value (anahtar-değer) mantığıyla çalışır.",
            "tags": ["map"]
          },
          {
            "questionId": 14008,
            "question": "Aşağıdaki Map kullanımında ekrana ne yazdırılır?",
            "questionType": "multiple_choice",
            "code": "val map = mapOf(\"a\" to 1, \"b\" to 2)\nprintln(map[\"b\"])",
            "difficulty": "easy",
            "options": [
              "a",
              "1",
              "2",
              "null"
            ],
            "correctAnswerIndex": 2,
            "explanation": "\"b\" anahtarının karşılığı 2'dir.",
            "tags": ["map"]
          },
          {
            "questionId": 14009,
            "question": "MutableMap ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "code": null,
            "options": [
              "Yeni key-value eklenemez",
              "Sadece okunabilir",
              "Key-value ekleme ve silme yapılabilir",
              "Index kullanır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "MutableMap, Map'in değiştirilebilir versiyonudur.",
            "tags": ["map", "mutablemap"]
          },
          {
            "questionId": 14010,
            "question": "Aşağıdaki koleksiyonlardan hangisi benzersiz veri tutmak için en uygundur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Array",
              "List",
              "Set",
              "Map"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Set yapısı duplicate elemanları otomatik olarak engeller.",
            "tags": ["set", "collections"]
          }
        ]
        },
        {
          "sectionId": 105,
          "sectionTitle": "Fonksiyonlar ve Null Safety",
          "sectionDescription": "",
          "order": 5,
          "topics": [
            {
              "topicId": 1401,
              "title": "Fonksiyonlar",
              "summary": "Fonksiyonlar, belirli bir işi yapmak için yazılan ve gerektiğinde tekrar tekrar çağrılabilen kod bloklarıdır. Kotlin'de fonksiyonlar daha okunabilir, kısa ve güvenli bir yapı sunar.",
              "content": "## Fonksiyonlar\n\nFonksiyonlar, kod tekrarını önlemek ve uygulamayı daha düzenli hale getirmek için kullanılır.\n\nKotlin'de fonksiyonlar `fun` anahtar kelimesi ile tanımlanır. Fonksiyonlar parametre alabilir, değer döndürebilir veya sadece işlem yapabilir.\n\nKotlin'in kısa söz dizimi sayesinde tek satırlık fonksiyonlar sade bir şekilde yazılabilir. Fonksiyonlar Android geliştirmede UI işlemleri, veri işleme ve iş mantığını ayırmak için sıkça kullanılır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Parametresiz Fonksiyon",
                  "code": "fun sayHello() {\n    println(\"Merhaba Kotlin\")\n}",
                  "explanation": "Parametre almayan ve sadece işlem yapan basit bir fonksiyon."
                },
                {
                  "title": "Parametre Alan Fonksiyon",
                  "code": "fun greet(name: String) {\n    println(\"Merhaba $name\")\n}",
                  "explanation": "Fonksiyon dışarıdan parametre alabilir."
                },
                {
                  "title": "Geriye Değer Döndüren Fonksiyon",
                  "code": "fun sum(a: Int, b: Int): Int {\n    return a + b\n}",
                  "explanation": "Fonksiyon hesaplama yapıp bir değer döndürebilir."
                },
                {
                  "title": "Tek Satırlık Fonksiyon",
                  "code": "fun multiply(a: Int, b: Int): Int = a * b",
                  "explanation": "Tek satırlık fonksiyonlarda return yazmaya gerek yoktur."
                },
                {
                  "title": "Fonksiyon Çağırma",
                  "code": "val result = sum(5, 3)\nprintln(result)",
                  "explanation": "Fonksiyon çağrılarak dönen değer kullanılabilir."
                }
              ],
              "keyPoints": [
                "Fonksiyonlar fun anahtar kelimesi ile tanımlanır",
                "Parametre alabilir veya almayabilir",
                "Geriye değer döndürebilir",
                "Kod tekrarını önler",
                "Android projelerinde iş mantığını ayırmak için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 140101,
                  "question": "Kotlin'de fonksiyon tanımlamak için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "function",
                    "def",
                    "fun",
                    "method"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de fonksiyonlar fun anahtar kelimesi ile tanımlanır.",
                  "tags": ["functions", "basics"]
                },
                {
                  "questionId": 140102,
                  "question": "Bir fonksiyonun geriye değer döndürmesi için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "println kullanılmalı",
                    "return kullanılmalı",
                    "val kullanılmalı",
                    "var kullanılmalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlar return anahtar kelimesi ile değer döndürür.",
                  "tags": ["functions", "return"]
                },
                {
                  "questionId": 140103,
                  "question": "Aşağıdaki fonksiyonlardan hangisi doğru tanımlanmıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "fun sum(a, b): Int",
                    "fun sum(a: Int, b: Int): Int = a + b",
                    "function sum(a: Int, b: Int)",
                    "def sum(a: Int, b: Int)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de parametre tipleri belirtilmeli ve fun anahtar kelimesi kullanılmalıdır.",
                  "tags": ["functions", "syntax"]
                },
                {
                  "questionId": 140104,
                  "question": "Tek satırlık fonksiyonlarda hangisi kullanılmaz?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "return",
                    "fun",
                    "Parametreler",
                    "Dönüş tipi"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Tek satırlık fonksiyonlarda return anahtar kelimesi kullanılmaz.",
                  "tags": ["functions"]
                },
                {
                  "questionId": 140105,
                  "question": "Fonksiyonların en büyük faydası nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kod boyutunu artırmak",
                    "Kod tekrarını azaltmak",
                    "Daha fazla değişken oluşturmak",
                    "Sadece çıktı almak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlar kod tekrarını azaltır ve düzenli kod yazılmasını sağlar.",
                  "tags": ["functions", "best-practice"]
                }
              ]
            },
            {
              "topicId": 1402,
              "title": "Parametreler ve Geri Dönüş Tipleri",
              "summary": "Parametreler, fonksiyonlara dışarıdan veri göndermeyi sağlar. Geri dönüş tipi ise fonksiyonun yaptığı işlemin sonucunda döndürdüğü veri tipini belirtir. Kotlin'de fonksiyonlar farklı parametreler alabilir ve farklı türlerde değerler döndürebilir.",
              "content": "## Parametreler ve Geri Dönüş Tipleri\n\nFonksiyonlar, dışarıdan veri alabilmek için parametre kullanır. Parametrelerin türleri açıkça belirtilmelidir.\n\nGeri dönüş tipi, fonksiyonun yaptığı işlem sonucunda hangi türde bir değer döndüreceğini ifade eder. Eğer fonksiyon bir değer döndürmüyorsa dönüş tipi `Unit` olarak kabul edilir.\n\nKotlin'de varsayılan parametreler, isimli parametreler ve Unit dönüş tipi gibi modern özellikler bulunmaktadır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Tek Parametreli Fonksiyon",
                  "code": "fun printAge(age: Int) {\n    println(age)\n}",
                  "explanation": "Fonksiyon tek bir parametre alabilir."
                },
                {
                  "title": "Birden Fazla Parametre",
                  "code": "fun sum(a: Int, b: Int): Int {\n    return a + b\n}",
                  "explanation": "Fonksiyon birden fazla parametre alabilir."
                },
                {
                  "title": "Unit Dönüş Tipi",
                  "code": "fun showMessage(message: String): Unit {\n    println(message)\n}",
                  "explanation": "Değer döndürmeyen fonksiyonların dönüş tipi Unit'tir."
                },
                {
                  "title": "Varsayılan Parametre",
                  "code": "fun greet(name: String = \"Misafir\") {\n    println(\"Merhaba $name\")\n}",
                  "explanation": "Parametreye varsayılan değer atanabilir."
                },
                {
                  "title": "İsimli Parametre Kullanımı",
                  "code": "greet(name = \"Ahmet\")",
                  "explanation": "Parametreler isimleriyle çağrılabilir."
                }
              ],
              "keyPoints": [
                "Parametreler fonksiyonlara veri aktarır",
                "Parametre tipleri belirtilmelidir",
                "Fonksiyonlar değer döndürebilir veya Unit döndürür",
                "Varsayılan parametreler kullanılabilir",
                "İsimli parametreler okunabilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 140201,
                  "question": "Fonksiyonlara dışarıdan veri göndermek için ne kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Return",
                    "Parametre",
                    "Variable",
                    "Unit"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlara veri parametreler aracılığıyla gönderilir.",
                  "tags": ["parameters"]
                },
                {
                  "questionId": 140202,
                  "question": "Değer döndürmeyen fonksiyonların dönüş tipi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Void",
                    "Null",
                    "Unit",
                    "None"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de değer döndürmeyen fonksiyonların dönüş tipi Unit'tir.",
                  "tags": ["unit"]
                },
                {
                  "questionId": 140203,
                  "question": "Aşağıdaki fonksiyonlardan hangisi varsayılan parametre kullanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "fun test(a: Int)",
                    "fun test(a: Int = 5)",
                    "fun test(a)",
                    "fun test(): Int"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Varsayılan parametre, parametreye başlangıç değeri verilerek tanımlanır.",
                  "tags": ["default-parameters"]
                },
                {
                  "questionId": 140204,
                  "question": "İsimli parametrelerin en büyük avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performansı artırmak",
                    "Hafıza kullanımını azaltmak",
                    "Kod okunabilirliğini artırmak",
                    "Daha az parametre kullanmak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "İsimli parametreler, fonksiyon çağrılarını daha okunabilir yapar.",
                  "tags": ["named-parameters"]
                },
                {
                  "questionId": 140205,
                  "question": "Bir fonksiyonun dönüş tipini belirtmek için hangi sembol kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "=",
                    "->",
                    ":",
                    "::"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Fonksiyon dönüş tipi iki nokta (:) ile belirtilir.",
                  "tags": ["return-type"]
                }
              ]
            },
            {
              "topicId": 1403,
              "title": "Null Safety",
              "summary": "Null Safety, Kotlin'in null referans hatalarını (NullPointerException) önlemek için sunduğu bir güvenlik mekanizmasıdır. Kotlin'de bir değişken varsayılan olarak null olamaz, bu da uygulamaların daha güvenli çalışmasını sağlar.",
              "content": "## Null Safety\n\nKotlin'de değişkenler varsayılan olarak null olamaz. Eğer bir değişkenin null değer alabilmesini istiyorsak, tipinin sonuna `?` eklememiz gerekir.\n\nKotlin, null değerlerle güvenli çalışmak için çeşitli operatörler sunar:\n\n- `?` : Nullable değişken\n- `?.` : Safe call (güvenli çağrı)\n- `?:` : Elvis operatörü (varsayılan değer)\n- `!!` : Not-null assertion (risklidir)\n\nBu yapı sayesinde NullPointerException hataları büyük ölçüde engellenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Nullable Değişken",
                  "code": "var name: String? = null",
                  "explanation": "String? ifadesi değişkenin null olabileceğini belirtir."
                },
                {
                  "title": "Safe Call (?.)",
                  "code": "val length = name?.length",
                  "explanation": "Eğer name null ise hata vermez, sonuç null olur."
                },
                {
                  "title": "Elvis Operatörü (?:)",
                  "code": "val length = name?.length ?: 0",
                  "explanation": "Eğer name null ise varsayılan olarak 0 atanır."
                },
                {
                  "title": "Not-Null Assertion (!!)",
                  "code": "val length = name!!.length",
                  "explanation": "name null ise uygulama çöker. Dikkatli kullanılmalıdır."
                },
                {
                  "title": "if ile Null Kontrolü",
                  "code": "if (name != null) {\n    println(name.length)\n}",
                  "explanation": "Klasik null kontrolü yapılabilir."
                }
              ],
              "keyPoints": [
                "Kotlin'de değişkenler varsayılan olarak null olamaz",
                "Nullable değişkenler ? ile tanımlanır",
                "Safe call (?.) NullPointerException'ı önler",
                "Elvis operatörü varsayılan değer sağlar",
                "!! operatörü risklidir ve önerilmez"
              ],
              "questions": [
                {
                  "questionId": 140301,
                  "question": "Kotlin'de bir değişkenin null olabilmesi için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val kullanmak",
                    "var kullanmak",
                    "Tipin sonuna ? eklemek",
                    "!! kullanmak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Nullable değişkenler ? ile tanımlanır.",
                  "tags": ["null-safety"]
                },
                {
                  "questionId": 140302,
                  "question": "Safe call operatörü hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "!!",
                    "?:",
                    "?.",
                    "::"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "?. operatörü null güvenli çağrı sağlar.",
                  "tags": ["safe-call"]
                },
                {
                  "questionId": 140303,
                  "question": "Aşağıdaki kodda name null ise length değeri ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val name: String? = null\nval length = name?.length ?: 0",
                  "difficulty": "medium",
                  "options": [
                    "null",
                    "Hata verir",
                    "0",
                    "1"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Elvis operatörü sayesinde null durumda 0 atanır.",
                  "tags": ["elvis-operator"]
                },
                {
                  "questionId": 140304,
                  "question": "!! operatörü ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Null kontrolü yapar",
                    "Null ise varsayılan değer atar",
                    "Null değilse çalışır, null ise crash olur",
                    "Her zaman güvenlidir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "!! operatörü null ise NullPointerException fırlatır.",
                  "tags": ["not-null-assertion"]
                },
                {
                  "questionId": 140305,
                  "question": "Null Safety'nin temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kod yazmayı zorlaştırmak",
                    "Daha fazla değişken oluşturmak",
                    "NullPointerException hatalarını önlemek",
                    "Performansı düşürmek"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Null Safety, NullPointerException hatalarını minimize eder.",
                  "tags": ["null-safety", "best-practice"]
                }
              ]
            },
            {
              "topicId": 1404,
              "title": "lateinit ve lazy",
              "summary": "lateinit ve lazy, Kotlin'de değişkenlerin geç (sonradan) başlatılmasını sağlayan iki farklı yaklaşımdır. lateinit mutable değişkenler için kullanılırken, lazy immutable değişkenler için kullanılır.",
              "content": "## lateinit ve lazy\n\nKotlin'de normalde bir değişken tanımlandığında hemen başlatılmalıdır. Ancak bazı durumlarda değişkenin değeri daha sonra atanır.\n\nBu durumlar için Kotlin iki çözüm sunar:\n\n- **lateinit**: var ile kullanılan, daha sonra başlatılacak değişkenler için\n- **lazy**: val ile kullanılan, ilk erişimde başlatılan değişkenler için\n\nAndroid geliştirmede özellikle ViewBinding, Activity ve Fragment yapılarında sıkça kullanılır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "lateinit Kullanımı",
                  "code": "lateinit var name: String\n\nfun initName() {\n    name = \"Ahmet\"\n}",
                  "explanation": "lateinit, var ile kullanılır ve sonradan değer atanır."
                },
                {
                  "title": "lateinit Kontrolü",
                  "code": "if (::name.isInitialized) {\n    println(name)\n}",
                  "explanation": "lateinit değişkenin başlatılıp başlatılmadığı kontrol edilebilir."
                },
                {
                  "title": "lazy Kullanımı",
                  "code": "val age: Int by lazy {\n    25\n}",
                  "explanation": "lazy, değişken ilk kez kullanıldığında çalışır."
                },
                {
                  "title": "lazy Çalışma Mantığı",
                  "code": "val message: String by lazy {\n    println(\"Initialized\")\n    \"Merhaba\"\n}",
                  "explanation": "lazy blok yalnızca ilk erişimde çalışır."
                },
                {
                  "title": "Android Örneği (ViewBinding)",
                  "code": "private lateinit var binding: ActivityMainBinding",
                  "explanation": "Android'de ViewBinding genellikle lateinit ile tanımlanır."
                }
              ],
              "keyPoints": [
                "lateinit sadece var ile kullanılır",
                "lazy sadece val ile kullanılır",
                "lateinit primitive tiplerde kullanılamaz",
                "lazy ilk erişimde çalışır",
                "Android'de ViewBinding için yaygın olarak kullanılır"
              ],
              "questions": [
                {
                  "questionId": 140401,
                  "question": "lateinit hangi değişken türü ile kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val",
                    "const",
                    "var",
                    "let"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lateinit sadece var ile kullanılabilir.",
                  "tags": ["lateinit"]
                },
                {
                  "questionId": 140402,
                  "question": "lazy hangi durumda çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Uygulama başlarken",
                    "Değişken tanımlandığında",
                    "İlk erişildiğinde",
                    "Fonksiyon çağrıldığında"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lazy blok ilk erişimde çalışır.",
                  "tags": ["lazy"]
                },
                {
                  "questionId": 140403,
                  "question": "Aşağıdakilerden hangisi lazy için doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "var ile kullanılır",
                    "Null olabilir",
                    "Sadece val ile kullanılır",
                    "Her zaman hemen çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lazy sadece val ile kullanılır.",
                  "tags": ["lazy"]
                },
                {
                  "questionId": 140404,
                  "question": "lateinit ile ilgili hangisi yanlıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "var ile kullanılır",
                    "Primitive tiplerde kullanılabilir",
                    "Sonradan değer atanır",
                    "Null Safety ile ilişkilidir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "lateinit primitive tiplerde (Int, Boolean vb.) kullanılamaz.",
                  "tags": ["lateinit"]
                },
                {
                  "questionId": 140405,
                  "question": "Android'de ViewBinding genellikle nasıl tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val binding = ActivityMainBinding()",
                    "lateinit var binding",
                    "val binding by lazy",
                    "var binding?"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewBinding genellikle lateinit var ile tanımlanır.",
                  "tags": ["android", "viewbinding"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 16001,
            "question": "Kotlin'de nullable bir değişken nasıl tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "String name",
              "String! name",
              "String? name",
              "nullable String name"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de nullable değişkenler '?' işareti ile tanımlanır.",
            "tags": ["null_safety", "nullable"]
          },
          {
            "questionId": 16002,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "fun printLength(text: String?) {\n    println(text?.length)\n}\n\nprintLength(null)",
            "difficulty": "easy",
            "options": [
              "0",
              "null",
              "Compile-time hatası",
              "Runtime hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe call (?.) kullanıldığı için null durumda hata oluşmaz ve null yazdırılır.",
            "tags": ["safe_call", "null_safety"]
          },
          {
            "questionId": 16003,
            "question": "Elvis operatörü (?:) ne amaçla kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Null kontrolü yapmak",
              "Exception fırlatmak",
              "Null durumunda varsayılan değer vermek",
              "Tip dönüşümü yapmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Elvis operatörü, ifade null ise alternatif bir değer döndürmek için kullanılır.",
            "tags": ["elvis_operator", "null_safety"]
          },
          {
            "questionId": 16004,
            "question": "Aşağıdaki kod çalıştığında ne olur?",
            "questionType": "multiple_choice",
            "code": "val name: String? = null\nprintln(name!!)",
            "difficulty": "medium",
            "options": [
              "null yazdırılır",
              "Boş string yazdırılır",
              "Compile-time hatası",
              "NullPointerException"
            ],
            "correctAnswerIndex": 3,
            "explanation": "!! operatörü null olmayan varsayımı yapar. Değer null olduğu için runtime'da NullPointerException fırlatılır.",
            "tags": ["not_null_assertion", "exception"]
          },
          {
            "questionId": 16005,
            "question": "Aşağıdakilerden hangisi lateinit için doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Primitive tiplerde kullanılabilir",
              "val ile kullanılabilir",
              "Nullable değişkenlerde kullanılır",
              "Sonradan initialize edilen non-null değişkenler için kullanılır"
            ],
            "correctAnswerIndex": 3,
            "explanation": "lateinit, non-null ve sonradan initialize edilecek var değişkenler için kullanılır.",
            "tags": ["lateinit"]
          },
          {
            "questionId": 16006,
            "question": "Aşağıdaki kod neden hatalıdır?",
            "questionType": "multiple_choice",
            "code": "lateinit var age: Int",
            "difficulty": "medium",
            "options": [
              "var yerine val kullanılması gerekir",
              "lateinit sadece String için geçerlidir",
              "Primitive tiplerde kullanılamaz",
              "Int nullable olmadığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "lateinit primitive tiplerde kullanılamaz, sadece reference type'lar için geçerlidir.",
            "tags": ["lateinit", "primitive"]
          },
          {
            "questionId": 16007,
            "question": "lazy delegate ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her erişimde yeniden hesaplanır",
              "Sadece var ile kullanılabilir",
              "İlk erişimde initialize edilir",
              "Nullable değişkenler için zorunludur"
            ],
            "correctAnswerIndex": 2,
            "explanation": "lazy, değişkeni ilk erişimde initialize eder ve sonucu saklar.",
            "tags": ["lazy"]
          },
          {
            "questionId": 16008,
            "question": "Aşağıdaki kodun çıktısı nedir?",
            "questionType": "multiple_choice",
            "code": "val number: Int? = null\nval result = number ?: 10\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "null",
              "0",
              "10",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 2,
            "explanation": "number null olduğu için Elvis operatörü 10 değerini döndürür.",
            "tags": ["elvis_operator"]
          },
          {
            "questionId": 16009,
            "question": "Fonksiyon parametreleri nullable olabilir mi?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Hayır",
              "Sadece varsayılan parametrelerde",
              "Evet, '?' kullanılarak",
              "Sadece lateinit ile"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fonksiyon parametreleri nullable olabilir ve '?' ile belirtilir.",
            "tags": ["function", "nullable"]
          },
          {
            "questionId": 16010,
            "question": "lateinit ve lazy arasındaki temel fark nedir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "lateinit thread-safe'dir, lazy değildir",
              "lateinit var ile, lazy val ile kullanılır",
              "lazy nullable değişkenler içindir",
              "lateinit ilk erişimde initialize olur"
            ],
            "correctAnswerIndex": 1,
            "explanation": "lateinit yalnızca var ile kullanılır, lazy ise val ile ve ilk erişimde initialize edilir.",
            "tags": ["lateinit", "lazy", "difference"]
          }
        ]
        },
        {
          "sectionId": 106,
          "sectionTitle": "Nesne Yönelimli Programlama",
          "sectionDescription": "",
          "order": 6,
          "topics": [
            {
              "topicId": 1501,
              "title": "Sınıflara Giriş (Classlar)",
              "summary": "Sınıflar (class), nesne tabanlı programlamanın temel yapı taşlarıdır. Kotlin'de sınıflar; özellikleri (property) ve davranışları (fonksiyon) bir arada tutarak gerçek hayattaki nesneleri temsil eder.",
              "content": "## Sınıflara Giriş (Classlar)\n\nNesne tabanlı programlamada (OOP), sınıflar bir nesnenin taslağını (şablonunu) temsil eder. Bir sınıftan birden fazla nesne (object) oluşturulabilir.\n\nKotlin'de sınıflar `class` anahtar kelimesi ile tanımlanır. Sınıflar; değişkenler (property) ve fonksiyonlar (method) içerebilir.\n\nAndroid geliştirmede Activity, Fragment, ViewModel gibi tüm yapılar birer sınıftır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Sınıf Tanımı",
                  "code": "class Person {\n    var name: String = \"\"\n    var age: Int = 0\n}",
                  "explanation": "Person sınıfı iki property içerir."
                },
                {
                  "title": "Nesne Oluşturma",
                  "code": "val person = Person()\nperson.name = \"Ahmet\"\nperson.age = 25",
                  "explanation": "Sınıftan bir nesne (object) oluşturulur."
                },
                {
                  "title": "Sınıf İçinde Fonksiyon",
                  "code": "class Car {\n    var brand: String = \"\"\n\n    fun drive() {\n        println(\"Araba sürülüyor\")\n    }\n}",
                  "explanation": "Sınıf içinde fonksiyon tanımlanabilir."
                },
                {
                  "title": "Fonksiyon Çağırma",
                  "code": "val car = Car()\ncar.drive()",
                  "explanation": "Sınıf fonksiyonları nesne üzerinden çağrılır."
                },
                {
                  "title": "Birden Fazla Nesne",
                  "code": "val p1 = Person()\nval p2 = Person()",
                  "explanation": "Aynı sınıftan birden fazla nesne oluşturulabilir."
                }
              ],
              "keyPoints": [
                "Sınıflar OOP'nin temel yapı taşıdır",
                "class anahtar kelimesi ile tanımlanır",
                "Sınıflardan nesneler (object) oluşturulur",
                "Sınıflar property ve fonksiyon içerir",
                "Android'deki her yapı aslında bir sınıftır"
              ],
              "questions": [
                {
                  "questionId": 150101,
                  "question": "Kotlin'de sınıf tanımlamak için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "object",
                    "class",
                    "struct",
                    "type"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de sınıflar class anahtar kelimesi ile tanımlanır.",
                  "tags": ["class", "oop"]
                },
                {
                  "questionId": 150102,
                  "question": "Bir sınıftan oluşturulan örneğe ne ad verilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Method",
                    "Property",
                    "Object",
                    "Package"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sınıftan oluşturulan her örnek bir object'tir.",
                  "tags": ["object", "oop"]
                },
                {
                  "questionId": 150103,
                  "question": "Aşağıdakilerden hangisi sınıf içinde bulunabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece değişken",
                    "Sadece fonksiyon",
                    "Değişken ve fonksiyon",
                    "Sadece constructor"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sınıflar hem property hem fonksiyon içerebilir.",
                  "tags": ["class"]
                },
                {
                  "questionId": 150104,
                  "question": "Aşağıdaki ifadelerden hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Bir sınıftan sadece bir nesne oluşturulur",
                    "Sınıflar sadece veri tutar",
                    "Bir sınıftan birden fazla nesne oluşturulabilir",
                    "Sınıflar fonksiyon içeremez"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Aynı sınıftan birden fazla nesne oluşturulabilir.",
                  "tags": ["oop"]
                },
                {
                  "questionId": 150105,
                  "question": "Android'de Activity ve Fragment ne tür yapılardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fonksiyon",
                    "Değişken",
                    "Sınıf",
                    "Paket"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Activity ve Fragment, Kotlin'de sınıf olarak tanımlanır.",
                  "tags": ["android", "class"]
                }
              ]
            },
            {
              "topicId": 1502,
              "title": "Constructor",
              "summary": "Constructor, bir sınıftan nesne oluşturulurken çalışan özel bir yapıdır. Kotlin'de constructor'lar sayesinde sınıfın başlangıç değerleri belirlenir ve nesne oluşturma süreci kontrol altına alınır.",
              "content": "## Constructor (Yapıcı Metot)\n\nConstructor, bir sınıftan nesne oluşturulduğu anda otomatik olarak çalışan özel bir fonksiyondur. Kotlin'de constructor kullanımı oldukça basittir ve genellikle sınıf başlığında tanımlanır.\n\nKotlin'de iki tür constructor vardır:\n- Primary Constructor (Birincil)\n- Secondary Constructor (İkincil)\n\nPrimary constructor sınıf başlığında tanımlanır ve en çok kullanılan yöntemdir. Secondary constructor ise ek senaryolar için kullanılır.\n\nAndroid geliştirmede model sınıfları, ViewModel'ler ve adapter yapıları constructor mantığına dayanır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Primary Constructor",
                  "code": "class User(val name: String, val age: Int)",
                  "explanation": "Primary constructor sınıf başlığında tanımlanır."
                },
                {
                  "title": "Nesne Oluşturma",
                  "code": "val user = User(\"Ahmet\", 25)",
                  "explanation": "Constructor parametreleri nesne oluştururken gönderilir."
                },
                {
                  "title": "Init Bloğu",
                  "code": "class Product(val price: Int) {\n    init {\n        println(\"Ürün fiyatı: $price\")\n    }\n}",
                  "explanation": "init bloğu constructor çalıştığında otomatik olarak tetiklenir."
                },
                {
                  "title": "Secondary Constructor",
                  "code": "class Car {\n    var brand: String\n\n    constructor(brand: String) {\n        this.brand = brand\n    }\n}",
                  "explanation": "Secondary constructor, class içinde constructor anahtar kelimesi ile tanımlanır."
                },
                {
                  "title": "Birden Fazla Constructor",
                  "code": "class Person(val name: String) {\n    var age: Int = 0\n\n    constructor(name: String, age: Int) : this(name) {\n        this.age = age\n    }\n}",
                  "explanation": "Secondary constructor, primary constructor'ı çağırmak zorundadır."
                }
              ],
              "keyPoints": [
                "Constructor nesne oluşturulurken çalışır",
                "Primary constructor en çok kullanılan yöntemdir",
                "init bloğu constructor ile birlikte çalışır",
                "Secondary constructor ek senaryolar için kullanılır",
                "Android model sınıfları constructor yapısını yoğun kullanır"
              ],
              "questions": [
                {
                  "questionId": 150201,
                  "question": "Constructor ne zaman çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sınıf tanımlandığında",
                    "Fonksiyon çağrıldığında",
                    "Nesne oluşturulduğunda",
                    "Uygulama kapandığında"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Constructor, sınıftan nesne oluşturulduğu anda çalışır.",
                  "tags": ["constructor", "oop"]
                },
                {
                  "questionId": 150202,
                  "question": "Primary constructor nerede tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fonksiyon içinde",
                    "Sınıf başlığında",
                    "init bloğunda",
                    "Companion object içinde"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Primary constructor sınıf başlığında tanımlanır.",
                  "tags": ["constructor"]
                },
                {
                  "questionId": 150203,
                  "question": "init bloğu ne zaman çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Uygulama açıldığında",
                    "Fonksiyon çağrıldığında",
                    "Constructor çalıştığında",
                    "Sınıf silindiğinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "init bloğu constructor ile birlikte otomatik olarak çalışır.",
                  "tags": ["init", "constructor"]
                },
                {
                  "questionId": 150204,
                  "question": "Secondary constructor hangi anahtar kelime ile tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "init",
                    "class",
                    "new",
                    "constructor"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Secondary constructor, constructor anahtar kelimesi ile tanımlanır.",
                  "tags": ["constructor"]
                },
                {
                  "questionId": 150205,
                  "question": "Secondary constructor için aşağıdakilerden hangisi zorunludur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "init bloğu çağırmak",
                    "Primary constructor'ı çağırmak",
                    "open sınıf olmak",
                    "abstract sınıf olmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Secondary constructor, primary constructor'ı çağırmak zorundadır.",
                  "tags": ["oop", "constructor"]
                }
              ]
            },
            {
              "topicId": 1503,
              "title": "Encapsulation",
              "summary": "Encapsulation (kapsülleme), nesneye ait verilerin doğrudan erişime kapatılması ve kontrollü bir şekilde dışarıya açılması prensibidir. Kotlin'de bu işlem access modifier'lar ve getter/setter yapıları ile sağlanır.",
              "content": "## Encapsulation (Kapsülleme)\n\nEncapsulation, nesne yönelimli programlamanın (OOP) temel prensiplerinden biridir. Amaç, bir sınıfın iç detaylarını gizleyerek dış dünyaya yalnızca gerekli olan kısmı açmaktır.\n\nKotlin'de encapsulation genellikle **private**, **public**, **protected** gibi erişim belirleyiciler ve **getter/setter** yapıları ile uygulanır.\n\nBu yaklaşım sayesinde:\n- Kod güvenliği artar\n- Hatalı kullanımlar engellenir\n- Sınıflar daha sürdürülebilir hale gelir\n\nAndroid geliştirmede ViewModel, Repository ve Model sınıflarında encapsulation yoğun şekilde kullanılır.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Private Property Kullanımı",
                  "code": "class User {\n    private var password: String = \"1234\"\n\n    fun checkPassword(input: String): Boolean {\n        return input == password\n    }\n}",
                  "explanation": "password değişkeni private olduğu için dışarıdan doğrudan erişilemez."
                },
                {
                  "title": "Public Getter - Private Setter",
                  "code": "class Account {\n    var balance: Int = 0\n        private set\n}",
                  "explanation": "balance değeri dışarıdan okunabilir ama değiştirilemez."
                },
                {
                  "title": "Custom Getter ve Setter",
                  "code": "class Product {\n    var price: Int = 0\n        get() = field\n        set(value) {\n            if (value >= 0) {\n                field = value\n            }\n        }\n}",
                  "explanation": "Setter içinde kontrol yapılarak hatalı değer atamaları engellenir."
                },
                {
                  "title": "Encapsulation ile Veri Koruma",
                  "code": "class BankAccount {\n    private var balance: Int = 0\n\n    fun deposit(amount: Int) {\n        if (amount > 0) balance += amount\n    }\n\n    fun getBalance(): Int = balance\n}",
                  "explanation": "balance sadece sınıf içinden değiştirilebilir, dışarıya kontrollü açılır."
                }
              ],
              "keyPoints": [
                "Encapsulation, veriyi gizleyip kontrollü açma prensibidir",
                "private erişim belirleyicisi sık kullanılır",
                "Getter ve setter ile kontrollü erişim sağlanır",
                "Hatalı veri girişleri engellenir",
                "Kodun güvenliği ve sürdürülebilirliği artar"
              ],
              "questions": [
                {
                  "questionId": 150301,
                  "question": "Encapsulation'ın temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kodu uzatmak",
                    "Veriyi gizlemek ve kontrollü erişim sağlamak",
                    "Daha fazla sınıf oluşturmak",
                    "Sadece performansı artırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Encapsulation, veriyi gizleyip kontrollü erişim sağlamak için kullanılır.",
                  "tags": ["encapsulation", "oop"]
                },
                {
                  "questionId": 150302,
                  "question": "Bir değişkenin dışarıdan erişimini tamamen kapatmak için hangi access modifier kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "public",
                    "protected",
                    "internal",
                    "private"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "private ile tanımlanan değişkenlere sadece sınıf içinden erişilebilir.",
                  "tags": ["access-modifiers"]
                },
                {
                  "questionId": 150303,
                  "question": "Aşağıdaki yapılardan hangisi encapsulation örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Tüm değişkenleri public yapmak",
                    "private property + public method kullanmak",
                    "Her sınıfı abstract yapmak",
                    "Sadece data class kullanmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Veriyi private yapıp kontrollü metotlarla erişmek encapsulation'dır.",
                  "tags": ["encapsulation"]
                },
                {
                  "questionId": 150304,
                  "question": "Aşağıdaki kodda balance neden private tanımlanmıştır?",
                  "questionType": "multiple_choice",
                  "code": "class Account {\n    private var balance = 0\n\n    fun deposit(amount: Int) {\n        balance += amount\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "Performans için",
                    "Dışarıdan doğrudan değiştirilmesini engellemek için",
                    "Derleme süresini kısaltmak için",
                    "Zorunlu olduğu için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Encapsulation sayesinde balance sadece kontrollü şekilde değiştirilebilir.",
                  "tags": ["encapsulation", "security"]
                },
                {
                  "questionId": 150305,
                  "question": "Getter ve setter'ların temel görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sınıf oluşturmak",
                    "Veriyi silmek",
                    "Değişkenlere kontrollü erişim sağlamak",
                    "Inheritance sağlamak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Getter ve setter, değişkenlere kontrollü erişim sağlar.",
                  "tags": ["getter", "setter"]
                }
              ]
            },
            {
              "topicId": 1504,
              "title": "Inheritance",
              "summary": "Inheritance (kalıtım), bir sınıfın başka bir sınıfın özelliklerini ve davranışlarını miras almasını sağlar. Kotlin'de kalıtım, kod tekrarını azaltmak ve sınıflar arasında hiyerarşik bir yapı kurmak için kullanılır.",
              "content": "## Inheritance (Kalıtım)\n\nInheritance, nesne yönelimli programlamanın temel prensiplerinden biridir. Bir sınıfın başka bir sınıftan türemesini sağlar.\n\nKotlin'de bir sınıf varsayılan olarak **final**'dır. Kalıtım yapılabilmesi için **open** anahtar kelimesi kullanılır.\n\nAlt sınıflar (**child / subclass**), üst sınıfın (**parent / superclass**) public ve protected üyelerine erişebilir.\n\nAndroid geliştirmede Activity, Fragment, ViewModel gibi yapılar kalıtımın en yaygın kullanıldığı örneklerdir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Basit Kalıtım Örneği",
                  "code": "open class Animal {\n    fun makeSound() {\n        println(\"Ses çıkarıyor\")\n    }\n}\n\nclass Dog : Animal() {\n    fun bark() {\n        println(\"Hav hav\")\n    }\n}",
                  "explanation": "Dog sınıfı, Animal sınıfından kalıtım alır ve onun fonksiyonlarını kullanabilir."
                },
                {
                  "title": "Constructor ile Kalıtım",
                  "code": "open class Vehicle(val brand: String)\n\nclass Car(brand: String, val doors: Int) : Vehicle(brand)",
                  "explanation": "Alt sınıf, üst sınıfın constructor'ına parametre gönderebilir."
                },
                {
                  "title": "open ve override Kullanımı",
                  "code": "open class Shape {\n    open fun draw() {\n        println(\"Şekil çiziliyor\")\n    }\n}\n\nclass Circle : Shape() {\n    override fun draw() {\n        println(\"Daire çiziliyor\")\n    }\n}",
                  "explanation": "Bir fonksiyon override edilecekse üst sınıfta open olarak tanımlanmalıdır."
                },
                {
                  "title": "super Anahtar Kelimesi",
                  "code": "open class User {\n    open fun getRole() {\n        println(\"User\")\n    }\n}\n\nclass Admin : User() {\n    override fun getRole() {\n        super.getRole()\n        println(\"Admin\")\n    }\n}",
                  "explanation": "super ile üst sınıfın fonksiyonuna erişilebilir."
                }
              ],
              "keyPoints": [
                "Kotlin'de sınıflar varsayılan olarak final'dır",
                "Kalıtım için open anahtar kelimesi gerekir",
                "Alt sınıf, üst sınıfın public ve protected üyelerine erişebilir",
                "override edilen fonksiyonlar open olmalıdır",
                "super anahtar kelimesi ile üst sınıfa erişilir"
              ],
              "questions": [
                {
                  "questionId": 150401,
                  "question": "Kotlin'de bir sınıfın kalıtım alabilmesi için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "abstract",
                    "open",
                    "inherit",
                    "extends"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır. Kalıtım için open kullanılmalıdır.",
                  "tags": ["inheritance", "open"]
                },
                {
                  "questionId": 150402,
                  "question": "Aşağıdakilerden hangisi override edilebilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "final fonksiyon",
                    "private fonksiyon",
                    "open fonksiyon",
                    "local fonksiyon"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sadece open olarak tanımlanan fonksiyonlar override edilebilir.",
                  "tags": ["override"]
                },
                {
                  "questionId": 150403,
                  "question": "super anahtar kelimesi ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Alt sınıfı çağırır",
                    "Üst sınıfın üyelerine erişir",
                    "Yeni nesne oluşturur",
                    "Interface implement eder"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "super, üst sınıfın fonksiyon ve property'lerine erişmek için kullanılır.",
                  "tags": ["super"]
                },
                {
                  "questionId": 150404,
                  "question": "Aşağıdaki kodda hata oluşmasının sebebi nedir?",
                  "questionType": "multiple_choice",
                  "code": "class A\n\nclass B : A()",
                  "difficulty": "medium",
                  "options": [
                    "Constructor eksik",
                    "A sınıfı open değil",
                    "B sınıfı final",
                    "override eksik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "A sınıfı open olmadığı için kalıtım alınamaz.",
                  "tags": ["inheritance", "error"]
                },
                {
                  "questionId": 150405,
                  "question": "Android'de aşağıdakilerden hangisi inheritance örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Activity : AppCompatActivity",
                    "Intent kullanımı",
                    "SharedPreferences",
                    "DataBinding"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Activity'ler genellikle AppCompatActivity'den kalıtım alır.",
                  "tags": ["android", "inheritance"]
                }
              ]
            },
            {
              "topicId": 1505,
              "title": "Polymorphism",
              "summary": "Polymorphism (çok biçimlilik), aynı arayüz veya üst sınıf referansı ile farklı nesnelerin farklı davranışlar sergilemesini sağlar. Kotlin'de polymorphism, inheritance ve override mekanizmaları ile uygulanır.",
              "content": "## Polymorphism (Çok Biçimlilik)\n\nPolymorphism, nesne yönelimli programlamanın temel prensiplerinden biridir. Aynı türden referanslar kullanılarak farklı nesnelerin kendi davranışlarını sergilemesini sağlar.\n\nKotlin'de polymorphism genellikle:\n- open ve override fonksiyonlar\n- Üst sınıf referansı ile alt sınıf nesnesi oluşturma\n- Interface ve abstract class yapıları\n\nüzerinden uygulanır.\n\nAndroid geliştirmede polymorphism; Adapter, ViewModel, Repository ve callback yapılarında sıkça kullanılır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Üst Sınıf Referansı ile Alt Sınıf Nesnesi",
                  "code": "open class Animal {\n    open fun makeSound() {\n        println(\"Ses çıkarıyor\")\n    }\n}\n\nclass Cat : Animal() {\n    override fun makeSound() {\n        println(\"Miyav\")\n    }\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Hav hav\")\n    }\n}",
                  "explanation": "Animal referansı, farklı alt sınıf nesneleri için farklı çıktılar üretir."
                },
                {
                  "title": "Polymorphism Kullanımı",
                  "code": "fun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nanimalSound(Cat())\nanimalSound(Dog())",
                  "explanation": "Fonksiyon, Animal türü alır ama gelen nesneye göre davranış değişir."
                },
                {
                  "title": "Liste Üzerinden Polymorphism",
                  "code": "val animals: List<Animal> = listOf(Cat(), Dog())\n\nfor (animal in animals) {\n    animal.makeSound()\n}",
                  "explanation": "Aynı liste içinde farklı alt sınıflar kendi davranışlarını sergiler."
                },
                {
                  "title": "Android'de Polymorphism Örneği",
                  "code": "open class BaseViewModel\n\nclass MainViewModel : BaseViewModel()\nclass DetailViewModel : BaseViewModel()",
                  "explanation": "ViewModel'lar genellikle ortak bir üst sınıftan türetilir."
                }
              ],
              "keyPoints": [
                "Polymorphism, tek referans ile farklı davranışlar üretir",
                "Inheritance polymorphism için temel şarttır",
                "override edilen fonksiyonlar runtime'da çağrılır",
                "Üst sınıf referansı alt sınıf nesnesini tutabilir",
                "Kod esnekliği ve genişletilebilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 150501,
                  "question": "Polymorphism neyi ifade eder?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Bir sınıfın tek görevi olmasını",
                    "Aynı referans ile farklı davranışlar sergilenmesini",
                    "Sınıfların birbirini çağırmasını",
                    "Sadece interface kullanımını"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism, aynı referans ile farklı nesnelerin farklı davranış göstermesidir.",
                  "tags": ["polymorphism", "oop"]
                },
                {
                  "questionId": 150502,
                  "question": "Aşağıdakilerden hangisi polymorphism için gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Data class",
                    "Inheritance",
                    "Singleton",
                    "Companion object"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism genellikle inheritance ve override ile sağlanır.",
                  "tags": ["inheritance"]
                },
                {
                  "questionId": 150503,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "open class A {\n    open fun print() {\n        println(\"A\")\n    }\n}\n\nclass B : A() {\n    override fun print() {\n        println(\"B\")\n    }\n}\n\nval obj: A = B()\nobj.print()",
                  "difficulty": "medium",
                  "options": [
                    "A",
                    "B",
                    "Compile hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Runtime'da nesnenin gerçek tipi (B) çalışır.",
                  "tags": ["runtime", "override"]
                },
                {
                  "questionId": 150504,
                  "question": "Override edilen fonksiyon ne zaman belirlenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Compile time",
                    "Runtime",
                    "Build time",
                    "Install time"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism runtime binding kullanır.",
                  "tags": ["runtime"]
                },
                {
                  "questionId": 150505,
                  "question": "Android'de Adapter yapılarında polymorphism neden kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI tasarlamak için",
                    "Farklı item tiplerini yönetmek için",
                    "Performansı düşürmek için",
                    "Veritabanı bağlantısı için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Adapter'larda farklı view type'lar polymorphism ile yönetilir.",
                  "tags": ["android", "adapter"]
                }
              ]
            },
            {
              "topicId": 1506,
              "title": "Abstraction",
              "summary": "Abstraction (soyutlama), bir nesnenin sadece gerekli özelliklerini dışarıya sunup detayları gizleme prensibidir. Kotlin'de abstraction, abstract class ve interface yapıları ile uygulanır.",
              "content": "## Abstraction (Soyutlama)\n\nAbstraction, nesne yönelimli programlamanın en önemli prensiplerinden biridir. Amaç, **ne yapıldığını** göstermek, **nasıl yapıldığını** gizlemektir.\n\nKotlin'de abstraction iki temel yapı ile sağlanır:\n\n- **Abstract Class**: Gövdeli ve gövdesiz (abstract) fonksiyonlar içerebilir, state tutabilir.\n- **Interface**: Fonksiyon imzaları tanımlar, çoklu implementasyona izin verir.\n\nAndroid geliştirmede abstraction; Repository, DataSource, Callback, Listener ve Service yapılarında yoğun şekilde kullanılır.",
              "difficulty": "medium",
              "order": 6,
              "codeExamples": [
                {
                  "title": "Abstract Class Örneği",
                  "code": "abstract class Vehicle {\n    abstract fun move()\n\n    fun stop() {\n        println(\"Araç durdu\")\n    }\n}\n\nclass Car : Vehicle() {\n    override fun move() {\n        println(\"Araba hareket ediyor\")\n    }\n}",
                  "explanation": "Abstract class hem gövdeli hem gövdesiz fonksiyonlar içerebilir."
                },
                {
                  "title": "Interface Örneği",
                  "code": "interface Flyable {\n    fun fly()\n}\n\nclass Bird : Flyable {\n    override fun fly() {\n        println(\"Kuş uçuyor\")\n    }\n}",
                  "explanation": "Interface, sınıflara davranış kazandırmak için kullanılır."
                },
                {
                  "title": "Abstract Property Kullanımı",
                  "code": "abstract class Employee {\n    abstract val salary: Int\n}\n\nclass Developer : Employee() {\n    override val salary: Int = 30000\n}",
                  "explanation": "Abstract class'lar abstract property tanımlayabilir."
                },
                {
                  "title": "Android'de Abstraction Örneği",
                  "code": "interface UserRepository {\n    fun getUsers(): List<String>\n}\n\nclass UserRepositoryImpl : UserRepository {\n    override fun getUsers(): List<String> {\n        return listOf(\"Ahmet\", \"Mehmet\")\n    }\n}",
                  "explanation": "Repository pattern abstraction kullanılarak uygulanır."
                }
              ],
              "keyPoints": [
                "Abstraction, detayları gizleyip gerekli kısmı sunar",
                "Abstract class hem state hem fonksiyon içerebilir",
                "Interface çoklu implementasyona izin verir",
                "Abstract class'tan nesne oluşturulamaz",
                "Android mimarilerinde abstraction temel yapı taşıdır"
              ],
              "questions": [
                {
                  "questionId": 150601,
                  "question": "Abstraction'ın temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kodu uzatmak",
                    "Detayları gizleyip gerekli yapıyı sunmak",
                    "Daha fazla sınıf oluşturmak",
                    "Performansı artırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Abstraction, ne yapıldığını gösterip nasıl yapıldığını gizler.",
                  "tags": ["abstraction", "oop"]
                },
                {
                  "questionId": 150602,
                  "question": "Abstract class ile ilgili hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Nesnesi oluşturulabilir",
                    "Sadece abstract fonksiyon içerir",
                    "Hem gövdeli hem gövdesiz fonksiyon içerebilir",
                    "Çoklu kalıtımı destekler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Abstract class'lar hem normal hem abstract fonksiyonlar içerebilir.",
                  "tags": ["abstract-class"]
                },
                {
                  "questionId": 150603,
                  "question": "Interface'lerin en önemli avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "State tutabilmeleri",
                    "Constructor içermeleri",
                    "Çoklu implementasyona izin vermeleri",
                    "Sadece Android'de çalışmaları"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin interface'leri çoklu implementasyona izin verir.",
                  "tags": ["interface"]
                },
                {
                  "questionId": 150604,
                  "question": "Aşağıdakilerden hangisi abstraction örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Concrete class kullanımı",
                    "private değişken tanımlama",
                    "Repository interface kullanımı",
                    "Data class oluşturma"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Repository interface, abstraction'ın en yaygın kullanım alanlarından biridir.",
                  "tags": ["android", "architecture"]
                },
                {
                  "questionId": 150605,
                  "question": "Android mimarilerinde abstraction neden önemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI tasarımı için",
                    "Test edilebilirliği artırmak için",
                    "APK boyutunu küçültmek için",
                    "XML yazmamak için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Abstraction sayesinde kod daha test edilebilir ve sürdürülebilir olur.",
                  "tags": ["mvvm", "clean-architecture"]
                }
              ]
            },
            {
              "topicId": 1507,
              "title": "Visibility Modifiers",
              "summary": "Visibility Modifiers (erişim belirleyiciler), sınıfların, fonksiyonların ve değişkenlerin nerelerden erişilebilir olduğunu belirler. Kotlin'de public, private, protected ve internal olmak üzere dört temel erişim belirleyici bulunur.",
              "content": "## Visibility Modifiers (Erişim Belirleyiciler)\n\nVisibility modifiers, bir sınıfın veya üyenin (property, fonksiyon) hangi kapsamdan erişilebileceğini kontrol eder.\n\nKotlin'de dört temel erişim belirleyici vardır:\n\n- **public**: Her yerden erişilebilir (varsayılan)\n- **private**: Sadece tanımlandığı dosya veya sınıf içinden erişilebilir\n- **protected**: Sadece sınıf ve alt sınıflar tarafından erişilebilir\n- **internal**: Aynı module (modül) içerisinden erişilebilir\n\nDoğru visibility kullanımı, encapsulation ve abstraction prensiplerinin temelini oluşturur.",
              "difficulty": "medium",
              "order": 7,
              "codeExamples": [
                {
                  "title": "Public (Varsayılan) Kullanımı",
                  "code": "class User {\n    val name: String = \"Ahmet\"\n}",
                  "explanation": "public varsayılan olduğu için name her yerden erişilebilir."
                },
                {
                  "title": "Private Kullanımı",
                  "code": "class Account {\n    private var balance: Int = 0\n\n    fun getBalance(): Int {\n        return balance\n    }\n}",
                  "explanation": "balance sadece Account sınıfı içinden erişilebilir."
                },
                {
                  "title": "Protected Kullanımı",
                  "code": "open class Person {\n    protected val age: Int = 30\n}\n\nclass Employee : Person() {\n    fun printAge() {\n        println(age)\n    }\n}",
                  "explanation": "protected üyeler alt sınıflar tarafından erişilebilir."
                },
                {
                  "title": "Internal Kullanımı",
                  "code": "internal class Logger {\n    fun log(message: String) {\n        println(message)\n    }\n}",
                  "explanation": "internal tanımlanan sınıf sadece aynı module içinde erişilebilir."
                },
                {
                  "title": "Constructor Visibility",
                  "code": "class Singleton private constructor() {\n    companion object {\n        val instance = Singleton()\n    }\n}",
                  "explanation": "private constructor ile dışarıdan nesne oluşturulması engellenir."
                }
              ],
              "keyPoints": [
                "Kotlin'de varsayılan visibility public'tir",
                "private en dar erişim seviyesidir",
                "protected sadece inheritance ile çalışır",
                "internal module bazlı erişim sağlar",
                "Doğru visibility kod güvenliğini artırır"
              ],
              "questions": [
                {
                  "questionId": 150701,
                  "question": "Kotlin'de varsayılan visibility modifier hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "private",
                    "protected",
                    "internal",
                    "public"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Kotlin'de herhangi bir modifier belirtilmezse varsayılan olarak public kabul edilir.",
                  "tags": ["visibility", "public"]
                },
                {
                  "questionId": 150702,
                  "question": "Aynı module içinden erişim sağlayan visibility hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "private",
                    "protected",
                    "internal",
                    "public"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "internal modifier, sadece aynı module içinden erişime izin verir.",
                  "tags": ["internal"]
                },
                {
                  "questionId": 150703,
                  "question": "protected modifier hangi durumda anlam kazanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Top-level fonksiyonlarda",
                    "Inheritance (kalıtım) durumunda",
                    "Data class'larda",
                    "Singleton yapısında"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "protected sadece sınıf ve alt sınıflar için geçerlidir.",
                  "tags": ["protected", "inheritance"]
                },
                {
                  "questionId": 150704,
                  "question": "Aşağıdaki kodda hangi üyeye dışarıdan erişilemez?",
                  "questionType": "multiple_choice",
                  "code": "class Test {\n    private val a = 1\n    val b = 2\n}",
                  "difficulty": "easy",
                  "options": [
                    "a",
                    "b",
                    "İkisine de erişilebilir",
                    "Hiçbirine erişilemez"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "private tanımlanan a değişkenine sınıf dışından erişilemez.",
                  "tags": ["private"]
                },
                {
                  "questionId": 150705,
                  "question": "Android projelerinde internal genellikle ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI bileşenleri",
                    "Test edilebilirliği artırmak",
                    "Module içi sınıfları sınırlamak",
                    "Veritabanı tabloları"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "internal, module sınırları içinde erişimi kısıtlamak için kullanılır.",
                  "tags": ["android", "module"]
                }
              ]
            }

          ],
          "sectionMixedQuestions": [
          {
            "questionId": 17001,
            "question": "Kotlin'de bir sınıf (class) nasıl tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "class MyClass {}",
              "MyClass class {}",
              "define class MyClass {}",
              "object MyClass {}"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de sınıflar 'class' anahtar kelimesi ile tanımlanır.",
            "tags": ["class", "oop"]
          },
          {
            "questionId": 17002,
            "question": "Primary constructor aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "class User { constructor(name: String) {} }",
              "class User(name: String)",
              "fun constructor() {}",
              "init(name: String)"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Primary constructor, class tanımının yanında parantez içinde tanımlanır.",
            "tags": ["constructor", "primary_constructor"]
          },
          {
            "questionId": 17003,
            "question": "Encapsulation'ın temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Kodun daha hızlı çalışmasını sağlamak",
              "Sınıflar arası kalıtım sağlamak",
              "Veriyi dış müdahalelere karşı korumak",
              "Aynı isimli fonksiyonları kullanmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Encapsulation, sınıf içindeki veriyi private yaparak kontrollü erişim sağlamayı amaçlar.",
            "tags": ["encapsulation", "oop"]
          },
          {
            "questionId": 17004,
            "question": "Aşağıdaki visibility modifier'lardan hangisi sadece aynı sınıf içinde erişime izin verir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "public",
              "internal",
              "protected",
              "private"
            ],
            "correctAnswerIndex": 3,
            "explanation": "private, yalnızca tanımlandığı sınıf içinde erişilebilir.",
            "tags": ["visibility", "private"]
          },
          {
            "questionId": 17005,
            "question": "Kotlin'de inheritance (kalıtım) için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "extends",
              "inherits",
              ":",
              "implements"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de bir sınıf başka bir sınıftan ':' operatörü ile türetilir.",
            "tags": ["inheritance"]
          },
          {
            "questionId": 17006,
            "question": "Bir sınıfın miras alınabilmesi için hangi anahtar kelime ile işaretlenmesi gerekir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "abstract",
              "open",
              "public",
              "override"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır. Miras alınabilmesi için open olarak tanımlanmalıdır.",
            "tags": ["open", "inheritance"]
          },
          {
            "questionId": 17007,
            "question": "Polymorphism aşağıdakilerden hangisini ifade eder?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Bir sınıfın birden fazla constructor'a sahip olması",
              "Aynı fonksiyonun farklı davranışlar sergilemesi",
              "Sınıfların gizlenmesi",
              "Verilerin kapsüllenmesi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Polymorphism, aynı isimli fonksiyonların farklı sınıflarda farklı davranışlar göstermesidir.",
            "tags": ["polymorphism"]
          },
          {
            "questionId": 17008,
            "question": "Aşağıdakilerden hangisi abstraction için doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Abstract class instance alınabilir",
              "Abstract fonksiyonların gövdesi olmak zorundadır",
              "Detayları gizleyip sadece gerekli yapıyı sunar",
              "Sadece interface ile yapılır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Abstraction, karmaşık detayları gizleyerek kullanıcıya sade bir yapı sunar.",
            "tags": ["abstraction"]
          },
          {
            "questionId": 17009,
            "question": "Aşağıdaki kodda hangi OOP prensibi uygulanmaktadır?",
            "questionType": "multiple_choice",
            "code": "open class Animal {\n    open fun sound() {}\n}\n\nclass Dog : Animal() {\n    override fun sound() {}\n}",
            "difficulty": "hard",
            "options": [
              "Encapsulation",
              "Inheritance",
              "Polymorphism",
              "Abstraction"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Aynı fonksiyonun (sound) farklı sınıflarda farklı şekilde override edilmesi polymorphism örneğidir.",
            "tags": ["polymorphism", "override"]
          },
          {
            "questionId": 17010,
            "question": "protected visibility modifier ne anlama gelir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her yerden erişilebilir",
              "Sadece aynı dosya içinden erişilebilir",
              "Sadece aynı sınıf ve alt sınıflardan erişilebilir",
              "Sadece aynı modülden erişilebilir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "protected, tanımlandığı sınıf ve o sınıftan türeyen alt sınıflar tarafından erişilebilir.",
            "tags": ["protected", "visibility"]
          }
        ]
        },
        {
          "sectionId": 107,
          "sectionTitle": "Fonksiyonel Programlama",
          "sectionDescription": "",
          "order": 7,
          "topics": [
            {
              "topicId": 1601,
              "title": "Lambda",
              "summary": "Lambda, isimsiz (anonim) fonksiyonlardır ve fonksiyonel programlamanın temel yapı taşlarından biridir. Kotlin'de lambda ifadeleri, fonksiyonları değişken gibi kullanmayı ve daha okunabilir, esnek kod yazmayı sağlar.",
              "content": "## Lambda\n\nLambda ifadeleri, kısa ve tek kullanımlık fonksiyonlar tanımlamak için kullanılır. Kotlin'de fonksiyonlar birer first-class citizen'dır, yani değişkenlere atanabilir, parametre olarak gönderilebilir ve fonksiyondan döndürülebilir.\n\nLambda yapısı:\n\n```\n{ parametreler -> işlem }\n```\n\nLambda'lar genellikle collection işlemleri, callback yapıları ve asenkron işlemlerde kullanılır.\n\nAndroid geliştirmede onClick listener'lar, adapter callback'leri ve higher-order function'lar lambda kullanımının en yaygın örnekleridir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Lambda Tanımı",
                  "code": "val sum = { a: Int, b: Int -> a + b }\n\nprintln(sum(3, 5))",
                  "explanation": "Lambda bir değişkene atanabilir ve fonksiyon gibi çağrılabilir."
                },
                {
                  "title": "Tek Parametreli Lambda (it)",
                  "code": "val printNumber: (Int) -> Unit = { println(it) }\n\nprintNumber(10)",
                  "explanation": "Tek parametre varsa it anahtar kelimesi kullanılabilir."
                },
                {
                  "title": "Fonksiyon Parametresi Olarak Lambda",
                  "code": "fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nval result = calculate(4, 2) { x, y -> x * y }",
                  "explanation": "Fonksiyonlar parametre olarak lambda alabilir."
                },
                {
                  "title": "Android'de Lambda Kullanımı",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "explanation": "Listener yapıları lambda ile sadeleşir."
                }
              ],
              "keyPoints": [
                "Lambda ifadeleri isimsiz fonksiyonlardır",
                "Fonksiyonlar Kotlin'de first-class citizen'dır",
                "Lambda'lar değişkene atanabilir",
                "Fonksiyonlara parametre olarak gönderilebilir",
                "Android callback'lerinde yaygın kullanılır"
              ],
              "questions": [
                {
                  "questionId": 160101,
                  "question": "Lambda ifadesi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "İsimli fonksiyon",
                    "Anonim (isimsiz) fonksiyon",
                    "Sadece Android'e özel yapı",
                    "Class türü"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda, isimsiz fonksiyonlardır.",
                  "tags": ["lambda", "functional"]
                },
                {
                  "questionId": 160102,
                  "question": "Tek parametreli lambda'da hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "this",
                    "param",
                    "it",
                    "self"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Tek parametreli lambda'da it kullanılır.",
                  "tags": ["lambda"]
                },
                {
                  "questionId": 160103,
                  "question": "Aşağıdakilerden hangisi doğru lambda tanımıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "{ a, b => a + b }",
                    "{ a: Int, b: Int -> a + b }",
                    "(a, b) -> a + b",
                    "lambda(a, b)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de lambda tanımı bu şekildedir.",
                  "tags": ["syntax"]
                },
                {
                  "questionId": 160104,
                  "question": "Lambda'lar genellikle hangi yapılarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "XML layout",
                    "Callback ve collection işlemleri",
                    "Manifest dosyası",
                    "Gradle script"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda'lar callback ve collection işlemlerinde yaygındır.",
                  "tags": ["collections", "callback"]
                },
                {
                  "questionId": 160105,
                  "question": "Android'de lambda kullanımının avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha fazla kod yazmak",
                    "Okunabilirliği ve sadeliği artırmak",
                    "Sadece performans kazanmak",
                    "Java uyumluluğunu kaldırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda, boilerplate kodu azaltır ve okunabilirliği artırır.",
                  "tags": ["android", "lambda"]
                }
              ]
            },
            {
              "topicId": 1602,
              "title": "Map ve Filter",
              "summary": "Map ve Filter, koleksiyonlar üzerinde veri dönüştürme ve filtreleme işlemleri yapmak için kullanılan fonksiyonel programlama araçlarıdır. Kotlin'de okunabilir ve temiz kod yazmayı sağlar.",
              "content": "## Map ve Filter\n\nMap fonksiyonu, bir koleksiyondaki her elemanı dönüştürerek yeni bir koleksiyon oluşturur.\n\nFilter fonksiyonu ise belirli bir koşulu sağlayan elemanları seçerek yeni bir koleksiyon döndürür.\n\nBu fonksiyonlar orijinal koleksiyonu değiştirmez, immutable yapıyı korur.\n\nAndroid geliştirmede listeleme, arama, veri dönüştürme ve UI'ya uygun veri hazırlama işlemlerinde sıkça kullanılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Map Kullanımı",
                  "code": "val numbers = listOf(1, 2, 3, 4)\n\nval doubled = numbers.map { it * 2 }\n\nprintln(doubled)",
                  "explanation": "Map, listedeki her elemanı dönüştürür."
                },
                {
                  "title": "Filter Kullanımı",
                  "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nval evenNumbers = numbers.filter { it % 2 == 0 }\n\nprintln(evenNumbers)",
                  "explanation": "Filter, koşulu sağlayan elemanları seçer."
                },
                {
                  "title": "Map + Filter Birlikte",
                  "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nval result = numbers.filter { it > 2 }.map { it * 10 }\n\nprintln(result)",
                  "explanation": "Önce filtreleme sonra dönüştürme yapılır."
                },
                {
                  "title": "Android Kullanım Senaryosu",
                  "code": "val users = listOf(\"Ali\", \"Ayşe\", \"Mehmet\")\n\nval uiList = users.map { it.uppercase() }\n\nprintln(uiList)",
                  "explanation": "UI'da gösterilecek veriler map ile dönüştürülür."
                }
              ],
              "keyPoints": [
                "Map koleksiyon elemanlarını dönüştürür",
                "Filter koşula uyan elemanları seçer",
                "Orijinal koleksiyon değişmez",
                "Fonksiyonel ve okunabilir kod sağlar",
                "Android projelerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 160201,
                  "question": "Map fonksiyonunun temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Elemanları silmek",
                    "Elemanları dönüştürmek",
                    "Listeyi sıralamak",
                    "Listeyi ters çevirmek"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Map, her elemanı dönüştürerek yeni bir koleksiyon oluşturur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 160202,
                  "question": "Filter fonksiyonu ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Elemanları değiştirir",
                    "Koşula uyan elemanları seçer",
                    "Listeyi kopyalar",
                    "Listeyi sıralar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Filter, verilen koşulu sağlayan elemanları döndürür.",
                  "tags": ["filter"]
                },
                {
                  "questionId": 160203,
                  "question": "Aşağıdaki kodun çıktısı nedir?\n\nnumbers.filter { it > 3 }.map { it * 2 }",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "[2, 4, 6]",
                    "[8, 10]",
                    "[4, 6, 8]",
                    "[6, 8, 10]"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Önce 3'ten büyükler seçilir, sonra 2 ile çarpılır.",
                  "tags": ["map", "filter"]
                },
                {
                  "questionId": 160204,
                  "question": "Map ve Filter kullanıldığında koleksiyon nasıl etkilenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Orijinal liste değişir",
                    "Orijinal liste silinir",
                    "Yeni bir liste oluşturulur",
                    "Sadece ilk eleman değişir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map ve Filter yeni bir koleksiyon döndürür.",
                  "tags": ["collections"]
                },
                {
                  "questionId": 160205,
                  "question": "Map & Filter Android'de en çok nerede kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Manifest dosyasında",
                    "Gradle ayarlarında",
                    "UI için veri hazırlamada",
                    "XML layout içinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Veriyi UI'ya uygun hale getirmek için sıkça kullanılır.",
                  "tags": ["android", "functional"]
                }
              ]
            },
            {
              "topicId": 1603,
              "title": "Scope Fonksiyonları",
              "summary": "Scope fonksiyonları, bir nesne üzerinde geçici bir kapsam (scope) oluşturarak daha okunabilir ve düzenli kod yazmayı sağlar. Kotlin'de let, run, apply, also ve with olmak üzere beş adet scope fonksiyonu bulunur.",
              "content": "## Scope Fonksiyonları\n\nScope fonksiyonları bir nesne ile birlikte çalışırken tekrar tekrar nesne adını yazma ihtiyacını ortadan kaldırır.\n\nBu fonksiyonlar, nesneye erişim şekline (this / it) ve geri dönüş tipine göre birbirinden ayrılır.\n\nAndroid geliştirmede null kontrolü, view binding, nesne yapılandırma ve zincirleme işlemler için sıkça kullanılır.\n\n### Scope Fonksiyonları Özeti\n- let → it kullanır, sonuç döndürür\n- run → this kullanır, sonuç döndürür\n- apply → this kullanır, nesnenin kendisini döndürür\n- also → it kullanır, nesnenin kendisini döndürür\n- with → this kullanır, sonuç döndürür (extension değildir)",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "let Kullanımı",
                  "code": "val name: String? = \"Ahmet\"\n\nname?.let {\n    println(it.uppercase())\n}",
                  "explanation": "let genellikle null kontrolü için kullanılır."
                },
                {
                  "title": "run Kullanımı",
                  "code": "val user = \"Kotlin\"\n\nval length = user.run {\n    this.length\n}\n\nprintln(length)",
                  "explanation": "run, this ile erişim sağlar ve sonuç döndürür."
                },
                {
                  "title": "apply Kullanımı",
                  "code": "val list = mutableListOf<String>().apply {\n    add(\"A\")\n    add(\"B\")\n}",
                  "explanation": "apply nesneyi yapılandırmak için kullanılır."
                },
                {
                  "title": "also Kullanımı",
                  "code": "val numbers = mutableListOf(1, 2, 3)\n    .also { println(\"Liste oluşturuldu: $it\") }",
                  "explanation": "also yan işlemler (log, debug) için idealdir."
                },
                {
                  "title": "with Kullanımı",
                  "code": "val user = StringBuilder()\n\nwith(user) {\n    append(\"Hello \")\n    append(\"Kotlin\")\n}\n\nprintln(user.toString())",
                  "explanation": "with bir nesneyle blok halinde çalışmayı sağlar."
                }
              ],
              "keyPoints": [
                "Scope fonksiyonları kod okunabilirliğini artırır",
                "let ve also -> it kullanır",
                "run, apply, with -> this kullanır",
                "apply ve also nesnenin kendisini döndürür",
                "Android projelerinde ViewBinding ve null kontrolünde yaygındır"
              ],
              "questions": [
                {
                  "questionId": 160301,
                  "question": "Hangi scope fonksiyonu null kontrolü için en sık kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "apply",
                    "with",
                    "let",
                    "also"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "let genellikle nullable nesnelerle kullanılır.",
                  "tags": ["scope", "let"]
                },
                {
                  "questionId": 160302,
                  "question": "Hangi scope fonksiyonu nesnenin kendisini döndürür?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "run",
                    "apply",
                    "with",
                    "let"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "apply yapılandırma sonrası nesnenin kendisini döndürür.",
                  "tags": ["apply"]
                },
                {
                  "questionId": 160303,
                  "question": "this anahtar kelimesiyle çalışan scope fonksiyonları hangileridir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "let ve also",
                    "apply ve run",
                    "let ve run",
                    "also ve with"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "apply ve run this ile erişim sağlar.",
                  "tags": ["scope"]
                },
                {
                  "questionId": 160304,
                  "question": "Log veya debug amaçlı en uygun scope fonksiyonu hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "run",
                    "with",
                    "also",
                    "let"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "also yan işlemler için tasarlanmıştır.",
                  "tags": ["also"]
                },
                {
                  "questionId": 160305,
                  "question": "with fonksiyonunun diğerlerinden farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Extension fonksiyon olması",
                    "Nesnenin kendisini döndürmesi",
                    "Extension olmaması",
                    "Null kontrolü yapması"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "with extension değildir, nesne parametre olarak verilir.",
                  "tags": ["with"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 18001,
            "question": "Lambda expression nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "İsimsiz bir sınıf",
              "İsimsiz bir fonksiyon",
              "Bir interface türü",
              "Bir veri tipi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Lambda, isimsiz fonksiyonlardır ve genellikle kısa işlemler için kullanılır.",
            "tags": ["lambda", "functional"]
          },
          {
            "questionId": 18002,
            "question": "Aşağıdakilerden hangisi geçerli bir lambda tanımıdır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "{ x, y -> x + y }",
              "(x, y) => x + y",
              "lambda x y { x + y }",
              "fun(x, y) = x + y"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de lambda tanımı { parametreler -> işlem } şeklindedir.",
            "tags": ["lambda", "syntax"]
          },
          {
            "questionId": 18003,
            "question": "map fonksiyonunun temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Listeyi filtrelemek",
              "Liste elemanlarını dönüştürmek",
              "Listeyi sıralamak",
              "Liste elemanlarını silmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "map, koleksiyonun her elemanını dönüştürerek yeni bir liste oluşturur.",
            "tags": ["map", "collections"]
          },
          {
            "questionId": 18004,
            "question": "filter fonksiyonu ne yapar?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Elemanları dönüştürür",
              "Belirli koşula uyanları seçer",
              "Elemanları gruplar",
              "Listeyi ters çevirir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "filter, verilen koşulu sağlayan elemanlardan yeni bir koleksiyon oluşturur.",
            "tags": ["filter"]
          },
          {
            "questionId": 18005,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val numbers = listOf(1, 2, 3, 4)\nval result = numbers.map { it * 2 }\nprintln(result)",
            "difficulty": "medium",
            "options": [
              "[1, 2, 3, 4]",
              "[2, 4, 6, 8]",
              "[1, 4, 9, 16]",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "map her elemanı 2 ile çarpar ve yeni bir liste döndürür.",
            "tags": ["map"]
          },
          {
            "questionId": 18006,
            "question": "Aşağıdaki scope fonksiyonlarından hangisi 'this' kullanır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "let",
              "also",
              "apply",
              "filter"
            ],
            "correctAnswerIndex": 2,
            "explanation": "apply ve run scope fonksiyonlarında context object 'this' ile temsil edilir.",
            "tags": ["scope_functions", "apply"]
          },
          {
            "questionId": 18007,
            "question": "let scope fonksiyonunun temel kullanım amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Nesneyi yapılandırmak",
              "Yan etkiler oluşturmak",
              "Null kontrolü ve dönüşüm",
              "Thread yönetimi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "let genellikle null kontrolü ve nesne üzerinde işlem yapmak için kullanılır.",
            "tags": ["let", "null_safety"]
          },
          {
            "questionId": 18008,
            "question": "Aşağıdaki kodda hangi scope fonksiyonu kullanılmıştır?",
            "questionType": "multiple_choice",
            "code": "val user = User().apply {\n    name = \"Ahmet\"\n    age = 25\n}",
            "difficulty": "medium",
            "options": [
              "let",
              "run",
              "also",
              "apply"
            ],
            "correctAnswerIndex": 3,
            "explanation": "apply, nesneyi yapılandırmak için kullanılır ve this referansını kullanır.",
            "tags": ["apply", "scope_functions"]
          },
          {
            "questionId": 18009,
            "question": "also scope fonksiyonunun ayırt edici özelliği nedir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "this kullanır",
              "Yeni bir nesne döndürür",
              "Yan etkiler (logging gibi) için kullanılır",
              "Null-safe değildir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "also genellikle loglama gibi yan etkiler için kullanılır ve it referansını kullanır.",
            "tags": ["also"]
          },
          {
            "questionId": 18010,
            "question": "map ve filter birlikte kullanıldığında ne sağlar?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Koleksiyonu sıralar",
              "Koleksiyonu optimize eder",
              "Filtrelenmiş veriyi dönüştürür",
              "Sadece performans artışı sağlar"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Önce filter ile elemanlar seçilir, ardından map ile dönüştürülür. Bu, fonksiyonel programlamanın temel desenidir.",
            "tags": ["map", "filter", "functional"]
          }
        ]
        },
        {
          "sectionId": 1700,
          "sectionTitle": "Hata Yönetimi",
          "sectionDescription": "Uygulama çalışırken oluşabilecek hataların yakalanması, yönetilmesi ve debug edilmesi",
          "order": 7,
          "topics": [
            {
              "topicId": 1701,
              "title": "try-catch",
              "summary": "try-catch yapısı, çalışma zamanında (runtime) oluşabilecek hataları yakalayarak uygulamanın çökmesini engeller. Kotlin'de hataya neden olabilecek kodlar try bloğuna yazılır ve oluşan hata catch bloğunda ele alınır.",
              "content": "## try-catch\n\ntry-catch, özellikle kullanıcı girdileri, network işlemleri ve dosya okuma gibi riskli işlemlerde kullanılır.\n\nKotlin'de birden fazla catch bloğu tanımlanabilir ve finally bloğu isteğe bağlıdır.\n\ntry-catch bir expression olarak da kullanılabilir ve değer döndürebilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit try-catch Kullanımı",
                  "code": "try {\n    val number = \"10a\".toInt()\n} catch (e: NumberFormatException) {\n    println(\"Hatalı sayı formatı\")\n}",
                  "explanation": "String değeri Int'e çevrilirken hata oluşur ve catch bloğu çalışır."
                },
                {
                  "title": "try-catch Expression",
                  "code": "val result = try {\n    10 / 2\n} catch (e: Exception) {\n    0\n}",
                  "explanation": "try-catch bir değer döndürebilir."
                }
              ],
              "keyPoints": [
                "Runtime hatalarını yakalamak için kullanılır",
                "Birden fazla catch bloğu yazılabilir",
                "finally isteğe bağlıdır",
                "try-catch expression olarak kullanılabilir"
              ],
              "questions": [
                {
                  "questionId": 170101,
                  "question": "try-catch yapısının temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Compile-time hataları yakalamak",
                    "Runtime hataları yakalamak",
                    "Performansı artırmak",
                    "Değişken tanımlamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "try-catch runtime sırasında oluşan hataları yakalamak için kullanılır.",
                  "tags": ["try-catch"]
                }
              ]
            },
            {
              "topicId": 1702,
              "title": "Exception",
              "summary": "Exception, uygulama çalışırken meydana gelen beklenmeyen hataları temsil eden nesnelerdir. Kotlin'de tüm exception'lar Exception sınıfından türetilir.",
              "content": "## Exception\n\nException'lar programın normal akışını bozar.\n\nKotlin'de checked exception yoktur, bu da kodu daha sade hale getirir.\n\nGeliştirici isterse kendi custom exception sınıflarını da oluşturabilir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Exception Fırlatma",
                  "code": "fun divide(a: Int, b: Int): Int {\n    if (b == 0) {\n        throw IllegalArgumentException(\"Bölen 0 olamaz\")\n    }\n    return a / b\n}",
                  "explanation": "Hatalı durumlarda manuel olarak exception fırlatılabilir."
                }
              ],
              "keyPoints": [
                "Tüm exception'lar Exception sınıfından türetilir",
                "Kotlin'de checked exception yoktur",
                "throw ile manuel exception fırlatılabilir",
                "Custom exception tanımlanabilir"
              ],
              "questions": [
                {
                  "questionId": 170201,
                  "question": "Kotlin'de checked exception var mı?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet",
                    "Hayır",
                    "Sadece Android'de var",
                    "Sadece JVM'de var"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de checked exception yoktur.",
                  "tags": ["exception"]
                }
              ]
            },
            {
              "topicId": 1703,
              "title": "Debug Mantığı",
              "summary": "Debug mantığı, uygulamada oluşan hataların nedenini bulmak ve çözmek için kullanılan sistematik yaklaşımdır. Loglama, breakpoint ve stack trace analizi bu sürecin temel parçalarıdır.",
              "content": "## Debug Mantığı\n\nDebug sürecinde hatanın nerede ve neden oluştuğu analiz edilir.\n\nAndroid Studio debugger, Logcat ve stack trace bu süreçte en önemli araçlardır.\n\nHataları sadece çözmek değil, tekrar oluşmasını engellemek de hedeflenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Log ile Debug",
                  "code": "Log.d(\"DEBUG\", \"Butona tıklandı\")",
                  "explanation": "Log mesajları uygulamanın akışını takip etmek için kullanılır."
                }
              ],
              "keyPoints": [
                "Breakpoint ile kod adım adım çalıştırılabilir",
                "Stack trace hatanın kaynağını gösterir",
                "Loglama debug sürecini kolaylaştırır",
                "Hatanın kök nedeni bulunmalıdır"
              ],
              "questions": [
                {
                  "questionId": 170301,
                  "question": "Stack trace neyi gösterir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI hatalarını",
                    "Memory kullanımını",
                    "Hatanın oluştuğu çağrı zincirini",
                    "Network trafiğini"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Stack trace hatanın hangi method çağrılarında oluştuğunu gösterir.",
                  "tags": ["debug"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 19001,
            "question": "Kotlin'de hata yakalamak için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "if-else",
              "try-catch",
              "when",
              "throw-catch"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de runtime hataları yakalamak için try-catch bloğu kullanılır.",
            "tags": ["try_catch", "exception"]
          },
          {
            "questionId": 19002,
            "question": "Aşağıdakilerden hangisi runtime exception örneğidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Syntax error",
              "NullPointerException",
              "Import hatası",
              "Derleme uyarısı"
            ],
            "correctAnswerIndex": 1,
            "explanation": "NullPointerException, uygulama çalışırken oluşan bir runtime exception'dır.",
            "tags": ["runtime_exception"]
          },
          {
            "questionId": 19003,
            "question": "Aşağıdaki kodda hangi durumda exception oluşur?",
            "questionType": "multiple_choice",
            "code": "val number = 10\nprintln(number / 0)",
            "difficulty": "easy",
            "options": [
              "Compile-time",
              "ArithmeticException",
              "NullPointerException",
              "Hiçbir hata oluşmaz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Sıfıra bölme işlemi ArithmeticException fırlatır.",
            "tags": ["exception", "arithmetic"]
          },
          {
            "questionId": 19004,
            "question": "Kotlin'de finally bloğunun amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Sadece hata oluştuğunda çalışır",
              "Exception fırlatmak için kullanılır",
              "Her durumda çalışır",
              "Sadece try başarılıysa çalışır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "finally bloğu, exception oluşsa da oluşmasa da her zaman çalışır.",
            "tags": ["finally"]
          },
          {
            "questionId": 19005,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "try {\n    val list = listOf(1, 2, 3)\n    println(list[5])\n} catch (e: Exception) {\n    println(\"Hata\")\n}",
            "difficulty": "medium",
            "options": [
              "5",
              "Compile-time hatası",
              "Hata",
              "Uygulama kapanır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "IndexOutOfBoundsException oluşur ve catch bloğu çalışır.",
            "tags": ["try_catch", "index"]
          },
          {
            "questionId": 19006,
            "question": "Exception fırlatmak için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "throw",
              "throws",
              "exception",
              "error"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de exception fırlatmak için throw anahtar kelimesi kullanılır.",
            "tags": ["throw"]
          },
          {
            "questionId": 19007,
            "question": "Aşağıdakilerden hangisi debug sürecinde en çok kullanılan yöntemlerden biridir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulamayı silip tekrar kurmak",
              "Print/Log kullanmak",
              "Random değerler denemek",
              "Kodları silmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Log veya print kullanımı, hata ayıklamada temel ve etkili bir yöntemdir.",
            "tags": ["debug", "log"]
          },
          {
            "questionId": 19008,
            "question": "Stack trace neyi ifade eder?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulamanın performansını",
              "Hatanın oluştuğu method zincirini",
              "Bellek kullanımını",
              "UI hatalarını"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Stack trace, hatanın hangi method çağrıları sonucunda oluştuğunu gösterir.",
            "tags": ["stacktrace", "debug"]
          },
          {
            "questionId": 19009,
            "question": "Kotlin'de try-catch bir ifade (expression) olarak kullanılabilir mi?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Hayır",
              "Sadece Java'da",
              "Evet",
              "Sadece finally ile"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de try-catch bir expression'dır ve değer döndürebilir.",
            "tags": ["expression", "try_catch"]
          },
          {
            "questionId": 19010,
            "question": "En sağlıklı debug yaklaşımı aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Deneme-yanılma",
              "Breakpoint ve adım adım inceleme",
              "Kodun tamamını yazmak",
              "Exception'ları görmezden gelmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Breakpoint kullanarak kodu adım adım incelemek, hatanın kök nedenini bulmada en etkili yöntemdir.",
            "tags": ["debug", "breakpoint"]
          }
        ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 90001,
          "question": "Kotlin'de değiştirilemeyen değişken hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["var", "val", "let", "const"],
          "correctAnswerIndex": 1,
          "explanation": "val immutable değişkenler için kullanılır.",
          "tags": ["val", "variables"]
        },
        {
          "questionId": 90002,
          "question": "Aşağıdaki veri tiplerinden hangisi kesirli sayı tutar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["Int", "Long", "Float", "Boolean"],
          "correctAnswerIndex": 2,
          "explanation": "Float ve Double kesirli sayılar içindir.",
          "tags": ["float", "double"]
        },
        {
          "questionId": 90003,
          "question": "when yapısı neyin alternatifidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["for", "while", "if-else zinciri", "try-catch"],
          "correctAnswerIndex": 2,
          "explanation": "when, if-else zincirlerinin daha okunabilir halidir.",
          "tags": ["when"]
        },
        {
          "questionId": 90004,
          "question": "Aşağıdaki döngülerden hangisi koşul yanlış olsa bile en az bir kez çalışır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["for", "while", "do-while", "repeat"],
          "correctAnswerIndex": 2,
          "explanation": "do-while döngüsü en az bir kez çalışır.",
          "tags": ["loop"]
        },
        {
          "questionId": 90005,
          "question": "Hangi koleksiyon türü benzersiz (unique) elemanlar tutar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["List", "Array", "Set", "Map"],
          "correctAnswerIndex": 2,
          "explanation": "Set aynı elemandan birden fazla tutmaz.",
          "tags": ["set"]
        },
        {
          "questionId": 90006,
          "question": "Map koleksiyonunda veriler nasıl tutulur?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Sadece değer",
            "Index ve değer",
            "Key - Value",
            "Liste şeklinde"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Map key-value yapısıyla çalışır.",
          "tags": ["map"]
        },
        {
          "questionId": 90007,
          "question": "Fonksiyonun bir değer döndürmesini sağlayan yapı hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["print", "return", "break", "continue"],
          "correctAnswerIndex": 1,
          "explanation": "return fonksiyondan değer döndürür.",
          "tags": ["functions"]
        },
        {
          "questionId": 90008,
          "question": "Nullable bir değişken nasıl tanımlanır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["String name", "String! name", "String? name", "nullable String"],
          "correctAnswerIndex": 2,
          "explanation": "Kotlin'de nullable değişkenler '?' ile tanımlanır.",
          "tags": ["null_safety"]
        },
        {
          "questionId": 90009,
          "question": "Elvis operatörü (?:) ne işe yarar?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Null kontrolü yapar",
            "Exception fırlatır",
            "Null ise varsayılan değer döndürür",
            "Tip dönüşümü yapar"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Null durumunda alternatif değer döndürür.",
          "tags": ["elvis"]
        },
        {
          "questionId": 90010,
          "question": "lateinit ile ilgili hangisi doğrudur?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "val ile kullanılır",
            "Primitive tiplerde kullanılır",
            "Sonradan initialize edilir",
            "Nullable olmak zorundadır"
          ],
          "correctAnswerIndex": 2,
          "explanation": "lateinit, non-null var değişkenlerde kullanılır.",
          "tags": ["lateinit"]
        },
        {
          "questionId": 90011,
          "question": "Bir sınıfın miras alınabilmesi için hangi anahtar kelime gerekir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": ["abstract", "open", "override", "protected"],
          "correctAnswerIndex": 1,
          "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır.",
          "tags": ["inheritance"]
        },
        {
          "questionId": 90012,
          "question": "Encapsulation'ın temel amacı nedir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Performans artırmak",
            "Veriyi gizlemek",
            "Kod kısaltmak",
            "UI ayırmak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Encapsulation veri güvenliği sağlar.",
          "tags": ["encapsulation"]
        },
        {
          "questionId": 90013,
          "question": "Polymorphism neyi ifade eder?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Çoklu constructor",
            "Aynı metodun farklı davranışı",
            "Veri gizleme",
            "Tek sorumluluk"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Override edilen fonksiyonlar polymorphism örneğidir.",
          "tags": ["polymorphism"]
        },
        {
          "questionId": 90014,
          "question": "Lambda nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "İsimsiz sınıf",
            "İsimsiz fonksiyon",
            "Interface",
            "Değişken"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Lambda isimsiz fonksiyonlardır.",
          "tags": ["lambda"]
        },
        {
          "questionId": 90015,
          "question": "map fonksiyonu ne yapar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Filtreler",
            "Dönüştürür",
            "Siler",
            "Sıralar"
          ],
          "correctAnswerIndex": 1,
          "explanation": "map her elemanı dönüştürür.",
          "tags": ["map"]
        },
        {
          "questionId": 90016,
          "question": "let scope fonksiyonu genellikle ne için kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Nesne oluşturmak",
            "Yan etki",
            "Null kontrolü",
            "Thread yönetimi"
          ],
          "correctAnswerIndex": 2,
          "explanation": "let genellikle nullable işlemler için kullanılır.",
          "tags": ["scope"]
        },
        {
          "questionId": 90017,
          "question": "Exception fırlatmak için hangi anahtar kelime kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["throw", "throws", "catch", "error"],
          "correctAnswerIndex": 0,
          "explanation": "throw exception fırlatır.",
          "tags": ["exception"]
        },
        {
          "questionId": 90018,
          "question": "finally bloğu ne zaman çalışır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Sadece hata olunca",
            "Sadece try başarılıysa",
            "Her durumda",
            "Hiçbir zaman"
          ],
          "correctAnswerIndex": 2,
          "explanation": "finally her koşulda çalışır.",
          "tags": ["finally"]
        },
        {
          "questionId": 90019,
          "question": "Stack trace neyi gösterir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "UI hatasını",
            "Hata oluşan method zincirini",
            "Performansı",
            "Bellek durumunu"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Stack trace hata yolunu gösterir.",
          "tags": ["debug"]
        },
        {
          "questionId": 90020,
          "question": "Kotlin'de try-catch bir expression olabilir mi?",
          "questionType": "multiple_choice",
          "difficulty": "hard",
          "options": ["Hayır", "Sadece Java'da", "Evet", "Sadece finally ile"],
          "correctAnswerIndex": 2,
          "explanation": "Kotlin'de try-catch değer döndürebilir.",
          "tags": ["try_catch"]
        }
      ]
    },
    {
      "categoryId": 2,
      "categoryTitle": "Android Temelleri",
      "categoryDescription": "Android uygulama geliştirmenin temel kavramları",
      "order": 2,
      "sections": [
        {
          "sectionId": 2100,
          "sectionTitle": "Android’e Giriş",
          "sectionDescription": "Android işletim sisteminin temel yapısı ve Android uygulama geliştirmenin genel mantığı",
          "order": 1,
          "topics": [
            {
              "topicId": 2101,
              "title": "Android Nedir",
              "summary": "Android, Google tarafından geliştirilen, Linux tabanlı, açık kaynaklı bir mobil işletim sistemidir. Akıllı telefonlar, tabletler, TV’ler ve giyilebilir cihazlarda yaygın olarak kullanılır. Android uygulamaları genellikle Kotlin veya Java dili ile geliştirilir.",
              "content": "## Android Nedir\n\nAndroid, mobil cihazlar için geliştirilmiş bir işletim sistemidir.\n\nAçık kaynaklı yapısı sayesinde birçok üretici tarafından özelleştirilerek kullanılır.\n\nAndroid uygulamaları, Android SDK ve Android Studio kullanılarak geliştirilir.\n\nGoogle Play Store, Android uygulamalarının dağıtıldığı resmi platformdur.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Linux tabanlı bir işletim sistemidir",
                "Google tarafından geliştirilir",
                "Açık kaynaklıdır",
                "Kotlin ve Java ile uygulama geliştirilir",
                "Google Play Store üzerinden dağıtılır"
              ],
              "questions": []
            },
            {
              "topicId": 2102,
              "title": "Android Proje Yapısı",
              "summary": "Android proje yapısı, uygulamanın kod, kaynak dosyaları ve konfigürasyonlarının düzenli bir şekilde tutulmasını sağlar. Android Studio’da oluşturulan her proje belirli klasör ve dosya yapısına sahiptir.",
              "content": "## Android Proje Yapısı\n\nAndroid projeleri modüler bir yapıya sahiptir.\n\nTemel olarak Java/Kotlin kodları, XML arayüz dosyaları ve uygulama ayarları ayrı klasörlerde tutulur.\n\nBu yapı, büyük projelerin daha yönetilebilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Temel Proje Yapısı",
                  "code": "app/\n ├─ java/ (veya kotlin/)\n │   └─ MainActivity.kt\n ├─ res/\n │   ├─ layout/\n │   ├─ drawable/\n │   └─ values/\n └─ AndroidManifest.xml",
                  "explanation": "Android projelerinde temel klasör ve dosyaların genel görünümü."
                }
              ],
              "keyPoints": [
                "java/kotlin: Uygulama kodları",
                "res/layout: XML arayüz dosyaları",
                "res/drawable: Görseller",
                "res/values: Renk, stil ve string tanımları",
                "AndroidManifest.xml: Uygulama yapılandırması"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 21001,
              "question": "Android nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Sadece bir mobil uygulama",
                "Bir programlama dili",
                "Linux tabanlı bir mobil işletim sistemi",
                "Sadece Google’a ait bir telefon markası"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Android, Linux çekirdeği üzerine kurulmuş açık kaynaklı bir mobil işletim sistemidir.",
              "tags": ["android", "intro"]
            },
            {
              "questionId": 21002,
              "question": "Android Studio'da bir Android projesi oluşturulduğunda uygulamanın giriş noktası hangi dosyadır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "MainActivity.kt",
                "AndroidManifest.xml",
                "build.gradle",
                "settings.gradle"
              ],
              "correctAnswerIndex": 1,
              "explanation": "AndroidManifest.xml uygulamanın temel bileşenlerini ve giriş noktalarını tanımlar.",
              "tags": ["manifest", "project_structure"]
            },
            {
              "questionId": 21003,
              "question": "Aşağıdakilerden hangisi Android proje yapısında uygulama arayüzlerinin (UI) tanımlandığı klasördür?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "java",
                "res/layout",
                "manifest",
                "gradle"
              ],
              "correctAnswerIndex": 1,
              "explanation": "XML tabanlı arayüz dosyaları res/layout klasörü altında bulunur.",
              "tags": ["layout", "ui"]
            }
          ]
        },
        {

            "sectionId": 2200,
            "sectionTitle": "Layout & UI",
            "sectionDescription": "Android uygulamalarda kullanıcı arayüzü oluşturma ve layout yapıları",
            "order": 2,
            "topics": [
            {
              "topicId": 2201,
              "title": "XML Nedir",
              "summary": "XML, Android'de kullanıcı arayüzlerini tanımlamak için kullanılan işaretleme dilidir. Görünümlerin hiyerarşisi, boyutları ve özellikleri XML dosyaları içerisinde tanımlanır.",
              "content": "## XML Nedir\n\nAndroid'de UI genellikle XML dosyaları ile oluşturulur.\n\nBu yapı, tasarım ve iş mantığını ayırarak kodun daha okunabilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit XML Örneği",
                  "code": "<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Merhaba Android\" />",
                  "explanation": "Basit bir TextView tanımı."
                }
              ],
              "keyPoints": [
                "UI XML ile tanımlanır",
                "Koddan bağımsızdır",
                "Okunabilirliği artırır"
              ],
              "questions": []
            },
            {
              "topicId": 2202,
              "title": "View Nedir",
              "summary": "View, Android'de ekranda görünen en temel UI bileşenidir. Button, TextView, EditText gibi tüm arayüz elemanları View sınıfından türetilir.",
              "content": "## View Nedir\n\nView, kullanıcı ile etkileşime giren temel bileşendir.\n\nTüm UI elemanları View veya ViewGroup'tan türetilir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "UI'nin temel yapı taşıdır",
                "Tıklama ve dokunma olaylarını alır",
                "ViewGroup içinde yer alır"
              ],
              "questions": []
            },
            {
              "topicId": 2203,
              "title": "LinearLayout",
              "summary": "LinearLayout, View'leri yatay veya dikey olarak sıralayan bir layout türüdür. orientation özelliği ile dizilim yönü belirlenir.",
              "content": "## LinearLayout\n\nBasit ve anlaşılır bir layout yapısıdır.\n\nİç içe kullanımı performans sorunlarına yol açabilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "LinearLayout Örneği",
                  "code": "<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView />\n    <Button />\n</LinearLayout>",
                  "explanation": "Dikey dizilimli LinearLayout."
                }
              ],
              "keyPoints": [
                "orientation: vertical / horizontal",
                "Basit dizilimler için idealdir",
                "Derin hiyerarşiden kaçınılmalı"
              ],
              "questions": []
            },
            {
              "topicId": 2204,
              "title": "ConstraintLayout",
              "summary": "ConstraintLayout, View'leri birbirine ve parent'a göre konumlandırmaya olanak tanıyan güçlü bir layout türüdür. Performans açısından en çok önerilen layout yapısıdır.",
              "content": "## ConstraintLayout\n\nEsnek ve performanslıdır.\n\nTek layout içinde karmaşık arayüzler oluşturulabilir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Performans dostudur",
                "Karmaşık UI'lar için idealdir",
                "Constraint mantığı kullanır"
              ],
              "questions": []
            },
            {
              "topicId": 2205,
              "title": "Nested Layout",
              "summary": "Nested Layout, layoutların iç içe kullanılmasıdır. Karmaşık arayüzlerde okunabilirliği artırabilir ancak aşırı kullanımı performans sorunlarına yol açar.",
              "content": "## Nested Layout\n\nİç içe layout kullanımı dikkatli yapılmalıdır.\n\nConstraintLayout bu ihtiyacı büyük ölçüde azaltır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "İç içe layout yapısıdır",
                "Performansı olumsuz etkileyebilir",
                "Alternatif olarak ConstraintLayout önerilir"
              ],
              "questions": []
            },
            {
              "topicId": 2206,
              "title": "View Binding",
              "summary": "View Binding, XML'de tanımlanan view'lara güvenli ve kolay erişim sağlayan bir özelliktir. findViewById kullanımını ortadan kaldırır.",
              "content": "## View Binding\n\nDerleme zamanında binding sınıfları oluşturur.\n\nNull safety sağlar ve kodu sadeleştirir.",
              "difficulty": "easy",
              "order": 6,
              "codeExamples": [
                {
                  "title": "View Binding Kullanımı",
                  "code": "val binding = ActivityMainBinding.inflate(layoutInflater)\nsetContentView(binding.root)\n\nbinding.textView.text = \"Merhaba\"",
                  "explanation": "View Binding ile view erişimi."
                }
              ],
              "keyPoints": [
                "findViewById ihtiyacını kaldırır",
                "Null safety sağlar",
                "Kod okunabilirliğini artırır"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 22001,
              "question": "Android'de XML dosyalarının temel amacı nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Uygulama mantığını yazmak",
                "Veritabanı işlemlerini yapmak",
                "Kullanıcı arayüzünü tanımlamak",
                "Ağ isteklerini yönetmek"
              ],
              "correctAnswerIndex": 2,
              "explanation": "XML, Android'de UI bileşenlerini ve yerleşimlerini tanımlamak için kullanılır."
            },
            {
              "questionId": 22002,
              "question": "Android'de View kavramı neyi ifade eder?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Sadece butonları",
                "Ekranda görünen tüm UI bileşenlerini",
                "Sadece layout dosyalarını",
                "Arka plan işlemlerini"
              ],
              "correctAnswerIndex": 1,
              "explanation": "TextView, Button, ImageView gibi tüm UI bileşenleri View sınıfından türetilir."
            },
            {
              "questionId": 22003,
              "question": "LinearLayout'un temel özelliği nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Ögeleri serbestçe konumlandırır",
                "Ögeleri yatay veya dikey sırayla dizer",
                "Sadece tek View alır",
                "Sadece ConstraintLayout içinde çalışır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "LinearLayout, orientation özelliğiyle View'ları dikey veya yatay dizer."
            },
            {
              "questionId": 22004,
              "question": "ConstraintLayout kullanmanın en büyük avantajı nedir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Daha fazla nested layout gerektirir",
                "Performansı düşürür",
                "Daha esnek ve performanslı UI tasarımı sağlar",
                "Sadece basit ekranlarda kullanılır"
              ],
              "correctAnswerIndex": 2,
              "explanation": "ConstraintLayout, karmaşık UI'ları daha az hiyerarşi ile oluşturur."
            },
            {
              "questionId": 22005,
              "question": "Nested Layout ne anlama gelir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Tek bir View kullanılması",
                "Layout içinde başka layout'ların bulunması",
                "Sadece ConstraintLayout kullanılması",
                "XML kullanılmadan UI oluşturulması"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Nested Layout, performansı olumsuz etkileyebilecek derin view hiyerarşisi oluşturur."
            },
            {
              "questionId": 22006,
              "question": "Aşırı nested layout kullanımının olası sonucu nedir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Uygulamanın daha hızlı çalışması",
                "Daha az bellek kullanımı",
                "UI performansının düşmesi",
                "Kod okunabilirliğinin artması"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Derin view hiyerarşisi ölçüm ve çizim sürelerini uzatır."
            },
            {
              "questionId": 22007,
              "question": "View Binding'in temel amacı nedir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "XML yerine Java/Kotlin kullanmak",
                "findViewById kullanımını ortadan kaldırmak",
                "UI performansını düşürmek",
                "Sadece Fragment'larda çalışmak"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding, type-safe bir şekilde View'lara erişmeyi sağlar."
            },
            {
              "questionId": 22008,
              "question": "View Binding kullanmanın avantajlarından biri değildir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "NullPointerException riskini azaltır",
                "Tip güvenliği sağlar",
                "Runtime'da view hatalarını artırır",
                "Kod okunabilirliğini artırır"
              ],
              "correctAnswerIndex": 2,
              "explanation": "View Binding, runtime hataları azaltmayı hedefler."
            },
            {
              "questionId": 22009,
              "question": "ConstraintLayout'ta View'ların konumu nasıl belirlenir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Sabit piksel değerleriyle",
                "Parent'a ve diğer View'lara constraint vererek",
                "Sadece orientation kullanarak",
                "Gravity özelliğiyle"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ConstraintLayout, constraint sistemiyle esnek yerleşim sağlar."
            },
            {
              "questionId": 22010,
              "question": "Modern Android UI tasarımında hangi yaklaşım önerilir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Çok sayıda nested LinearLayout",
                "ConstraintLayout kullanımı",
                "AbsoluteLayout kullanımı",
                "Sabit ekran boyutuna göre tasarım"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ConstraintLayout, performans ve esneklik açısından önerilen yaklaşımdır."
            }
          ]
        },
        {
          "sectionId": 2300,
          "sectionTitle": "Activity & Lifecycle",
          "sectionDescription": "Android uygulamalarda Activity kavramı, yaşam döngüsü ve Context kullanımı",
          "order": 3,
          "topics": [
            {
              "topicId": 2301,
              "title": "Activity Nedir",
              "summary": "Activity, Android uygulamalarda kullanıcıya gösterilen tek bir ekranı temsil eder. Uygulama içerisindeki her ekran genellikle bir Activity veya Fragment tarafından yönetilir.",
              "content": "## Activity Nedir\n\nActivity, kullanıcı ile etkileşime girilen temel bileşendir.\n\nBir uygulama birden fazla Activity içerebilir ve Activity'ler arasında Intent kullanılarak geçiş yapılır.\n\nActivity, Android işletim sistemi tarafından belirli bir yaşam döngüsüne göre yönetilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Activity Tanımı",
                  "code": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}",
                  "explanation": "Bir Activity'nin temel yapısı ve onCreate metodu."
                }
              ],
              "keyPoints": [
                "Her Activity bir ekranı temsil eder",
                "AppCompatActivity'den türetilir",
                "Intent ile Activity geçişleri yapılır",
                "Yaşam döngüsü metotlarına sahiptir"
              ],
              "questions": []
            },
            {
              "topicId": 2302,
              "title": "Lifecycle Metotları",
              "summary": "Lifecycle metotları, Activity'nin oluşturulmasından yok edilmesine kadar geçen sürede hangi aşamalardan geçtiğini belirler. Bu metotlar sayesinde kaynak yönetimi doğru şekilde yapılır.",
              "content": "## Lifecycle Metotları\n\nAndroid, Activity'nin durumuna göre belirli lifecycle metotlarını çağırır.\n\nBu metotlar, uygulamanın arka plana alınması, tekrar açılması veya kapatılması gibi durumlarda çalışır.\n\nDoğru lifecycle yönetimi performans ve stabilite açısından kritik öneme sahiptir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Lifecycle Metotları Örneği",
                  "code": "override fun onStart() {\n    super.onStart()\n}\n\noverride fun onResume() {\n    super.onResume()\n}\n\noverride fun onPause() {\n    super.onPause()\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n}",
                  "explanation": "Activity yaşam döngüsünde sık kullanılan metotlar."
                }
              ],
              "keyPoints": [
                "onCreate: Activity oluşturulur",
                "onStart / onResume: Activity görünür ve aktif",
                "onPause / onStop: Activity arka plana alınır",
                "onDestroy: Activity yok edilir",
                "Kaynaklar lifecycle'a göre yönetilmelidir"
              ],
              "questions": []
            },
            {
              "topicId": 2303,
              "title": "Context",
              "summary": "Context, Android uygulamasının mevcut durumunu ve ortam bilgisini temsil eder. Kaynaklara erişim, Activity başlatma ve sistem servislerini kullanmak için gereklidir.",
              "content": "## Context\n\nContext, uygulama hakkında bilgi sağlar.\n\nActivity, Application ve Service gibi sınıflar Context türevleridir.\n\nYanlış Context kullanımı memory leak gibi sorunlara yol açabilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Context Kullanımı",
                  "code": "Toast.makeText(this, \"Merhaba\", Toast.LENGTH_SHORT).show()",
                  "explanation": "Activity context kullanılarak Toast gösterilmesi."
                }
              ],
              "keyPoints": [
                "Kaynaklara erişim sağlar",
                "Activity ve Application Context farkı vardır",
                "Yanlış kullanım memory leak oluşturabilir",
                "Toast, Intent ve Dialog işlemlerinde kullanılır"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 23001,
              "question": "Android'de Activity nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Veritabanı işlemlerini yöneten sınıf",
                "Kullanıcı arayüzünü temsil eden temel bileşen",
                "Arka planda çalışan servis",
                "Sadece Fragment barındıran yapı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity, kullanıcıyla etkileşime girilen tek bir ekranı temsil eder."
            },
            {
              "questionId": 23002,
              "question": "Bir Activity ilk kez başlatıldığında ilk çağrılan lifecycle metodu hangisidir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "onStart()",
                "onResume()",
                "onCreate()",
                "onRestart()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "onCreate(), Activity'nin ilk oluşturulduğu yerdir."
            },
            {
              "questionId": 23003,
              "question": "onStart() metodu ne zaman çağrılır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Activity ekrandan tamamen kaybolduğunda",
                "Activity kullanıcıya görünür hale geldiğinde",
                "Activity kapatıldığında",
                "Uygulama arka plana alındığında"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onStart(), Activity görünür olduğunda çağrılır."
            },
            {
              "questionId": 23004,
              "question": "Kullanıcı Activity ile aktif olarak etkileşime geçtiğinde hangi metot çağrılır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "onPause()",
                "onStop()",
                "onResume()",
                "onDestroy()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "onResume(), Activity foreground'dayken çalışır."
            },
            {
              "questionId": 23005,
              "question": "Başka bir Activity açıldığında mevcut Activity için hangi metot çağrılır?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "onResume()",
                "onPause()",
                "onDestroy()",
                "onRestart()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onPause(), Activity kısmen görünmez olduğunda çağrılır."
            },
            {
              "questionId": 23006,
              "question": "Activity tamamen görünmez hale geldiğinde hangi lifecycle metodu çalışır?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "onPause()",
                "onStop()",
                "onStart()",
                "onCreate()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onStop(), Activity ekranda görünmediğinde çağrılır."
            },
            {
              "questionId": 23007,
              "question": "onDestroy() metodu ne zaman çağrılır?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Activity arka plana alındığında",
                "Kullanıcı geri tuşuna bastığında veya sistem Activity'yi yok ettiğinde",
                "Ekran döndüğünde",
                "Uygulama ilk açıldığında"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onDestroy(), Activity tamamen yok edilmeden önce çağrılır."
            },
            {
              "questionId": 23008,
              "question": "Context nedir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Sadece UI bileşenlerini temsil eder",
                "Uygulama ortamı hakkında bilgi sağlayan yapıdır",
                "Veritabanı bağlantısını yöneten sınıf",
                "Sadece Activity içinde kullanılan nesne"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Context, uygulamanın çalıştığı ortam hakkında bilgi verir."
            },
            {
              "questionId": 23009,
              "question": "Aşağıdakilerden hangisi Context örneğidir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "ViewModel",
                "Intent",
                "Activity",
                "LiveData"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Activity, Context sınıfından türetilmiştir."
            },
            {
              "questionId": 23010,
              "question": "Yanlış Context kullanımı neye yol açabilir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Daha hızlı uygulama",
                "Memory leak",
                "Daha az bellek kullanımı",
                "Daha iyi UI performansı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Yanlış Context referansları memory leak'e neden olabilir."
            }
          ]
        },
        {
          "sectionId": 2400,
          "sectionTitle": "Kullanıcı Etkileşimi",
          "sectionDescription": "Kullanıcının uygulama ile etkileşime girmesini sağlayan temel UI bileşenleri",
          "order": 4,
          "topics": [
            {
              "topicId": 2401,
              "title": "Button",
              "summary": "Button, kullanıcının bir aksiyon başlatmasını sağlayan temel UI bileşenidir. Genellikle tıklama (click) olayları ile birlikte kullanılır.",
              "content": "## Button\n\nButton, kullanıcıdan aksiyon almak için kullanılır.\n\nTıklama olayları click listener aracılığıyla yakalanır.\n\nXML üzerinden veya kod ile özelleştirilebilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Button Tanımı",
                  "code": "<Button\n    android:id=\"@+id/btnSave\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Kaydet\" />",
                  "explanation": "XML ile Button tanımlama."
                }
              ],
              "keyPoints": [
                "Kullanıcı aksiyonu için kullanılır",
                "Click listener ile çalışır",
                "XML ve koddan kontrol edilebilir"
              ],
              "questions": []
            },
            {
              "topicId": 2402,
              "title": "EditText",
              "summary": "EditText, kullanıcıdan metin girişi almak için kullanılan bir UI bileşenidir. Formlar ve veri giriş ekranlarında yaygın olarak kullanılır.",
              "content": "## EditText\n\nEditText, kullanıcıdan veri almak için kullanılır.\n\ninputType ile klavye türü belirlenebilir.\n\nGirilen veri String olarak alınır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "EditText Kullanımı",
                  "code": "<EditText\n    android:id=\"@+id/etName\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"İsim giriniz\" />",
                  "explanation": "Basit EditText tanımı."
                }
              ],
              "keyPoints": [
                "Kullanıcıdan metin alır",
                "inputType ile klavye ayarlanır",
                "Genellikle form ekranlarında kullanılır"
              ],
              "questions": []
            },
            {
              "topicId": 2403,
              "title": "Click Listener",
              "summary": "Click Listener, kullanıcı bir View'a tıkladığında çalışacak kod bloğunu tanımlamak için kullanılır. En yaygın kullanılan etkileşim yöntemidir.",
              "content": "## Click Listener\n\nClick listener sayesinde kullanıcı etkileşimleri yakalanır.\n\nKotlin'de lambda yapısı ile daha sade yazılabilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Click Listener Örneği",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "explanation": "Lambda kullanılarak click listener tanımı."
                }
              ],
              "keyPoints": [
                "Kullanıcı etkileşimini yakalar",
                "Lambda ile sade kullanım",
                "Tüm View'lar için geçerlidir"
              ],
              "questions": []
            },
            {
              "topicId": 2404,
              "title": "AlertDialog",
              "summary": "AlertDialog, kullanıcıya bilgi vermek veya onay almak için kullanılan açılır pencere yapısıdır. Kritik aksiyonlar öncesinde sıkça tercih edilir.",
              "content": "## AlertDialog\n\nAlertDialog, kullanıcıdan onay veya seçim almak için kullanılır.\n\nBaşlık, mesaj ve butonlar içerir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "AlertDialog Örneği",
                  "code": "AlertDialog.Builder(this)\n    .setTitle(\"Uyarı\")\n    .setMessage(\"Silmek istiyor musunuz?\")\n    .setPositiveButton(\"Evet\", null)\n    .setNegativeButton(\"Hayır\", null)\n    .show()",
                  "explanation": "Basit bir AlertDialog oluşturma."
                }
              ],
              "keyPoints": [
                "Kullanıcıdan onay almak için kullanılır",
                "Pozitif ve negatif butonlar içerir",
                "Context gerektirir"
              ],
              "questions": []
            },
            {
              "topicId": 2405,
              "title": "Toast / Snackbar",
              "summary": "Toast ve Snackbar, kullanıcıya kısa süreli bilgilendirme mesajları göstermek için kullanılır. Snackbar, Toast'a göre daha etkileşimli ve modern bir çözümdür.",
              "content": "## Toast / Snackbar\n\nToast kısa süreli mesaj gösterir.\n\nSnackbar, aksiyon butonu eklemeye izin verir ve genellikle View ile ilişkilidir.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Toast ve Snackbar",
                  "code": "Toast.makeText(this, \"Kayıt başarılı\", Toast.LENGTH_SHORT).show()\n\nSnackbar.make(view, \"Silindi\", Snackbar.LENGTH_LONG)\n    .setAction(\"Geri Al\") { }\n    .show()",
                  "explanation": "Toast ve Snackbar kullanım örneği."
                }
              ],
              "keyPoints": [
                "Toast kısa bilgilendirme için kullanılır",
                "Snackbar daha etkileşimlidir",
                "Snackbar aksiyon alabilir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 24001,
              "question": "Android'de Button bileşeni ne için kullanılır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Kullanıcıdan metin almak için",
                "Kullanıcı etkileşimini tetiklemek için",
                "Veri saklamak için",
                "Ekranlar arası geçişi otomatik yapmak için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Button, kullanıcıdan gelen tıklama gibi etkileşimleri yakalamak için kullanılır."
            },
            {
              "questionId": 24002,
              "question": "EditText bileşeninin temel amacı nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Metin göstermek",
                "Buton oluşturmak",
                "Kullanıcıdan veri girişi almak",
                "Mesaj göstermek"
              ],
              "correctAnswerIndex": 2,
              "explanation": "EditText, kullanıcıdan yazı girişi almak için kullanılan UI bileşenidir."
            },
            {
              "questionId": 24003,
              "question": "Bir Button'a tıklama olayını yakalamak için en yaygın kullanılan yöntem hangisidir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "setOnClickListener",
                "setOnTouchListener",
                "setOnFocusChangeListener",
                "setOnScrollChangeListener"
              ],
              "correctAnswerIndex": 0,
              "explanation": "setOnClickListener, tıklama olaylarını yakalamak için kullanılır."
            },
            {
              "questionId": 24004,
              "question": "Kotlin'de bir Click Listener genellikle hangi yapı ile tanımlanır?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Interface implementasyonu",
                "Lambda expression",
                "Abstract class",
                "Data class"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Kotlin'de click listener'lar genellikle lambda ile yazılır."
            },
            {
              "questionId": 24005,
              "question": "AlertDialog ne amaçla kullanılır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Arka planda işlem yapmak için",
                "Kullanıcıdan onay veya bilgi almak için",
                "Toast mesajı göstermek için",
                "Yeni Activity başlatmak için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "AlertDialog, kullanıcıya uyarı, onay veya seçenek sunmak için kullanılır."
            },
            {
              "questionId": 24006,
              "question": "AlertDialog.Builder hangi bileşenle birlikte kullanılır?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Service",
                "Context",
                "ViewModel",
                "RecyclerView"
              ],
              "correctAnswerIndex": 1,
              "explanation": "AlertDialog oluşturmak için Context gereklidir."
            },
            {
              "questionId": 24007,
              "question": "Toast mesajlarının temel özelliği nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Kullanıcıdan cevap alır",
                "Ekranı tamamen kaplar",
                "Kısa süreli ve geçici mesaj gösterir",
                "Buton içerir"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Toast mesajları kısa süreli bilgilendirme mesajlarıdır."
            },
            {
              "questionId": 24008,
              "question": "Snackbar, Toast'a göre hangi avantajı sunar?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Daha uzun süre görünür",
                "Arka planda çalışır",
                "Action (geri al gibi) eklenebilir",
                "Context gerektirmez"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Snackbar, kullanıcıya aksiyon sunabilme özelliği ile Toast'tan ayrılır."
            },
            {
              "questionId": 24009,
              "question": "EditText içinden alınan metni String'e çevirmek için hangi metot kullanılır?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "getText()",
                "text",
                "text.toString()",
                "valueOf()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "EditText.text.toString() ile String değeri alınır."
            },
            {
              "questionId": 24010,
              "question": "Kullanıcı etkileşimlerinde yanlış Context kullanımı neye sebep olabilir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Daha hızlı UI",
                "Memory leak",
                "Daha az bellek kullanımı",
                "Lifecycle hatalarını engeller"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Yanlış Context kullanımı memory leak'e yol açabilir."
            }
          ]
        },
        {
          "sectionId": 2500,
          "sectionTitle": "Intent & Veri Aktarımı",
          "sectionDescription": "Activity’ler arası geçiş ve veri aktarımı için kullanılan Intent yapıları",
          "order": 5,
          "topics": [
            {
              "topicId": 2501,
              "title": "Explicit Intent",
              "summary": "Explicit Intent, hangi Activity’nin açılacağını açıkça belirttiğimiz intent türüdür. Uygulama içindeki Activity geçişlerinde en sık kullanılan yöntemdir.",
              "content": "## Explicit Intent\n\nExplicit Intent, hedef Activity'nin doğrudan belirtildiği intent türüdür.\n\nGenellikle aynı uygulama içerisindeki ekranlar arasında geçiş yapmak için kullanılır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Explicit Intent Kullanımı",
                  "code": "val intent = Intent(this, DetailActivity::class.java)\nstartActivity(intent)",
                  "explanation": "MainActivity'den DetailActivity'e geçiş."
                }
              ],
              "keyPoints": [
                "Hedef Activity açıkça belirtilir",
                "Uygulama içi geçişlerde kullanılır",
                "En yaygın intent türüdür"
              ],
              "questions": []
            },
            {
              "topicId": 2502,
              "title": "Implicit Intent",
              "summary": "Implicit Intent, hangi uygulamanın açılacağını belirtmeden, yapılmak istenen işlemi tanımlar. Sistem, bu isteği karşılayabilecek uygulamayı kullanıcıya sunar.",
              "content": "## Implicit Intent\n\nImplicit Intent, belirli bir aksiyon ve veri ile çalışır.\n\nTelefon araması, tarayıcı açma veya paylaşım işlemlerinde sıkça kullanılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Implicit Intent Örneği",
                  "code": "val intent = Intent(Intent.ACTION_VIEW)\nintent.data = Uri.parse(\"https://www.google.com\")\nstartActivity(intent)",
                  "explanation": "Tarayıcı açmak için implicit intent kullanımı."
                }
              ],
              "keyPoints": [
                "Hedef uygulama belirtilmez",
                "Aksiyon ve data ile çalışır",
                "Sistem uygun uygulamayı seçer"
              ],
              "questions": []
            },
            {
              "topicId": 2503,
              "title": "Bundle",
              "summary": "Bundle, key-value mantığıyla çalışan ve Activity’ler arasında veri taşımak için kullanılan bir yapıdır. Intent ile birlikte kullanılır.",
              "content": "## Bundle\n\nBundle, küçük ve basit verilerin taşınması için idealdir.\n\nVeriler key-value şeklinde saklanır.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Bundle ile Veri Gönderme",
                  "code": "val bundle = Bundle()\nbundle.putString(\"username\", \"Ahmet\")\nintent.putExtras(bundle)\nstartActivity(intent)",
                  "explanation": "Bundle kullanarak veri aktarımı."
                }
              ],
              "keyPoints": [
                "Key-value mantığı ile çalışır",
                "Intent ile birlikte kullanılır",
                "Küçük veriler için uygundur"
              ],
              "questions": []
            },
            {
              "topicId": 2504,
              "title": "Serializable / Parcelable",
              "summary": "Serializable ve Parcelable, karmaşık nesneleri Activity’ler arasında taşımak için kullanılan yöntemlerdir. Parcelable, Android için daha performanslı bir çözümdür.",
              "content": "## Serializable / Parcelable\n\nSerializable Java tabanlıdır ve kullanımı kolaydır.\n\nParcelable ise Android’e özeldir ve daha hızlıdır.\n\nBüyük veri transferlerinde Parcelable tercih edilmelidir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Parcelable Kullanımı",
                  "code": "@Parcelize\ndata class User(val name: String, val age: Int) : Parcelable",
                  "explanation": "Parcelable veri sınıfı tanımı."
                }
              ],
              "keyPoints": [
                "Serializable kullanımı kolaydır",
                "Parcelable daha performanslıdır",
                "Karmaşık nesneler için kullanılır",
                "Android projelerinde Parcelable önerilir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 25001,
              "question": "Explicit Intent ne için kullanılır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Sistemde uygun uygulamayı bulmak için",
                "Belirli bir Activity veya Component'i başlatmak için",
                "Broadcast göndermek için",
                "Arka planda servis çalıştırmak için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Explicit Intent, hedef Activity veya Component'in açıkça belirtildiği intent türüdür."
            },
            {
              "questionId": 25002,
              "question": "Implicit Intent'in temel farkı nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Hedef Activity adı zorunludur",
                "Sadece uygulama içinde çalışır",
                "Hedefi sistem belirler",
                "Veri taşıyamaz"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Implicit Intent'te hangi uygulamanın çalışacağına Android sistemi karar verir."
            },
            {
              "questionId": 25003,
              "question": "Bir Activity'den diğerine veri göndermek için en sık kullanılan yöntem hangisidir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "SharedPreferences",
                "Intent extras",
                "Database",
                "Singleton"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent.putExtra() ile Activity'ler arası veri aktarımı yapılır."
            },
            {
              "questionId": 25004,
              "question": "Intent ile gönderilen küçük ve basit veriler genellikle nerede tutulur?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "ViewModel",
                "Bundle",
                "Room Database",
                "Service"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent verileri Bundle içerisinde taşır."
            },
            {
              "questionId": 25005,
              "question": "Bundle temel olarak ne işe yarar?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "UI çizmek",
                "Lifecycle yönetmek",
                "Key-Value şeklinde veri taşımak",
                "Thread yönetmek"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Bundle, key-value mantığıyla veri taşımak için kullanılır."
            },
            {
              "questionId": 25006,
              "question": "Aşağıdakilerden hangisi Implicit Intent kullanımına örnektir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Yeni Activity başlatmak",
                "Uygulama içi sayfa açmak",
                "Telefon arama ekranını açmak",
                "Fragment değiştirmek"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Telefon arama, tarayıcı açma gibi işlemler implicit intent ile yapılır."
            },
            {
              "questionId": 25007,
              "question": "Serializable ve Parcelable arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Serializable daha hızlıdır",
                "Parcelable Android'e özeldir ve daha performanslıdır",
                "Parcelable Java'ya özeldir",
                "İkisi de aynıdır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Parcelable Android'e özeldir ve Serializable'a göre daha performanslıdır."
            },
            {
              "questionId": 25008,
              "question": "Büyük veri nesneleri Intent ile taşınırken hangisi tercih edilmelidir?",
              "questionType": "multiple_choice",
              "difficulty": "hard",
              "options": [
                "Serializable",
                "Parcelable",
                "Bundle",
                "Global değişken"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Parcelable, performans açısından büyük veri transferlerinde tercih edilir."
            },
            {
              "questionId": 25009,
              "question": "Yanlış veri aktarımı aşağıdakilerden hangisine sebep olabilir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Compile error",
                "Memory leak",
                "App crash (Runtime exception)",
                "UI donması"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Yanlış key veya null veri alma işlemleri runtime crash'e yol açabilir."
            },
            {
              "questionId": 25010,
              "question": "Intent ile veri alırken kullanılan metot hangisidir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "getIntent()",
                "receiveExtra()",
                "fetchData()",
                "loadBundle()"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Activity içinde getIntent() ile gelen intent alınır ve extras okunur."
            }
          ]
        },
        {
          "sectionId": 2600,
          "sectionTitle": "Veri Saklama",
          "sectionDescription": "Android uygulamalarda kullanıcı verilerinin yerel olarak saklanması yöntemleri",
          "order": 6,
          "topics": [
            {
              "topicId": 2601,
              "title": "SharedPreferences",
              "summary": "SharedPreferences, küçük ve basit verileri anahtar-değer (key-value) mantığıyla saklamak için kullanılan hafif bir veri saklama yöntemidir. Genellikle kullanıcı ayarları ve basit konfigürasyonlar için tercih edilir.",
              "content": "## SharedPreferences\n\nSharedPreferences, kalıcı veri saklama sağlar.\n\nUygulama kapatılsa bile veriler korunur.\n\nBoolean, Int, Float, Long ve String gibi basit veri tiplerini destekler.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "SharedPreferences Kullanımı",
                  "code": "val prefs = getSharedPreferences(\"MyPrefs\", Context.MODE_PRIVATE)\nprefs.edit().putString(\"username\", \"Ahmet\").apply()",
                  "explanation": "SharedPreferences ile veri kaydetme."
                }
              ],
              "keyPoints": [
                "Key-value yapısı kullanır",
                "Küçük veriler için uygundur",
                "Kalıcı veri saklar",
                "Basit ve hızlıdır"
              ],
              "questions": []
            },
            {
              "topicId": 2602,
              "title": "Internal Storage",
              "summary": "Internal Storage, uygulamaya özel dosyaların cihazın dahili hafızasında saklanmasını sağlar. Bu veriler yalnızca ilgili uygulama tarafından erişilebilir.",
              "content": "## Internal Storage\n\nInternal Storage güvenli bir veri saklama yöntemidir.\n\nDosyalar uygulamaya özeldir ve başka uygulamalar erişemez.\n\nUygulama silindiğinde veriler de silinir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Internal Storage Dosya Yazma",
                  "code": "openFileOutput(\"data.txt\", Context.MODE_PRIVATE).use {\n    it.write(\"Merhaba\".toByteArray())\n}",
                  "explanation": "Internal Storage'a dosya yazma örneği."
                }
              ],
              "keyPoints": [
                "Uygulamaya özeldir",
                "Güvenlidir",
                "Dosya bazlı veri saklar",
                "Uygulama silinince veriler silinir"
              ],
              "questions": []
            },
            {
              "topicId": 2603,
              "title": "External Storage (Kavramsal)",
              "summary": "External Storage, cihazın ortak depolama alanını kullanarak veri saklamayı ifade eder. Diğer uygulamalar ve kullanıcı tarafından erişilebilir olduğu için güvenlik açısından dikkatli kullanılmalıdır.",
              "content": "## External Storage\n\nExternal Storage genellikle medya dosyaları için kullanılır.\n\nAndroid 10 ve sonrası sürümlerde scoped storage kavramı ile erişim kısıtlanmıştır.\n\nİzin (permission) gerektirebilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [],
              "keyPoints": [
                "Ortak depolama alanıdır",
                "Diğer uygulamalar erişebilir",
                "Permission gerektirebilir",
                "Medya dosyaları için uygundur"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 26001,
              "question": "SharedPreferences temel olarak ne için kullanılır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Büyük dosyaları saklamak",
                "Kullanıcı ayarları ve küçük veriler saklamak",
                "Veritabanı işlemleri yapmak",
                "Geçici UI verileri tutmak"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SharedPreferences, key-value şeklinde küçük ve basit verileri saklamak için kullanılır."
            },
            {
              "questionId": 26002,
              "question": "Aşağıdakilerden hangisi SharedPreferences için uygun bir veri örneğidir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Profil fotoğrafı",
                "Kullanıcı giriş durumu (true/false)",
                "Video dosyası",
                "Liste halinde ürünler"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Boolean, String, Int gibi küçük veriler SharedPreferences için uygundur."
            },
            {
              "questionId": 26003,
              "question": "Internal Storage'un temel özelliği nedir?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Diğer uygulamalar tarafından erişilebilir",
                "Sadece uygulamanın kendisi erişebilir",
                "İnternet bağlantısı gerektirir",
                "Kullanıcı silemez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Internal Storage, uygulamaya özel bir alandır ve başka uygulamalar erişemez."
            },
            {
              "questionId": 26004,
              "question": "Uygulama silindiğinde Internal Storage'taki veriler ne olur?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Cihazda kalır",
                "Cloud'a taşınır",
                "Otomatik olarak silinir",
                "External Storage'a aktarılır"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Uygulama kaldırıldığında Internal Storage içindeki tüm veriler silinir."
            },
            {
              "questionId": 26005,
              "question": "External Storage hangi tür veriler için daha uygundur?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Geçici ayarlar",
                "Kullanıcıya ait büyük medya dosyaları",
                "Şifreler",
                "Token bilgileri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Fotoğraf, video gibi büyük ve kullanıcıya ait dosyalar External Storage'ta tutulur."
            },
            {
              "questionId": 26006,
              "question": "External Storage kullanırken genellikle neye ihtiyaç duyulur?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "Internet izni",
                "Location izni",
                "Storage izni",
                "Camera izni"
              ],
              "correctAnswerIndex": 2,
              "explanation": "External Storage erişimi için runtime storage izinleri gerekebilir."
            },
            {
              "questionId": 26007,
              "question": "Kullanıcı uygulamayı silse bile dosyaların kalmasını istiyorsak hangi yöntem tercih edilir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "SharedPreferences",
                "Internal Storage",
                "External Storage",
                "ViewModel"
              ],
              "correctAnswerIndex": 2,
              "explanation": "External Storage verileri uygulama silinse bile cihazda kalabilir."
            },
            {
              "questionId": 26008,
              "question": "Güvenlik açısından en güvenli veri saklama yöntemi hangisidir?",
              "questionType": "multiple_choice",
              "difficulty": "medium",
              "options": [
                "External Storage",
                "SharedPreferences",
                "Internal Storage",
                "Cache"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Internal Storage yalnızca uygulama tarafından erişilebilir olduğu için daha güvenlidir."
            },
            {
              "questionId": 26009,
              "question": "SharedPreferences verileri hangi yapıda saklar?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "Liste",
                "JSON",
                "Key-Value",
                "Tablo"
              ],
              "correctAnswerIndex": 2,
              "explanation": "SharedPreferences key-value mantığıyla çalışır."
            },
            {
              "questionId": 26010,
              "question": "Aşağıdakilerden hangisi veri saklama yöntemleri arasında kavramsal olarak yer alır?",
              "questionType": "multiple_choice",
              "difficulty": "easy",
              "options": [
                "RecyclerView",
                "External Storage",
                "Intent",
                "Fragment"
              ],
              "correctAnswerIndex": 1,
              "explanation": "External Storage, Android'de veri saklama yöntemlerinden biridir."
            }
          ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 20001,
          "question": "Android nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Bir programlama dili",
            "Bir mobil işletim sistemi",
            "Bir UI kütüphanesi",
            "Bir veritabanı sistemi"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Android, Linux tabanlı açık kaynaklı bir mobil işletim sistemidir."
        },
        {
          "questionId": 20002,
          "question": "Android uygulamasının giriş noktası hangi dosyada tanımlanır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "MainActivity.kt",
            "AndroidManifest.xml",
            "build.gradle",
            "res/layout"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Uygulamanın bileşenleri ve giriş noktaları AndroidManifest.xml dosyasında tanımlanır."
        },
        {
          "questionId": 20003,
          "question": "XML Android'de ne için kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Veritabanı işlemleri",
            "UI tasarımı",
            "Network işlemleri",
            "Thread yönetimi"
          ],
          "correctAnswerIndex": 1,
          "explanation": "XML, Android'de arayüz (UI) tasarlamak için kullanılır."
        },
        {
          "questionId": 20004,
          "question": "Android'de View nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Bir ekran",
            "Bir UI bileşeni",
            "Bir veritabanı",
            "Bir servis"
          ],
          "correctAnswerIndex": 1,
          "explanation": "View, ekranda görünen temel UI bileşenidir."
        },
        {
          "questionId": 20005,
          "question": "LinearLayout'un temel özelliği nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Bileşenleri üst üste dizer",
            "Bileşenleri yatay veya dikey sıralar",
            "Serbest konumlandırma sağlar",
            "Sadece tek View alır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "LinearLayout, View'ları yatay veya dikey olarak sıralar."
        },
        {
          "questionId": 20006,
          "question": "ConstraintLayout neden tercih edilir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Daha yavaş çalıştığı için",
            "Daha az esneklik sağladığı için",
            "Performanslı ve esnek olduğu için",
            "Sadece küçük projelerde kullanıldığı için"
          ],
          "correctAnswerIndex": 2,
          "explanation": "ConstraintLayout, düz ve performanslı UI yapıları kurmayı sağlar."
        },
        {
          "questionId": 20007,
          "question": "View Binding'in temel avantajı nedir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Daha fazla XML yazmak",
            "findViewById ihtiyacını kaldırmak",
            "UI performansını düşürmek",
            "Sadece Fragment'ta çalışmak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "View Binding, type-safe erişim sağlayarak findViewById ihtiyacını ortadan kaldırır."
        },
        {
          "questionId": 20008,
          "question": "Activity nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Bir UI bileşeni",
            "Bir ekranı temsil eden bileşen",
            "Bir veritabanı",
            "Bir servis"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Activity, kullanıcıya gösterilen bir ekranı temsil eder."
        },
        {
          "questionId": 20009,
          "question": "Activity lifecycle'da ilk çağrılan metot hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "onStart",
            "onResume",
            "onCreate",
            "onPause"
          ],
          "correctAnswerIndex": 2,
          "explanation": "onCreate(), Activity ilk oluşturulduğunda çağrılır."
        },
        {
          "questionId": 20010,
          "question": "Context ne işe yarar?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "UI çizmek",
            "Uygulama ortamına erişmek",
            "Veritabanı oluşturmak",
            "Thread başlatmak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Context, uygulama ortamı ve kaynaklara erişim sağlar."
        },
        {
          "questionId": 20011,
          "question": "Kullanıcı tıklamalarını yakalamak için hangi yapı kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Intent",
            "Click Listener",
            "Context",
            "Fragment"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Click Listener, kullanıcı etkileşimlerini yakalar."
        },
        {
          "questionId": 20012,
          "question": "Toast ve Snackbar arasındaki temel fark nedir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Snackbar etkileşimlidir",
            "Toast daha uzun sürer",
            "Toast buton içerir",
            "Snackbar arka planda çalışır"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Snackbar, kullanıcıya aksiyon (buton) sunabilir."
        },
        {
          "questionId": 20013,
          "question": "Explicit Intent ne için kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Sisteme görev bırakmak",
            "Belirli Activity başlatmak",
            "Dosya okumak",
            "Veri saklamak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Explicit Intent, hedef Activity'nin açıkça belirtildiği intent türüdür."
        },
        {
          "questionId": 20014,
          "question": "Implicit Intent hangi durumda kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Uygulama içi ekran geçişi",
            "Telefon araması yapmak",
            "Fragment değiştirmek",
            "View Binding kullanmak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Telefon arama, tarayıcı açma gibi işlemler implicit intent ile yapılır."
        },
        {
          "questionId": 20015,
          "question": "Intent ile taşınan veriler nerede tutulur?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "SharedPreferences",
            "Bundle",
            "Room",
            "ViewModel"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Intent verileri Bundle içinde taşır."
        },
        {
          "questionId": 20016,
          "question": "Parcelable neden Serializable'dan daha çok tercih edilir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Daha kolay yazıldığı için",
            "Daha güvenli olduğu için",
            "Daha performanslı olduğu için",
            "Sadece Kotlin'de çalıştığı için"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Parcelable, Android'e özel ve daha performanslıdır."
        },
        {
          "questionId": 20017,
          "question": "SharedPreferences hangi tür veriler için uygundur?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Büyük dosyalar",
            "Kullanıcı ayarları",
            "Video kayıtları",
            "Liste verileri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "SharedPreferences küçük ve basit ayar verileri için kullanılır."
        },
        {
          "questionId": 20018,
          "question": "Internal Storage'un en önemli özelliği nedir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Herkese açık olması",
            "Uygulamaya özel olması",
            "Cloud ile senkron çalışması",
            "İzin gerektirmesi"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Internal Storage sadece uygulamaya özeldir."
        },
        {
          "questionId": 20019,
          "question": "External Storage genellikle ne için kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Şifre saklamak",
            "Uygulama ayarları",
            "Fotoğraf ve video dosyaları",
            "Token bilgileri"
          ],
          "correctAnswerIndex": 2,
          "explanation": "External Storage kullanıcıya ait büyük dosyalar için uygundur."
        },
        {
          "questionId": 20020,
          "question": "Yanlış veri saklama yöntemi kullanımı neye yol açabilir?",
          "questionType": "multiple_choice",
          "difficulty": "hard",
          "options": [
            "Compile error",
            "UI renk hatası",
            "Güvenlik ve performans sorunları",
            "XML parse hatası"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Yanlış saklama yöntemi güvenlik açıklarına ve performans problemlerine yol açabilir."
        }
      ]
    },
    {
      "categoryId": 3,
      "categoryTitle": "Android Orta - İleri Seviye",
      "categoryDescription": "Modern Android geliştirme teknikleri",
      "order": 3,
      "sections": [
        {
        "sectionId": 3100,
        "sectionTitle": "RecyclerView",
        "sectionDescription": "Liste ve grid yapılarında performanslı veri gösterimi için kullanılan RecyclerView bileşeninin detaylı incelenmesi",
        "order": 1,
        "topics": [
          {
            "topicId": 3101,
            "title": "RecyclerView Mantığı",
            "summary": "RecyclerView, büyük veri listelerini performanslı şekilde göstermek için kullanılan modern bir listeleme bileşenidir. Görünmeyen item'ları yeniden kullanarak (recycle) bellek ve performans avantajı sağlar.",
            "content": "## RecyclerView Mantığı\n\nRecyclerView, View recycling mantığı ile çalışır.\n\nEkranda görünmeyen item'lar yok edilmez, yeniden kullanılır.\n\nBu yapı özellikle uzun listelerde yüksek performans sağlar.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "RecyclerView Tanımı",
                "code": "val recyclerView = findViewById<RecyclerView>(R.id.recyclerView)\nrecyclerView.layoutManager = LinearLayoutManager(this)",
                "explanation": "RecyclerView için LayoutManager tanımlaması."
              }
            ],
            "keyPoints": [
              "View recycling kullanır",
              "Performanslıdır",
              "Büyük listeler için uygundur",
              "LayoutManager ile çalışır"
            ],
            "questions": []
          },
          {
            "topicId": 3102,
            "title": "Adapter",
            "summary": "Adapter, RecyclerView ile veri kaynağı arasındaki bağlantıyı sağlar. Her bir item için hangi layout'un kullanılacağını ve verinin nasıl bağlanacağını belirler.",
            "content": "## Adapter\n\nAdapter, RecyclerView'ın kalbidir.\n\nVeri setini ViewHolder ile bağlar.\n\nonCreateViewHolder, onBindViewHolder ve getItemCount metotlarını içerir.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Adapter Yapısı",
                "code": "class MyAdapter(private val list: List<String>) : RecyclerView.Adapter<MyViewHolder>() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)\n        return MyViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        holder.bind(list[position])\n    }\n\n    override fun getItemCount() = list.size\n}",
                "explanation": "RecyclerView Adapter temel yapısı."
              }
            ],
            "keyPoints": [
              "Veri ile UI arasındaki köprüdür",
              "ViewHolder kullanır",
              "Performans için gereklidir",
              "Liste güncellemelerini yönetir"
            ],
            "questions": []
          },
          {
            "topicId": 3103,
            "title": "ViewHolder",
            "summary": "ViewHolder, RecyclerView item'larının görünüm referanslarını tutarak findViewById çağrılarını minimize eder ve performansı artırır.",
            "content": "## ViewHolder\n\nHer item için ViewHolder oluşturulur.\n\nView referanslarını cache'ler.\n\nRecyclerView performansının temel parçalarındandır.",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "ViewHolder Tanımı",
                "code": "class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    fun bind(text: String) {\n        itemView.findViewById<TextView>(R.id.textView).text = text\n    }\n}",
                "explanation": "RecyclerView ViewHolder örneği."
              }
            ],
            "keyPoints": [
              "View referanslarını tutar",
              "Performansı artırır",
              "Adapter ile birlikte çalışır",
              "Her item için kullanılır"
            ],
            "questions": []
          },
          {
            "topicId": 3104,
            "title": "DiffUtil (Opsiyonel)",
            "summary": "DiffUtil, RecyclerView listelerindeki değişiklikleri minimum maliyetle hesaplayarak sadece değişen item'ların güncellenmesini sağlar.",
            "content": "## DiffUtil\n\nListe güncellemelerinde performans sağlar.\n\nnotifyDataSetChanged yerine önerilir.\n\nÖzellikle büyük listelerde fark yaratır.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "DiffUtil Kullanımı",
                "code": "class MyDiffUtil : DiffUtil.ItemCallback<Item>() {\n    override fun areItemsTheSame(oldItem: Item, newItem: Item) = oldItem.id == newItem.id\n\n    override fun areContentsTheSame(oldItem: Item, newItem: Item) = oldItem == newItem\n}",
                "explanation": "DiffUtil ile liste karşılaştırma."
              }
            ],
            "keyPoints": [
              "Performanslı liste güncelleme sağlar",
              "Sadece değişen item'ları günceller",
              "notifyDataSetChanged yerine kullanılır",
              "Large listelerde önerilir"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 31001,
            "question": "RecyclerView’un temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Tek bir View göstermek",
              "Az sayıda veriyi statik göstermek",
              "Büyük veri listelerini performanslı göstermek",
              "Fragment geçişlerini yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "RecyclerView, büyük veri listelerini minimum bellek kullanımıyla performanslı şekilde göstermek için tasarlanmıştır."
          },
          {
            "questionId": 31002,
            "question": "RecyclerView neden ListView’a göre daha avantajlıdır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Daha az kod yazıldığı için",
              "View recycling ve esneklik sağladığı için",
              "Sadece yatay çalıştığı için",
              "XML gerektirmediği için"
            ],
            "correctAnswerIndex": 1,
            "explanation": "RecyclerView, View recycling, ViewHolder pattern ve esnek layout yapıları sayesinde daha performanslıdır."
          },
          {
            "questionId": 31003,
            "question": "RecyclerView’da item’ların nasıl görüneceğini belirleyen yapı hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Activity",
              "Adapter",
              "ViewHolder",
              "LayoutManager"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Adapter, veri ile View’ları bağlayan ve item görünümünü yöneten sınıftır."
          },
          {
            "questionId": 31004,
            "question": "ViewHolder’ın temel görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Veri çekmek",
              "UI çizmek",
              "View referanslarını tutmak",
              "Listeyi sıralamak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewHolder, itemView içindeki View referanslarını tutarak performansı artırır."
          },
          {
            "questionId": 31005,
            "question": "RecyclerView’da ViewHolder kullanmanın temel faydası nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Daha fazla bellek kullanmak",
              "findViewById çağrılarını azaltmak",
              "Thread sayısını artırmak",
              "Veriyi cache’lemek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "ViewHolder, findViewById çağrılarını minimize ederek performansı artırır."
          },
          {
            "questionId": 31006,
            "question": "Adapter içinde hangi metot item sayısını belirtir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "onBindViewHolder",
              "onCreateViewHolder",
              "getItemCount",
              "notifyDataSetChanged"
            ],
            "correctAnswerIndex": 2,
            "explanation": "getItemCount(), RecyclerView’a kaç item gösterileceğini bildirir."
          },
          {
            "questionId": 31007,
            "question": "onCreateViewHolder metodu ne zaman çağrılır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her veri değiştiğinde",
              "Yeni bir View oluşturulması gerektiğinde",
              "Scroll durduğunda",
              "Liste sıfırlandığında"
            ],
            "correctAnswerIndex": 1,
            "explanation": "onCreateViewHolder, yeni bir ViewHolder oluşturulması gerektiğinde çağrılır."
          },
          {
            "questionId": 31008,
            "question": "onBindViewHolder metodunun görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Layout inflate etmek",
              "ViewHolder oluşturmak",
              "Veriyi ViewHolder’a bağlamak",
              "RecyclerView’u başlatmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "onBindViewHolder, veriyi ilgili ViewHolder’a bağlar."
          },
          {
            "questionId": 31009,
            "question": "RecyclerView’da farklı liste düzenleri için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Adapter",
              "ViewHolder",
              "LayoutManager",
              "DiffUtil"
            ],
            "correctAnswerIndex": 2,
            "explanation": "LayoutManager, RecyclerView’un item’ları nasıl yerleştireceğini belirler."
          },
          {
            "questionId": 31010,
            "question": "Aşağıdakilerden hangisi RecyclerView performansını artıran bir yaklaşımdır?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Her seferinde yeni Adapter oluşturmak",
              "notifyDataSetChanged kullanmak",
              "ViewHolder pattern kullanmak",
              "Nested RecyclerView kullanmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewHolder pattern, gereksiz View oluşturmayı azaltarak performansı artırır."
          }
        ]
      },
      {
        "sectionId": 3200,
        "sectionTitle": "Fragment & Navigation",
        "sectionDescription": "Fragment yapısı ve Android Navigation Component kullanarak ekranlar arası geçişlerin yönetilmesi",
        "order": 2,
        "topics": [
          {
            "topicId": 3201,
            "title": "Fragment",
            "summary": "Fragment, bir Activity içerisinde yer alan, kendi yaşam döngüsüne sahip modüler UI bileşenleridir. Tek bir Activity içinde birden fazla Fragment kullanılabilir.",
            "content": "## Fragment\n\nFragment'ler yeniden kullanılabilir UI parçalarıdır.\n\nActivity'lere bağımlı olarak çalışırlar.\n\nModern Android mimarisinde tek Activity - çok Fragment yaklaşımı yaygındır.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Fragment Tanımı",
                "code": "class HomeFragment : Fragment(R.layout.fragment_home)",
                "explanation": "Basit bir Fragment tanımı."
              }
            ],
            "keyPoints": [
              "Activity içinde çalışır",
              "Modüler UI sağlar",
              "Kendi lifecycle'ına sahiptir",
              "Yeniden kullanılabilir"
            ],
            "questions": []
          },
          {
            "topicId": 3202,
            "title": "Fragment Lifecycle",
            "summary": "Fragment Lifecycle, Fragment'in oluşturulmasından yok edilmesine kadar geçen yaşam döngüsünü ifade eder. Activity lifecycle'dan daha karmaşıktır.",
            "content": "## Fragment Lifecycle\n\nonCreate, onCreateView, onViewCreated, onDestroyView gibi metotlar içerir.\n\nUI ve veri işlemleri doğru lifecycle aşamasında yapılmalıdır.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Lifecycle Metodu",
                "code": "override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n}",
                "explanation": "UI işlemleri için önerilen lifecycle metodu."
              }
            ],
            "keyPoints": [
              "Activity lifecycle'dan farklıdır",
              "onDestroyView kritik öneme sahiptir",
              "Memory leak riskleri vardır",
              "Doğru kullanım performansı artırır"
            ],
            "questions": []
          },
          {
            "topicId": 3203,
            "title": "Navigation Component",
            "summary": "Navigation Component, Fragment'ler arası geçişleri güvenli, okunabilir ve merkezi bir şekilde yönetmeyi sağlar.",
            "content": "## Navigation Component\n\nNavigation Graph ile ekranlar tanımlanır.\n\nBackStack otomatik yönetilir.\n\nFragment geçişleri sadeleşir.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "Fragment Geçişi",
                "code": "findNavController().navigate(R.id.action_home_to_detail)",
                "explanation": "Navigation Component ile ekran geçişi."
              }
            ],
            "keyPoints": [
              "Merkezi navigasyon yönetimi",
              "BackStack otomatik yönetilir",
              "Fragment geçişleri kolaylaşır",
              "Best practice olarak önerilir"
            ],
            "questions": []
          },
          {
            "topicId": 3204,
            "title": "Safe Args",
            "summary": "Safe Args, Navigation Component ile Fragment'ler arasında tip güvenli veri aktarımı yapılmasını sağlar.",
            "content": "## Safe Args\n\nCompile-time güvenlik sağlar.\n\nYanlış key kullanımını engeller.\n\nParcelable ve Serializable destekler.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Safe Args Kullanımı",
                "code": "val action = HomeFragmentDirections.actionHomeToDetail(userId)\nfindNavController().navigate(action)",
                "explanation": "Safe Args ile veri gönderme."
              }
            ],
            "keyPoints": [
              "Tip güvenlidir",
              "Runtime hataları azaltır",
              "Navigation Component ile çalışır",
              "Önerilen veri aktarım yöntemidir"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 32001,
            "question": "Fragment nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Bağımsız çalışan bir uygulama bileşeni",
              "Activity içinde çalışan yeniden kullanılabilir UI parçası",
              "Sadece veri saklamak için kullanılan yapı",
              "Sadece Navigation Component ile çalışan yapı"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Fragment, bir Activity içinde çalışan ve yeniden kullanılabilen UI bileşenidir."
          },
          {
            "questionId": 32002,
            "question": "Aşağıdakilerden hangisi Fragment lifecycle metodlarından biri değildir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "onAttach()",
              "onCreateView()",
              "onStart()",
              "onNewIntent()"
            ],
            "correctAnswerIndex": 3,
            "explanation": "onNewIntent(), Activity lifecycle metodudur, Fragment lifecycle’a ait değildir."
          },
          {
            "questionId": 32003,
            "question": "Fragment içinde layout inflate işlemi hangi metotta yapılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "onCreate()",
              "onViewCreated()",
              "onCreateView()",
              "onAttach()"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fragment layout’u onCreateView() metodu içinde inflate edilir."
          },
          {
            "questionId": 32004,
            "question": "Fragment ile Activity arasında güvenli iletişim kurmak için önerilen yöntem hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Global değişken kullanmak",
              "Interface (callback) kullanmak",
              "Static değişken kullanmak",
              "Thread kullanmak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Fragment-Activity iletişiminde en yaygın ve güvenli yöntem interface (callback) kullanmaktır."
          },
          {
            "questionId": 32005,
            "question": "Navigation Component’in temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Fragment performansını artırmak",
              "Ekran geçişlerini ve back stack yönetimini kolaylaştırmak",
              "Veri tabanı işlemlerini yönetmek",
              "UI bileşenlerini otomatik oluşturmak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Component, ekran geçişlerini ve geri tuşu davranışını merkezi şekilde yönetir."
          },
          {
            "questionId": 32006,
            "question": "Navigation Component kullanılırken ekran geçişleri hangi dosyada tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "AndroidManifest.xml",
              "activity_main.xml",
              "nav_graph.xml",
              "styles.xml"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Navigation işlemleri nav_graph.xml dosyasında tanımlanır."
          },
          {
            "questionId": 32007,
            "question": "Safe Args ne işe yarar?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Fragment lifecycle hatalarını önler",
              "Fragmentlar arası tip güvenli veri aktarımı sağlar",
              "Navigation hızını artırır",
              "Bundle kullanımını tamamen kaldırır"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe Args, Fragmentlar arasında tip güvenli veri aktarımı yapılmasını sağlar."
          },
          {
            "questionId": 32008,
            "question": "Safe Args kullanmanın en büyük avantajı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Daha az XML yazılması",
              "Runtime hatalarının azalması",
              "Uygulamanın daha hızlı çalışması",
              "Navigation Component ihtiyacını kaldırması"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe Args sayesinde yanlış tipte veri gönderme gibi runtime hataları büyük ölçüde azalır."
          },
          {
            "questionId": 32009,
            "question": "Fragment içinde view erişimi için güncel ve önerilen yöntem hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "findViewById",
              "Kotlin synthetic",
              "View Binding",
              "Static view referansı"
            ],
            "correctAnswerIndex": 2,
            "explanation": "View Binding, type-safe ve lifecycle uyumlu olduğu için önerilir."
          },
          {
            "questionId": 32010,
            "question": "Navigation Component geri tuşu davranışını nasıl yönetir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Manuel olarak override edilmelidir",
              "Back stack’e göre otomatik yönetir",
              "Sadece Activity içinde çalışır",
              "Fragment’larda çalışmaz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Component, back stack’e göre geri tuşu davranışını otomatik yönetir."
          }
        ]
      },
      {
        "sectionId": 3300,
        "sectionTitle": "Veritabanı (Room)",
        "sectionDescription": "Android uygulamalarda yerel veritabanı kullanımı ve Room kütüphanesinin temel bileşenleri",
        "order": 3,
        "topics": [
          {
            "topicId": 3301,
            "title": "SQLite Temelleri",
            "summary": "SQLite, Android cihazlarda yerleşik olarak bulunan hafif ve ilişkisel bir veritabanıdır. Tablolar, satırlar ve sütunlar üzerinden veri saklar. Android'de uzun süreli ve kalıcı veri saklamak için kullanılır.",
            "content": "## SQLite Temelleri\n\nSQLite ilişkisel bir veritabanıdır.\n\nSQL sorguları ile veri ekleme, silme, güncelleme ve okuma işlemleri yapılır.\n\nRoom, SQLite üzerinde çalışan bir soyutlama katmanıdır.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Android'e gömülü gelir",
              "İlişkisel veritabanıdır",
              "SQL tabanlıdır",
              "Room altyapı olarak SQLite kullanır"
            ],
            "questions": []
          },
          {
            "topicId": 3302,
            "title": "Entity",
            "summary": "Entity, Room veritabanında bir tabloyu temsil eden Kotlin sınıfıdır. Her Entity sınıfı bir tabloya, her property ise bir sütuna karşılık gelir.",
            "content": "## Entity\n\n@Entity anotasyonu ile tanımlanır.\n\nPrimary key zorunludur.\n\nVeritabanı şemasını temsil eder.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Entity Örneği",
                "code": "@Entity\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val name: String,\n    val age: Int\n)",
                "explanation": "User tablosunu temsil eden bir Entity sınıfı."
              }
            ],
            "keyPoints": [
              "Tabloyu temsil eder",
              "PrimaryKey zorunludur",
              "data class olarak tanımlanır",
              "@Entity anotasyonu kullanılır"
            ],
            "questions": []
          },
          {
            "topicId": 3303,
            "title": "DAO",
            "summary": "DAO (Data Access Object), veritabanı işlemlerinin tanımlandığı arayüzdür. SQL sorguları bu katmanda yazılır ve veriye erişim buradan sağlanır.",
            "content": "## DAO\n\n@Dao anotasyonu ile tanımlanır.\n\nInsert, Delete, Update ve Query metotları içerir.\n\nVeri erişim katmanıdır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "DAO Örneği",
                "code": "@Dao\ninterface UserDao {\n    @Insert\n    suspend fun insert(user: User)\n\n    @Query(\"SELECT * FROM User\")\n    suspend fun getAllUsers(): List<User>\n}",
                "explanation": "User tablosu için DAO tanımı."
              }
            ],
            "keyPoints": [
              "Veri erişim katmanıdır",
              "SQL sorguları burada yazılır",
              "Interface olarak tanımlanır",
              "Suspend fonksiyonlarla çalışabilir"
            ],
            "questions": []
          },
          {
            "topicId": 3304,
            "title": "Database",
            "summary": "Database sınıfı, Room veritabanının ana erişim noktasıdır. Entity ve DAO'ları bir araya getirir ve singleton olarak kullanılır.",
            "content": "## Database\n\n@Database anotasyonu ile tanımlanır.\n\nAbstract class olmalıdır.\n\nVeritabanı versiyonlamasını yönetir.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Database Tanımı",
                "code": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}",
                "explanation": "Room Database tanımı."
              }
            ],
            "keyPoints": [
              "RoomDatabase'den türetilir",
              "Singleton olarak kullanılır",
              "DAO'lara erişim sağlar",
              "Version yönetimi içerir"
            ],
            "questions": []
          },
          {
            "topicId": 3305,
            "title": "CRUD İşlemleri",
            "summary": "CRUD işlemleri, Create (Ekle), Read (Oku), Update (Güncelle) ve Delete (Sil) işlemlerini ifade eder. Room ile bu işlemler anotasyonlar sayesinde kolayca yapılır.",
            "content": "## CRUD İşlemleri\n\nInsert, Query, Update ve Delete anotasyonları kullanılır.\n\nSuspend fonksiyonlarla arka planda çalıştırılmalıdır.",
            "difficulty": "medium",
            "order": 5,
            "codeExamples": [
              {
                "title": "CRUD Örneği",
                "code": "@Update\nsuspend fun updateUser(user: User)\n\n@Delete\nsuspend fun deleteUser(user: User)",
                "explanation": "Room ile güncelleme ve silme işlemleri."
              }
            ],
            "keyPoints": [
              "CRUD = Create, Read, Update, Delete",
              "Room anotasyonları ile yapılır",
              "Suspend fonksiyon önerilir",
              "Ana thread bloklanmamalıdır"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 33001,
            "question": "Room kütüphanesinin Android’de kullanılma amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "UI tasarlamak",
              "SQLite işlemlerini daha güvenli ve kolay yapmak",
              "Network isteklerini yönetmek",
              "Fragment geçişlerini sağlamak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Room, SQLite üzerinde çalışan, type-safe ve kolay veritabanı işlemleri sunan bir ORM kütüphanesidir."
          },
          {
            "questionId": 33002,
            "question": "SQLite nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Sunucu tabanlı veritabanı",
              "Bulut veritabanı",
              "Android cihaz üzerinde çalışan yerel veritabanı",
              "Sadece geçici veri tutan yapı"
            ],
            "correctAnswerIndex": 2,
            "explanation": "SQLite, Android cihaz üzerinde çalışan yerel (embedded) bir ilişkisel veritabanıdır."
          },
          {
            "questionId": 33003,
            "question": "Room’da bir tabloyu temsil eden yapı hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "DAO",
              "Entity",
              "Database",
              "Repository"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Entity, veritabanındaki bir tabloyu temsil eder."
          },
          {
            "questionId": 33004,
            "question": "Entity sınıfında primary key tanımlamak için hangi annotation kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "@ColumnInfo",
              "@PrimaryKey",
              "@EntityKey",
              "@Id"
            ],
            "correctAnswerIndex": 1,
            "explanation": "@PrimaryKey annotation’ı tablo için birincil anahtar tanımlar."
          },
          {
            "questionId": 33005,
            "question": "DAO’nun (Data Access Object) temel görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Veritabanı bağlantısını başlatmak",
              "UI ile veritabanı arasındaki iletişimi sağlamak",
              "Veritabanı CRUD işlemlerini tanımlamak",
              "Tablo şemasını oluşturmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "DAO, veritabanı üzerinde yapılacak CRUD işlemlerini tanımlar."
          },
          {
            "questionId": 33006,
            "question": "Room Database sınıfı ne işe yarar?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Tabloları tanımlar",
              "DAO’lara erişim sağlar",
              "UI bileşenlerini yönetir",
              "Network işlemlerini yapar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Database sınıfı, Room veritabanını temsil eder ve DAO’lara erişimi sağlar."
          },
          {
            "questionId": 33007,
            "question": "Aşağıdakilerden hangisi CRUD işlemlerinden biri değildir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Create",
              "Read",
              "Update",
              "Render"
            ],
            "correctAnswerIndex": 3,
            "explanation": "CRUD işlemleri Create, Read, Update ve Delete’den oluşur."
          },
          {
            "questionId": 33008,
            "question": "Room’da veri ekleme işlemi için genellikle hangi annotation kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "@Query",
              "@Insert",
              "@Update",
              "@Delete"
            ],
            "correctAnswerIndex": 1,
            "explanation": "@Insert annotation’ı veritabanına veri eklemek için kullanılır."
          },
          {
            "questionId": 33009,
            "question": "Room ile çalışırken veritabanı işlemlerinin main thread’de yapılmamasının sebebi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Derleme hatası oluşur",
              "UI donmalarını önlemek",
              "Veri kaybını önlemek",
              "Room bunu zorunlu kılar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Main thread’de yapılan veritabanı işlemleri UI donmasına (ANR) sebep olabilir."
          },
          {
            "questionId": 33010,
            "question": "Room ile MVVM mimarisi birlikte kullanıldığında DAO genellikle hangi katman tarafından çağrılır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Activity",
              "Fragment",
              "ViewModel",
              "Repository"
            ],
            "correctAnswerIndex": 3,
            "explanation": "MVVM mimarisinde DAO’ya doğrudan ViewModel değil, Repository erişir."
          }
        ]
      },
      {
        "sectionId": 3400,
        "sectionTitle": "MVVM Mimarisi",
        "sectionDescription": "Android uygulamalarda sürdürülebilir, test edilebilir ve okunabilir mimari yapı kurmak için kullanılan MVVM yaklaşımı",
        "order": 4,
        "topics": [
          {
            "topicId": 3401,
            "title": "MVVM Nedir",
            "summary": "MVVM (Model-View-ViewModel), kullanıcı arayüzü ile iş mantığını birbirinden ayırmayı amaçlayan bir mimari tasarım desenidir. Kodun daha okunabilir, test edilebilir ve sürdürülebilir olmasını sağlar.",
            "content": "## MVVM Nedir\n\nMVVM üç ana bileşenden oluşur:\n\n- Model: Veri katmanı\n- View: UI katmanı\n- ViewModel: İş mantığı ve state yönetimi\n\nAndroid'de Google tarafından önerilen mimaridir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Katmanlı mimari sağlar",
              "UI ve iş mantığını ayırır",
              "Test edilebilirliği artırır",
              "Modern Android için önerilir"
            ],
            "questions": []
          },
          {
            "topicId": 3402,
            "title": "ViewModel",
            "summary": "ViewModel, UI ile ilişkili verileri saklayan ve yöneten bileşendir. Configuration change (ekran döndürme gibi) durumlarında verinin kaybolmasını engeller.",
            "content": "## ViewModel\n\nViewModel, lifecycle-aware bir bileşendir.\n\nUI logic burada tutulur.\n\nActivity ve Fragment'tan bağımsızdır.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "ViewModel Tanımı",
                "code": "class MainViewModel : ViewModel() {\n    val counter = MutableLiveData<Int>()\n}",
                "explanation": "Basit bir ViewModel örneği."
              }
            ],
            "keyPoints": [
              "Lifecycle-aware çalışır",
              "UI verisini tutar",
              "Configuration change'lerde silinmez",
              "Business logic içerir"
            ],
            "questions": []
          },
          {
            "topicId": 3403,
            "title": "LiveData",
            "summary": "LiveData, lifecycle-aware ve gözlemlenebilir bir veri tutucudur. UI katmanı, veri değişikliklerini otomatik olarak takip eder.",
            "content": "## LiveData\n\nObserver pattern kullanır.\n\nLifecycle'a duyarlıdır.\n\nMemory leak riskini azaltır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "LiveData Kullanımı",
                "code": "viewModel.counter.observe(viewLifecycleOwner) {\n    textView.text = it.toString()\n}",
                "explanation": "LiveData gözlemlenmesi."
              }
            ],
            "keyPoints": [
              "Observer pattern kullanır",
              "Lifecycle-aware'dır",
              "UI otomatik güncellenir",
              "Thread-safe veri akışı sağlar"
            ],
            "questions": []
          },
          {
            "topicId": 3404,
            "title": "Repository",
            "summary": "Repository, veri kaynaklarını (API, Room, Cache) tek bir noktadan yöneten katmandır. ViewModel'in veri kaynağına doğrudan erişmesini engeller.",
            "content": "## Repository\n\nTek sorumluluk prensibini destekler.\n\nVeri kaynaklarını soyutlar.\n\nViewModel ile data source arasında köprü görevi görür.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Repository Örneği",
                "code": "class UserRepository(private val dao: UserDao) {\n    suspend fun getUsers() = dao.getAllUsers()\n}",
                "explanation": "Room kullanan basit bir Repository örneği."
              }
            ],
            "keyPoints": [
              "Veri kaynaklarını soyutlar",
              "ViewModel bağımlılığını azaltır",
              "Test yazımını kolaylaştırır",
              "Clean Architecture'a uygundur"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 34001,
            "question": "MVVM mimarisinin temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "UI tasarımını kolaylaştırmak",
              "Veri tabanı işlemlerini hızlandırmak",
              "UI ile iş mantığını birbirinden ayırmak",
              "Network işlemlerini yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "MVVM, kullanıcı arayüzü ile iş mantığını ayırarak daha sürdürülebilir ve test edilebilir bir yapı sağlar."
          },
          {
            "questionId": 34002,
            "question": "MVVM mimarisinde View katmanı aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Repository",
              "ViewModel",
              "Activity / Fragment",
              "Model"
            ],
            "correctAnswerIndex": 2,
            "explanation": "View katmanı Android’de genellikle Activity veya Fragment’tır."
          },
          {
            "questionId": 34003,
            "question": "ViewModel’in en önemli avantajı aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "UI çizimini yapması",
              "Context’e erişebilmesi",
              "Configuration change’lerde veriyi koruması",
              "Veritabanı bağlantısını yönetmesi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewModel, ekran döndürme gibi durumlarda veriyi korur."
          },
          {
            "questionId": 34004,
            "question": "ViewModel hangi bileşenden bağımsız çalışmalıdır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Repository",
              "LiveData",
              "Activity / Fragment",
              "Model"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewModel, Activity veya Fragment’a doğrudan bağımlı olmamalıdır."
          },
          {
            "questionId": 34005,
            "question": "LiveData’nın temel özelliği aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Thread yönetimi yapması",
              "Lifecycle-aware olması",
              "Veritabanı işlemleri yapması",
              "Network isteklerini yönetmesi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "LiveData, lifecycle-aware bir veri tutucudur."
          },
          {
            "questionId": 34006,
            "question": "LiveData kullanmanın en büyük avantajlarından biri nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "UI güncellemelerini manuel yapmak",
              "Memory leak riskini azaltmak",
              "Daha hızlı veritabanı işlemleri",
              "Daha az kod yazmak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "LiveData, lifecycle-aware olduğu için memory leak riskini azaltır."
          },
          {
            "questionId": 34007,
            "question": "Repository katmanının temel görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "UI güncellemek",
              "ViewModel oluşturmak",
              "Veri kaynaklarını tek noktadan yönetmek",
              "Navigation işlemlerini yapmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Repository, API, Room gibi veri kaynaklarını tek noktadan yönetir."
          },
          {
            "questionId": 34008,
            "question": "MVVM mimarisinde ViewModel genellikle hangi katmanla doğrudan iletişim kurar?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Activity / Fragment",
              "Repository",
              "Database",
              "Network"
            ],
            "correctAnswerIndex": 1,
            "explanation": "ViewModel, veriyi Repository üzerinden alır."
          },
          {
            "questionId": 34009,
            "question": "LiveData hangi tasarım desenini temel alır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Singleton",
              "Factory",
              "Observer",
              "Builder"
            ],
            "correctAnswerIndex": 2,
            "explanation": "LiveData, Observer pattern üzerine kuruludur."
          },
          {
            "questionId": 34010,
            "question": "MVVM mimarisinin test edilebilirliği artırmasının temel sebebi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Daha az sınıf kullanması",
              "UI ve iş mantığının ayrılması",
              "Daha hızlı çalışması",
              "Context kullanımının artması"
            ],
            "correctAnswerIndex": 1,
            "explanation": "UI ve iş mantığının ayrılması, unit test yazmayı kolaylaştırır."
          }
        ]
      },
      {
        "sectionId": 3500,
        "sectionTitle": "Networking",
        "sectionDescription": "Android uygulamalarda internet üzerinden veri alışverişi yapmak için kullanılan temel networking kavramları ve araçlar",
        "order": 5,
        "topics": [
          {
            "topicId": 3501,
            "title": "REST API",
            "summary": "REST API, istemci ve sunucu arasında HTTP protokolü üzerinden veri alışverişi yapılmasını sağlayan mimari bir yaklaşımdır. Genellikle JSON formatında veri iletimi kullanılır.",
            "content": "## REST API\n\nREST, stateless bir mimaridir.\n\nKaynaklar URL üzerinden erişilir.\n\nMobil uygulamalar backend servislerle genellikle REST API üzerinden haberleşir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Stateless mimari kullanır",
              "HTTP protokolü üzerinden çalışır",
              "JSON en yaygın veri formatıdır",
              "Mobil-backend iletişimin temelidir"
            ],
            "questions": []
          },
          {
            "topicId": 3502,
            "title": "Retrofit",
            "summary": "Retrofit, Android ve Java/Kotlin projelerinde REST API çağrılarını kolay ve güvenli şekilde yapmayı sağlayan popüler bir networking kütüphanesidir.",
            "content": "## Retrofit\n\nInterface tabanlı çalışır.\n\nHTTP isteklerini annotation'lar ile tanımlar.\n\nOkHttp üzerine kuruludur.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Retrofit Interface",
                "code": "interface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List<User>\n}",
                "explanation": "Basit bir Retrofit API tanımı."
              }
            ],
            "keyPoints": [
              "Interface tabanlıdır",
              "Coroutine ve RxJava desteği vardır",
              "OkHttp ile birlikte çalışır",
              "API çağrılarını sadeleştirir"
            ],
            "questions": []
          },
          {
            "topicId": 3503,
            "title": "HTTP İstek Türleri",
            "summary": "HTTP istek türleri, istemcinin sunucuya ne tür bir işlem yapmak istediğini belirtir. En yaygın olanları GET, POST, PUT ve DELETE'tir.",
            "content": "## HTTP İstek Türleri\n\nGET: Veri almak\nPOST: Veri göndermek\nPUT: Veri güncellemek\nDELETE: Veri silmek",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "POST İsteği",
                "code": "@POST(\"users\")\nsuspend fun createUser(@Body user: User): Response<User>",
                "explanation": "Retrofit ile POST isteği örneği."
              }
            ],
            "keyPoints": [
              "GET veri almak için kullanılır",
              "POST veri ekler",
              "PUT veri günceller",
              "DELETE veri siler"
            ],
            "questions": []
          },
          {
            "topicId": 3504,
            "title": "JSON Parsing",
            "summary": "JSON Parsing, sunucudan gelen JSON formatındaki verinin Kotlin nesnelerine dönüştürülmesi işlemidir. Retrofit genellikle Gson veya Moshi ile birlikte kullanılır.",
            "content": "## JSON Parsing\n\nJSON, anahtar-değer yapısına sahiptir.\n\nModel class'lar ile parse edilir.\n\nOtomatik dönüşüm sağlar.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Data Class",
                "code": "data class User(\n    val id: Int,\n    val name: String\n)",
                "explanation": "JSON verisini temsil eden data class."
              }
            ],
            "keyPoints": [
              "JSON en yaygın veri formatıdır",
              "Data class ile eşleştirilir",
              "Gson / Moshi kullanılır",
              "Retrofit ile otomatik parse edilir"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 35001,
            "question": "REST API’nin temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "UI tasarımı yapmak",
              "Verileri istemci ve sunucu arasında iletmek",
              "Veritabanı oluşturmak",
              "Android lifecycle yönetmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "REST API, istemci ile sunucu arasında veri alışverişi yapılmasını sağlar."
          },
          {
            "questionId": 35002,
            "question": "REST mimarisinde veri genellikle hangi formatta gönderilir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "XML",
              "CSV",
              "JSON",
              "TXT"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Günümüzde REST API’lerde en yaygın kullanılan veri formatı JSON’dur."
          },
          {
            "questionId": 35003,
            "question": "Retrofit kütüphanesinin Android’deki temel görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "UI bileşenlerini yönetmek",
              "HTTP isteklerini kolaylaştırmak",
              "Veritabanı işlemleri yapmak",
              "Navigation işlemlerini yönetmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Retrofit, HTTP isteklerini basit ve okunabilir hale getiren bir networking kütüphanesidir."
          },
          {
            "questionId": 35004,
            "question": "Retrofit’te API istekleri genellikle hangi yapı ile tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Activity",
              "Fragment",
              "Interface",
              "Repository"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Retrofit’te API endpoint’leri interface içerisinde tanımlanır."
          },
          {
            "questionId": 35005,
            "question": "Aşağıdakilerden hangisi bir HTTP GET isteğinin amacıdır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Yeni veri eklemek",
              "Veri silmek",
              "Veri güncellemek",
              "Veri almak"
            ],
            "correctAnswerIndex": 3,
            "explanation": "GET isteği sunucudan veri almak için kullanılır."
          },
          {
            "questionId": 35006,
            "question": "Yeni bir veri oluşturmak için hangi HTTP isteği kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "GET",
              "POST",
              "PUT",
              "DELETE"
            ],
            "correctAnswerIndex": 1,
            "explanation": "POST isteği sunucuya yeni veri eklemek için kullanılır."
          },
          {
            "questionId": 35007,
            "question": "PUT ve PATCH isteklerinin temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Veri silmek",
              "Veri almak",
              "Var olan veriyi güncellemek",
              "Sunucu kapatmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "PUT ve PATCH, var olan veriyi güncellemek için kullanılır."
          },
          {
            "questionId": 35008,
            "question": "JSON Parsing işlemi ne anlama gelir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "JSON dosyasını silmek",
              "JSON verisini model sınıflarına dönüştürmek",
              "JSON oluşturmak",
              "JSON’u şifrelemek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "JSON Parsing, gelen JSON verisinin Kotlin/Java nesnelerine dönüştürülmesidir."
          },
          {
            "questionId": 35009,
            "question": "Retrofit ile JSON parsing işlemi genellikle hangi kütüphane ile yapılır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Room",
              "Gson / Moshi",
              "LiveData",
              "Glide"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Retrofit, JSON parsing için Gson veya Moshi gibi converter’lar kullanır."
          },
          {
            "questionId": 35010,
            "question": "HTTP DELETE isteğinin temel görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Veri almak",
              "Veri eklemek",
              "Veri güncellemek",
              "Veri silmek"
            ],
            "correctAnswerIndex": 3,
            "explanation": "DELETE isteği sunucudaki veriyi silmek için kullanılır."
          }
        ]
      },
      {
        "sectionId": 3600,
        "sectionTitle": "Firebase",
        "sectionDescription": "Google Firebase kullanarak backend ihtiyacı olmadan kimlik doğrulama, veritabanı, dosya depolama ve güvenlik yönetimi",
        "order": 6,
        "topics": [
          {
            "topicId": 3601,
            "title": "Authentication",
            "summary": "Firebase Authentication, kullanıcıların e-posta/şifre, Google, Facebook gibi yöntemlerle güvenli bir şekilde giriş yapmasını sağlayan kimlik doğrulama servisidir.",
            "content": "## Authentication\n\nKullanıcı yönetimini kolaylaştırır.\n\nHazır giriş yöntemleri sunar.\n\nBackend yazmaya gerek kalmaz.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Email ile Giriş",
                "code": "FirebaseAuth.getInstance()\n    .signInWithEmailAndPassword(email, password)",
                "explanation": "Firebase ile e-posta ve şifre kullanarak giriş işlemi."
              }
            ],
            "keyPoints": [
              "Hazır authentication altyapısı sunar",
              "Email, Google, Facebook desteği vardır",
              "Güvenli kullanıcı yönetimi sağlar",
              "Kolay entegrasyon sunar"
            ],
            "questions": []
          },
          {
            "topicId": 3602,
            "title": "Firestore",
            "summary": "Firestore, NoSQL tabanlı, gerçek zamanlı veri senkronizasyonu sağlayan bulut veritabanıdır. Koleksiyon ve doküman yapısı ile çalışır.",
            "content": "## Firestore\n\nNoSQL mimarisi kullanır.\n\nGerçek zamanlı veri güncellemeleri sunar.\n\nOffline desteklidir.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Veri Ekleme",
                "code": "FirebaseFirestore.getInstance()\n    .collection(\"users\")\n    .add(user)",
                "explanation": "Firestore'a veri ekleme örneği."
              }
            ],
            "keyPoints": [
              "NoSQL tabanlıdır",
              "Gerçek zamanlı çalışır",
              "Offline desteği vardır",
              "Koleksiyon-doküman yapısı kullanır"
            ],
            "questions": []
          },
          {
            "topicId": 3603,
            "title": "Storage",
            "summary": "Firebase Storage, kullanıcıların yüklediği görsel, video ve dosyaları güvenli bir şekilde saklamak için kullanılan bulut depolama servisidir.",
            "content": "## Storage\n\nDosya depolama için kullanılır.\n\nBüyük dosyalar için uygundur.\n\nAuthentication ile entegre çalışır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "Dosya Yükleme",
                "code": "FirebaseStorage.getInstance()\n    .reference\n    .child(\"images/photo.jpg\")\n    .putFile(uri)",
                "explanation": "Firebase Storage'a dosya yükleme."
              }
            ],
            "keyPoints": [
              "Dosya ve medya depolama sağlar",
              "Güvenli erişim sunar",
              "Authentication ile birlikte çalışır",
              "Yüksek ölçeklenebilirlik sunar"
            ],
            "questions": []
          },
          {
            "topicId": 3604,
            "title": "Security Rules",
            "summary": "Firebase Security Rules, Firestore ve Storage üzerinde kimlerin hangi verilere erişebileceğini tanımlamak için kullanılan güvenlik kurallarıdır.",
            "content": "## Security Rules\n\nYetkilendirme ve doğrulama sağlar.\n\nAuthentication bilgileri ile çalışır.\n\nVeri güvenliği için kritiktir.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Basit Firestore Kuralı",
                "code": "allow read, write: if request.auth != null;",
                "explanation": "Sadece giriş yapmış kullanıcıların erişmesine izin veren kural."
              }
            ],
            "keyPoints": [
              "Veri güvenliğini sağlar",
              "Authentication ile entegredir",
              "Yetkisiz erişimi engeller",
              "Prod ortamda mutlaka tanımlanmalıdır"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 36001,
            "question": "Firebase Authentication’ın temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Veritabanı oluşturmak",
              "Kullanıcı kimlik doğrulaması yapmak",
              "Dosya depolamak",
              "UI yönetmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firebase Authentication, kullanıcıların uygulamaya güvenli şekilde giriş yapmasını sağlar."
          },
          {
            "questionId": 36002,
            "question": "Firebase Authentication aşağıdaki giriş yöntemlerinden hangisini destekler?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Sadece e-posta & şifre",
              "Sadece Google hesabı",
              "Telefon numarası",
              "Hepsi"
            ],
            "correctAnswerIndex": 3,
            "explanation": "Firebase Authentication; e-posta, Google, telefon numarası ve daha birçok giriş yöntemini destekler."
          },
          {
            "questionId": 36003,
            "question": "Firestore nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "SQL tabanlı yerel veritabanı",
              "Bulut tabanlı NoSQL veritabanı",
              "Dosya depolama servisi",
              "Kimlik doğrulama servisi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firestore, Firebase’in sunduğu bulut tabanlı ve NoSQL yapıya sahip bir veritabanıdır."
          },
          {
            "questionId": 36004,
            "question": "Firestore’da veriler hangi yapı ile saklanır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Table ve Row",
              "Collection ve Document",
              "File ve Folder",
              "Key ve Value"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firestore verileri collection ve document yapısı ile saklar."
          },
          {
            "questionId": 36005,
            "question": "Firebase Storage ne amaçla kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Kullanıcı bilgisi tutmak",
              "JSON veri saklamak",
              "Resim, video gibi dosyaları saklamak",
              "API çağrıları yapmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Firebase Storage, büyük boyutlu dosyaların (resim, video vb.) saklanması için kullanılır."
          },
          {
            "questionId": 36006,
            "question": "Firebase Storage ile en sık hangi tür veriler saklanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Kullanıcı token’ları",
              "Resimler ve videolar",
              "Lifecycle verileri",
              "Intent verileri"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firebase Storage genellikle medya dosyaları için kullanılır."
          },
          {
            "questionId": 36007,
            "question": "Firebase Security Rules’un temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "UI performansını artırmak",
              "Veri erişim yetkilerini kontrol etmek",
              "Veritabanını hızlandırmak",
              "Authentication’ı devre dışı bırakmak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Security Rules, hangi kullanıcının hangi verilere erişebileceğini belirler."
          },
          {
            "questionId": 36008,
            "question": "Firestore Security Rules hangi kriterlere göre yazılabilir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Kullanıcı kimliği",
              "Authentication durumu",
              "Belge içeriği",
              "Hepsi"
            ],
            "correctAnswerIndex": 3,
            "explanation": "Firestore Security Rules; kullanıcı, authentication durumu ve veri içeriğine göre yazılabilir."
          },
          {
            "questionId": 36009,
            "question": "Aşağıdakilerden hangisi Firebase’in en büyük avantajlarından biridir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Sadece offline çalışması",
              "Backend gerektirmemesi",
              "Sadece Android’de çalışması",
              "SQL zorunluluğu"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firebase, çoğu backend ihtiyacını hazır servislerle karşılar."
          },
          {
            "questionId": 36010,
            "question": "Firebase servisleri genellikle hangi mimari katmanda kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "View",
              "ViewModel",
              "Repository",
              "Activity"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Firebase servisleri genellikle Repository katmanında kullanılarak mimari ayrım sağlanır."
          }
        ]
      },
      {
        "sectionId": 3700,
        "sectionTitle": "Konum & Harita",
        "sectionDescription": "Android uygulamalarda kullanıcı konumunu almak, harita üzerinde göstermek ve rota işlemleri yapmak",
        "order": 7,
        "topics": [
          {
            "topicId": 3701,
            "title": "Google Maps",
            "summary": "Google Maps SDK, Android uygulamalarında harita gösterimi ve harita üzerinde etkileşimli işlemler yapılmasını sağlayan resmi Google servisidir.",
            "content": "## Google Maps\n\nGoogle Maps SDK kullanılarak harita uygulamaya entegre edilir.\n\nAPI Key gerektirir.\n\nMarker, kamera hareketleri ve rota çizimi desteklenir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Harita Hazırlama",
                "code": "override fun onMapReady(googleMap: GoogleMap) {\n    map = googleMap\n}",
                "explanation": "Google Maps hazır olduğunda çağrılan metot."
              }
            ],
            "keyPoints": [
              "Google Maps SDK kullanılır",
              "API Key zorunludur",
              "Harita etkileşimleri desteklenir",
              "Modern uygulamalarda yaygındır"
            ],
            "questions": []
          },
          {
            "topicId": 3702,
            "title": "Location Permission",
            "summary": "Android'de kullanıcı konumuna erişmek için runtime permission mekanizması kullanılır. Kullanıcının açık izni olmadan konum bilgisi alınamaz.",
            "content": "## Location Permission\n\nACCESS_FINE_LOCATION ve ACCESS_COARSE_LOCATION izinleri kullanılır.\n\nAndroid 6.0 sonrası runtime permission zorunludur.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Permission Kontrolü",
                "code": "if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)\n    != PackageManager.PERMISSION_GRANTED) {\n    requestPermissions(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), 100)\n}",
                "explanation": "Konum izni kontrolü ve isteme."
              }
            ],
            "keyPoints": [
              "Runtime permission zorunludur",
              "Kullanıcı onayı gerekir",
              "Fine ve Coarse location farkı vardır",
              "Yanlış kullanım crash'e yol açabilir"
            ],
            "questions": []
          },
          {
            "topicId": 3703,
            "title": "Marker",
            "summary": "Marker, Google Maps üzerinde belirli bir konumu işaretlemek için kullanılan görsel işaretleyicilerdir.",
            "content": "## Marker\n\nHarita üzerinde konum göstermek için kullanılır.\n\nBaşlık ve açıklama eklenebilir.",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "Marker Ekleme",
                "code": "val location = LatLng(41.0082, 28.9784)\nmap.addMarker(MarkerOptions().position(location).title(\"İstanbul\"))",
                "explanation": "Harita üzerine marker ekleme."
              }
            ],
            "keyPoints": [
              "Konum işaretlemek için kullanılır",
              "Başlık ve açıklama eklenebilir",
              "Kullanıcı etkileşimine açıktır",
              "Birden fazla marker eklenebilir"
            ],
            "questions": []
          },
          {
            "topicId": 3704,
            "title": "Route",
            "summary": "Route (rota), iki veya daha fazla nokta arasındaki yolun harita üzerinde çizilmesini ifade eder. Genellikle Directions API ile birlikte kullanılır.",
            "content": "## Route\n\nPolyline kullanılarak çizilir.\n\nDirections API ile rota bilgisi alınır.\n\nNavigasyon uygulamalarında yaygındır.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Polyline Çizimi",
                "code": "map.addPolyline(\n    PolylineOptions().add(startLatLng, endLatLng)\n)",
                "explanation": "İki nokta arasında rota çizimi."
              }
            ],
            "keyPoints": [
              "Polyline ile çizilir",
              "Directions API gerektirir",
              "Navigasyon uygulamalarında kullanılır",
              "Performans dikkat edilmelidir"
            ],
            "questions": []
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 37001,
            "question": "Android uygulamalarda harita kullanmak için en yaygın kullanılan servis hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "OpenStreetMap",
              "Here Maps",
              "Google Maps API",
              "Yandex Maps"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Android uygulamalarda en yaygın kullanılan harita servisi Google Maps API’dir."
          },
          {
            "questionId": 37002,
            "question": "Google Maps kullanabilmek için geliştiricinin alması gereken şey nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Firebase Token",
              "API Key",
              "SHA-1 Sertifikası",
              "OAuth Client ID"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Google Maps API kullanımı için Google Cloud üzerinden bir API Key alınmalıdır."
          },
          {
            "questionId": 37003,
            "question": "Kullanıcının konumuna erişebilmek için hangi izin gereklidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "INTERNET",
              "ACCESS_NETWORK_STATE",
              "ACCESS_FINE_LOCATION",
              "READ_CONTACTS"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ACCESS_FINE_LOCATION izni, kullanıcının hassas konum bilgisine erişmek için kullanılır."
          },
          {
            "questionId": 37004,
            "question": "Konum izinleri hangi Android sürümünden itibaren çalışma zamanında (runtime) istenmektedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Android 4.4",
              "Android 5.0",
              "Android 6.0",
              "Android 8.0"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Android 6.0 (API 23) ile birlikte runtime permission sistemi gelmiştir."
          },
          {
            "questionId": 37005,
            "question": "Google Maps üzerinde belirli bir konumu işaretlemek için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Polyline",
              "Circle",
              "Marker",
              "CameraPosition"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Marker, harita üzerinde belirli bir konumu işaretlemek için kullanılır."
          },
          {
            "questionId": 37006,
            "question": "Bir Marker eklemek için hangi bilgi zorunludur?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Başlık (title)",
              "Açıklama (snippet)",
              "Latitude ve Longitude",
              "Icon"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Marker eklemek için mutlaka latitude ve longitude bilgisi gereklidir."
          },
          {
            "questionId": 37007,
            "question": "Harita üzerinde iki nokta arasında rota çizmek için en çok hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Marker",
              "Polyline",
              "Polygon",
              "Circle"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Polyline, harita üzerinde rota veya yol çizmek için kullanılır."
          },
          {
            "questionId": 37008,
            "question": "Gerçek zamanlı konum güncellemeleri almak için genellikle hangi API tercih edilir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Camera API",
              "Sensor API",
              "Fused Location Provider",
              "Bluetooth API"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fused Location Provider, düşük pil tüketimiyle konum verisi sağlar."
          },
          {
            "questionId": 37009,
            "question": "Kullanıcıdan konum izni alınmadan konum verisi çekilmeye çalışılırsa ne olur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulama normal çalışır",
              "Compile-time hatası oluşur",
              "Runtime exception oluşabilir",
              "Uygulama otomatik izin verir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Runtime permission verilmeden konum erişimi yapılırsa uygulama çökebilir."
          },
          {
            "questionId": 37010,
            "question": "Google Maps üzerinde kamerayı belirli bir konuma odaklamak için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "MarkerOptions",
              "LatLng",
              "CameraUpdate",
              "MapStyle"
            ],
            "correctAnswerIndex": 2,
            "explanation": "CameraUpdate, harita kamerasını belirli bir konuma veya yakınlaştırma seviyesine taşımak için kullanılır."
          }
        ]
      }
      ],
      "interviewQuestions": []
    },
    {
      "categoryId": 4,
      "categoryTitle": "Android İleri Seviye & Profesyonel",
      "categoryDescription": "Modern Android uygulamalarında performans, ölçeklenebilirlik ve profesyonel mimari kurmak için ileri seviye konular",
      "order": 4,
      "sections": [
        {
          "sectionId": 4100,
          "sectionTitle": "Coroutines & Asenkron Programlama",
          "sectionDescription": "Android uygulamalarda asenkron işlemleri güvenli, okunabilir ve performanslı şekilde yönetmek için Kotlin Coroutines kullanımı",
          "order": 1,
          "topics": [
            {
              "topicId": 4101,
              "title": "Asenkron Programlama Nedir",
              "summary": "Asenkron programlama, uzun süren işlemlerin (network, veritabanı vb.) ana thread'i bloklamadan arka planda çalıştırılmasını sağlar. Android'de UI performansı için kritik öneme sahiptir.",
              "content": "## Asenkron Programlama\n\nAndroid'de ana thread UI işlemlerini yürütür.\n\nUzun süren işlemler ANR hatasına yol açabilir.\n\nAsenkron yapı performans ve kullanıcı deneyimi sağlar.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "UI thread bloklanmamalıdır",
                "Network ve DB işlemleri arka planda çalışmalıdır",
                "Yanlış kullanım ANR hatasına sebep olur",
                "Asenkron yapı UX'i iyileştirir"
              ],
              "questions": []
            },
            {
              "topicId": 4102,
              "title": "Coroutine Nedir",
              "summary": "Coroutine, Kotlin tarafından sunulan hafif ve güçlü bir asenkron programlama çözümüdür. Callback ve Thread karmaşasını ortadan kaldırır.",
              "content": "## Coroutine\n\nCoroutine'ler lightweight yapılardır.\n\nThread yönetimini geliştiriciden alır.\n\nOkunabilir ve güvenli kod yazmayı sağlar.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Basit Coroutine",
                  "code": "GlobalScope.launch {\n    delay(1000)\n    println(\"Coroutine çalıştı\")\n}",
                  "explanation": "Basit bir coroutine başlatma örneği."
                }
              ],
              "keyPoints": [
                "Thread'e göre daha hafiftir",
                "Callback hell'i ortadan kaldırır",
                "Suspend fonksiyonlar kullanılır",
                "Modern Android'in temelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4103,
              "title": "Suspend Fonksiyonlar",
              "summary": "Suspend fonksiyonlar, coroutine içerisinde çalışabilen ve execution'ı askıya alabilen özel fonksiyonlardır.",
              "content": "## Suspend Fonksiyonlar\n\nSuspend fonksiyonlar coroutine context içinde çağrılır.\n\nThread bloklamaz.\n\nAsenkron işlemler için kullanılır.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Suspend Fonksiyon",
                  "code": "suspend fun fetchData() {\n    delay(1000)\n}",
                  "explanation": "Suspend fonksiyon örneği."
                }
              ],
              "keyPoints": [
                "Sadece coroutine içinde çağrılır",
                "Thread'i bloklamaz",
                "delay() gibi suspend fonksiyonlar içerir",
                "Asenkron yapının temelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4104,
              "title": "Coroutine Scope & Dispatcher",
              "summary": "Coroutine Scope, coroutine'in yaşam döngüsünü; Dispatcher ise hangi thread üzerinde çalışacağını belirler.",
              "content": "## Scope & Dispatcher\n\nScope lifecycle ile ilişkilidir.\n\nDispatcher thread yönetimini sağlar.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Dispatcher Kullanımı",
                  "code": "viewModelScope.launch(Dispatchers.IO) {\n    repository.getData()\n}",
                  "explanation": "IO dispatcher ile coroutine çalıştırma."
                }
              ],
              "keyPoints": [
                "viewModelScope lifecycle-aware'dır",
                "Dispatchers.IO: network & DB",
                "Dispatchers.Main: UI",
                "Yanlış dispatcher crash'e yol açabilir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4200,
          "sectionTitle": "Flow & StateFlow",
          "sectionDescription": "Kotlin Flow ile reaktif veri akışı yönetimi ve StateFlow kullanarak UI state yönetimi",
          "order": 2,
          "topics": [
            {
              "topicId": 4201,
              "title": "Flow Nedir",
              "summary": "Flow, Kotlin Coroutines tabanlı soğuk (cold) veri akışı sağlayan reaktif bir yapıdır. Zaman içerisinde birden fazla veri yayını yapabilir.",
              "content": "## Flow Nedir\n\nFlow, async data stream sağlar.\n\nCold stream'dir (collect edilmeden çalışmaz).\n\nCoroutine ile uyumludur.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Flow",
                  "code": "fun numbersFlow(): Flow<Int> = flow {\n    emit(1)\n    emit(2)\n    emit(3)\n}",
                  "explanation": "Basit bir Flow örneği."
                }
              ],
              "keyPoints": [
                "Cold stream'dir",
                "Coroutine tabanlıdır",
                "Birden fazla değer yayabilir",
                "Asenkron veri akışı sağlar"
              ],
              "questions": []
            },
            {
              "topicId": 4202,
              "title": "Flow Collect",
              "summary": "collect, Flow'dan gelen verileri dinlemek ve işlemek için kullanılan suspend fonksiyondur.",
              "content": "## Collect\n\nFlow collect edilmeden çalışmaz.\n\nSuspend fonksiyondur.\n\nCoroutine scope içinde çağrılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Flow Collect",
                  "code": "lifecycleScope.launch {\n    numbersFlow().collect {\n        println(it)\n    }\n}",
                  "explanation": "Flow collect örneği."
                }
              ],
              "keyPoints": [
                "Suspend fonksiyondur",
                "Coroutine scope gerektirir",
                "Flow başlatır",
                "UI lifecycle ile birlikte çalışır"
              ],
              "questions": []
            },
            {
              "topicId": 4203,
              "title": "StateFlow Nedir",
              "summary": "StateFlow, her zaman güncel bir state tutan ve yeni observer'lara son değeri anında ileten sıcak (hot) bir Flow türüdür.",
              "content": "## StateFlow\n\nHot stream'dir.\n\nHer zaman bir initial değeri vardır.\n\nUI state yönetimi için idealdir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "StateFlow Tanımı",
                  "code": "private val _uiState = MutableStateFlow(0)\nval uiState: StateFlow<Int> = _uiState",
                  "explanation": "StateFlow tanımlama."
                }
              ],
              "keyPoints": [
                "Hot stream'dir",
                "Initial value zorunludur",
                "Son değeri saklar",
                "UI state için kullanılır"
              ],
              "questions": []
            },
            {
              "topicId": 4204,
              "title": "Flow vs LiveData",
              "summary": "Flow ve LiveData benzer amaçlara hizmet etse de Flow daha esnek ve güçlüdür. Modern Android geliştirmede Flow tercih edilir.",
              "content": "## Flow vs LiveData\n\nFlow coroutine tabanlıdır.\n\nLiveData lifecycle-aware'dır.\n\nStateFlow lifecycle bağımsızdır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Flow daha esnektir",
                "LiveData XML uyumludur",
                "StateFlow lifecycle'dan bağımsızdır",
                "Modern projelerde Flow önerilir"
              ],
              "questions": []
            },
            {
              "topicId": 4205,
              "title": "ViewModel + StateFlow Kullanımı",
              "summary": "StateFlow genellikle ViewModel içinde tanımlanır ve UI tarafından observe edilir.",
              "content": "## ViewModel + StateFlow\n\nUI state ViewModel'de tutulur.\n\nLifecycle ile collect edilir.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "StateFlow Observe",
                  "code": "lifecycleScope.launch {\n    viewModel.uiState.collect {\n        textView.text = it.toString()\n    }\n}",
                  "explanation": "UI tarafında StateFlow collect edilmesi."
                }
              ],
              "keyPoints": [
                "StateFlow ViewModel'de tutulur",
                "UI sadece observe eder",
                "Tek yönlü data flow sağlar",
                "MVVM ile uyumludur"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4300,
          "sectionTitle": "Dependency Injection (Hilt)",
          "sectionDescription": "Bağımlılıkları merkezi ve yönetilebilir şekilde sağlamak için kullanılan Hilt tabanlı Dependency Injection yapısı",
          "order": 3,
          "topics": [
            {
              "topicId": 4301,
              "title": "Dependency Injection Nedir",
              "summary": "Dependency Injection (DI), bir sınıfın ihtiyaç duyduğu bağımlılıkları kendisinin oluşturması yerine dışarıdan almasını sağlayan tasarım desenidir.",
              "content": "## Dependency Injection Nedir\n\nDI, sıkı bağımlılıkları azaltır.\n\nKodun test edilebilirliğini artırır.\n\nBakımı ve ölçeklenebilirliği kolaylaştırır.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Sıkı bağımlılığı azaltır",
                "Test yazımını kolaylaştırır",
                "Kod tekrarını önler",
                "Clean Architecture için gereklidir"
              ],
              "questions": []
            },
            {
              "topicId": 4302,
              "title": "Hilt Nedir",
              "summary": "Hilt, Android için geliştirilmiş, Dagger üzerine kurulu resmi Dependency Injection kütüphanesidir.",
              "content": "## Hilt Nedir\n\nGoogle tarafından önerilir.\n\nAndroid bileşenleriyle entegredir.\n\nBoilerplate kodu azaltır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Hilt Kurulumu",
                  "code": "@HiltAndroidApp\nclass MyApplication : Application()",
                  "explanation": "Application seviyesinde Hilt başlatma."
                }
              ],
              "keyPoints": [
                "Dagger tabanlıdır",
                "Android'e özeldir",
                "Otomatik lifecycle yönetimi sağlar",
                "Resmi DI çözümüdür"
              ],
              "questions": []
            },
            {
              "topicId": 4303,
              "title": "Hilt Modülleri",
              "summary": "Hilt modülleri, bağımlılıkların nasıl oluşturulacağını tanımlayan sınıflardır.",
              "content": "## Hilt Modülleri\n\n@Module anotasyonu ile tanımlanır.\n\n@Provides veya @Binds kullanılır.\n\nSingleton gibi scope'lar desteklenir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Hilt Module Örneği",
                  "code": "@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n    @Provides\n    fun provideApi(): ApiService {\n        return ApiService.create()\n    }\n}",
                  "explanation": "Basit bir Hilt modül tanımı."
                }
              ],
              "keyPoints": [
                "Bağımlılık tanımı yapılır",
                "Singleton scope desteklenir",
                "Merkezi yapı sağlar",
                "Test için mock edilebilir"
              ],
              "questions": []
            },
            {
              "topicId": 4304,
              "title": "Hilt ile ViewModel Kullanımı",
              "summary": "Hilt, ViewModel bağımlılıklarını otomatik olarak sağlayarak constructor injection kullanımını mümkün kılar.",
              "content": "## ViewModel + Hilt\n\nConstructor injection desteklenir.\n\n@HiltViewModel anotasyonu kullanılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Hilt ViewModel",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel()",
                  "explanation": "Hilt ile ViewModel injection."
                }
              ],
              "keyPoints": [
                "Constructor injection kullanılır",
                "ViewModel daha test edilebilir olur",
                "Boilerplate azalır",
                "MVVM ile tam uyumludur"
              ],
              "questions": []
            },
            {
              "topicId": 4305,
              "title": "Hilt Scope'ları",
              "summary": "Hilt scope'ları, bağımlılıkların yaşam döngüsünü belirlemek için kullanılır.",
              "content": "## Hilt Scope\n\n@Singleton\n\n@ActivityScoped\n\n@ViewModelScoped gibi scope'lar vardır.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Lifecycle bazlı yönetim sağlar",
                "Bellek kullanımını optimize eder",
                "Yanlış instance oluşumunu önler",
                "Performansı artırır"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4400,
          "sectionTitle": "Clean Architecture",
          "sectionDescription": "Uygulamanın katmanlara ayrılarak daha sürdürülebilir, test edilebilir ve ölçeklenebilir hale getirilmesini sağlayan mimari yaklaşım",
          "order": 4,
          "topics": [
            {
              "topicId": 4401,
              "title": "Clean Architecture Nedir",
              "summary": "Clean Architecture, uygulamayı katmanlara ayırarak bağımlılıkların tek yönlü olmasını sağlayan bir mimari yaklaşımdır.",
              "content": "## Clean Architecture Nedir\n\nBu mimari, iş kurallarını framework ve UI bağımlılıklarından ayırır.\n\nMerkezde domain katmanı bulunur.\n\nDış katmanlar iç katmanlara bağımlıdır, tersi mümkün değildir.",
              "difficulty": "hard",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Katmanlı yapı sunar",
                "Bağımlılıklar tek yönlüdür",
                "İş mantığı UI'dan bağımsızdır",
                "Test yazımı kolaylaşır"
              ],
              "questions": []
            },
            {
              "topicId": 4402,
              "title": "Katmanlar (Presentation, Domain, Data)",
              "summary": "Clean Architecture, uygulamayı üç ana katmana ayırır: Presentation, Domain ve Data.",
              "content": "## Clean Architecture Katmanları\n\n- Presentation: UI ve ViewModel\n- Domain: UseCase ve Entity\n- Data: Repository ve veri kaynakları\n\nHer katmanın sorumluluğu nettir.",
              "difficulty": "hard",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "Presentation UI logic içerir",
                "Domain saf Kotlin'dir",
                "Data veri kaynaklarını yönetir",
                "Katmanlar arası bağımlılık sınırlandırılmıştır"
              ],
              "questions": []
            },
            {
              "topicId": 4403,
              "title": "Domain Katmanı",
              "summary": "Domain katmanı, uygulamanın iş kurallarını ve UseCase yapılarını içerir.",
              "content": "## Domain Katmanı\n\nFramework bağımlılığı yoktur.\n\nSaf Kotlin kodu içerir.\n\nUygulamanın kalbidir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "UseCase Örneği",
                  "code": "class GetUsersUseCase(private val repository: UserRepository) {\n    suspend operator fun invoke() = repository.getUsers()\n}",
                  "explanation": "Domain katmanında bir UseCase örneği."
                }
              ],
              "keyPoints": [
                "Framework bağımsızdır",
                "Business logic burada yer alır",
                "Test edilmesi çok kolaydır",
                "Uzun vadede stabil yapı sağlar"
              ],
              "questions": []
            },
            {
              "topicId": 4404,
              "title": "Data Katmanı",
              "summary": "Data katmanı, veri kaynaklarını (API, Room, Cache) yöneten katmandır.",
              "content": "## Data Katmanı\n\nRepository implementasyonları burada bulunur.\n\nRemote ve local data source'lar ayrılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Repository Implementasyonu",
                  "code": "class UserRepositoryImpl(\n    private val api: ApiService\n) : UserRepository {\n    override suspend fun getUsers() = api.getUsers()\n}",
                  "explanation": "Data katmanında repository implementasyonu."
                }
              ],
              "keyPoints": [
                "Veri kaynaklarını soyutlar",
                "API ve Room ayrımı yapılır",
                "Domain ile interface üzerinden konuşur",
                "Mocklama kolaydır"
              ],
              "questions": []
            },
            {
              "topicId": 4405,
              "title": "Presentation Katmanı",
              "summary": "Presentation katmanı, UI ve kullanıcı etkileşimlerini yöneten katmandır.",
              "content": "## Presentation Katmanı\n\nActivity, Fragment ve ViewModel içerir.\n\nSadece UI logic bulunur.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [
                {
                  "title": "ViewModel + UseCase",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val getUsersUseCase: GetUsersUseCase\n) : ViewModel()",
                  "explanation": "Presentation katmanında ViewModel örneği."
                }
              ],
              "keyPoints": [
                "UI ile sınırlıdır",
                "Business logic içermez",
                "UseCase kullanır",
                "MVVM ile birlikte çalışır"
              ],
              "questions": []
            },
            {
              "topicId": 4406,
              "title": "Clean Architecture + MVVM",
              "summary": "Clean Architecture, MVVM ile birlikte kullanıldığında güçlü ve sürdürülebilir bir yapı ortaya çıkar.",
              "content": "## Clean Architecture + MVVM\n\nMVVM, Presentation katmanında kullanılır.\n\nUseCase'ler ViewModel tarafından çağrılır.",
              "difficulty": "hard",
              "order": 6,
              "codeExamples": [],
              "keyPoints": [
                "Modern Android için ideal yapı",
                "Test edilebilirlik maksimumdur",
                "Büyük projelerde tercih edilir",
                "Senior seviye mimaridir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4500,
          "sectionTitle": "Coroutines",
          "sectionDescription": "Asenkron işlemleri daha okunabilir, güvenli ve performanslı şekilde yönetmek için kullanılan Kotlin Coroutine yapısı",
          "order": 5,
          "topics": [
            {
              "topicId": 4501,
              "title": "Coroutines Nedir",
              "summary": "Coroutines, uzun süren işlemleri (network, database vb.) ana thread'i bloklamadan çalıştırmayı sağlayan Kotlin'in asenkron programlama çözümüdür.",
              "content": "## Coroutines Nedir\n\nCoroutines, callback ve RxJava gibi yapılara modern bir alternatiftir.\n\nKodun senkron gibi okunmasını sağlar ancak asenkron çalışır.\n\nAndroid'de performans ve kullanıcı deneyimi için kritik öneme sahiptir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Asenkron işlemleri basitleştirir",
                "Callback hell sorununu çözer",
                "Okunabilir kod yapısı sağlar",
                "Android tarafından resmi olarak desteklenir"
              ],
              "questions": []
            },
            {
              "topicId": 4502,
              "title": "CoroutineScope ve Lifecycle",
              "summary": "CoroutineScope, coroutine'lerin hangi yaşam döngüsüne bağlı çalışacağını belirler.",
              "content": "## CoroutineScope\n\nAndroid'de en sık kullanılan scope'lar:\n\n- viewModelScope\n- lifecycleScope\n- GlobalScope (önerilmez)\n\nLifecycle-aware scope'lar memory leak riskini azaltır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "viewModelScope Kullanımı",
                  "code": "viewModelScope.launch {\n    val users = repository.getUsers()\n}",
                  "explanation": "ViewModel yok edildiğinde coroutine otomatik iptal edilir."
                }
              ],
              "keyPoints": [
                "Lifecycle'a duyarlı çalışır",
                "Memory leak riskini azaltır",
                "GlobalScope önerilmez",
                "UI güvenliğini artırır"
              ],
              "questions": []
            },
            {
              "topicId": 4503,
              "title": "Dispatchers",
              "summary": "Dispatchers, coroutine'in hangi thread üzerinde çalışacağını belirler.",
              "content": "## Dispatchers\n\n- Dispatchers.Main → UI işlemleri\n- Dispatchers.IO → Network / Database\n- Dispatchers.Default → CPU yoğun işlemler\n\nYanlış dispatcher kullanımı performans sorunlarına yol açar.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Dispatcher Kullanımı",
                  "code": "withContext(Dispatchers.IO) {\n    dao.getAllUsers()\n}",
                  "explanation": "IO işlemleri ana thread dışında çalıştırılır."
                }
              ],
              "keyPoints": [
                "Thread yönetimini kolaylaştırır",
                "UI thread bloklanmaz",
                "Doğru dispatcher performansı artırır",
                "Yanlış kullanım ANR'a sebep olabilir"
              ],
              "questions": []
            },
            {
              "topicId": 4504,
              "title": "launch ve async",
              "summary": "launch ve async, coroutine başlatmak için kullanılan iki temel builder'dır.",
              "content": "## launch vs async\n\n- launch → Sonuç dönmez\n- async → Deferred<T> döner\n\nasync genellikle paralel işlemler için kullanılır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "async / await",
                  "code": "val result = async { api.getData() }\nresult.await()",
                  "explanation": "async sonucu await ile alınır."
                }
              ],
              "keyPoints": [
                "launch fire-and-forget",
                "async sonuç döner",
                "await ile senkron bekleme yapılır",
                "Yanlış kullanım memory leak doğurabilir"
              ],
              "questions": []
            },
            {
              "topicId": 4505,
              "title": "Exception Handling",
              "summary": "Coroutine'lerde hata yönetimi structured concurrency prensibine göre yapılır.",
              "content": "## Coroutine Exception Handling\n\ntry-catch ve CoroutineExceptionHandler kullanılır.\n\nSupervisorJob ile child coroutine hataları izole edilebilir.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "try-catch Kullanımı",
                  "code": "viewModelScope.launch {\n    try {\n        api.getData()\n    } catch (e: Exception) {\n        // hata yönetimi\n    }\n}",
                  "explanation": "Coroutine içinde hata yakalama."
                }
              ],
              "keyPoints": [
                "Structured concurrency önemlidir",
                "Hatalar scope'a yayılabilir",
                "SupervisorJob izolasyon sağlar",
                "Doğru hata yönetimi crash'i önler"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4600,
          "sectionTitle": "Testing",
          "sectionDescription": "Android uygulamalarda hataları erken yakalamak, sürdürülebilir ve güvenilir kod yazmak için kullanılan test yaklaşımları",
          "order": 6,
          "topics": [
            {
              "topicId": 4601,
              "title": "Testing Nedir ve Neden Önemlidir",
              "summary": "Testing, yazılan kodun beklenen şekilde çalışıp çalışmadığını doğrulamak için yapılan kontrollü test süreçleridir. Hataları erken yakalamayı ve kod kalitesini artırmayı sağlar.",
              "content": "## Testing Nedir\n\nTest yazmak, uygulamanın davranışlarını otomatik olarak kontrol etmeyi sağlar.\n\nBüyük projelerde regresyon hatalarını önler.\n\nProfesyonel yazılım geliştirme süreçlerinin vazgeçilmezidir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Hataları erken yakalar",
                "Kod kalitesini artırır",
                "Refactor sürecini güvenli hale getirir",
                "Profesyonel projelerde zorunludur"
              ],
              "questions": []
            },
            {
              "topicId": 4602,
              "title": "Unit Test",
              "summary": "Unit Test, uygulamadaki en küçük test edilebilir birimlerin (fonksiyon, ViewModel vb.) izole şekilde test edilmesini sağlar.",
              "content": "## Unit Test\n\nAndroid'de genellikle ViewModel ve business logic test edilir.\n\nJUnit ve Mockito sık kullanılan araçlardır.\n\nUI'dan bağımsız çalışır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "ViewModel Unit Test",
                  "code": "@Test\nfun counter_increases_correctly() {\n    val vm = MainViewModel()\n    vm.increase()\n    assertEquals(1, vm.counter.value)\n}",
                  "explanation": "ViewModel fonksiyonunun doğru çalıştığını test eder."
                }
              ],
              "keyPoints": [
                "UI bağımsız test edilir",
                "Hızlı çalışır",
                "ViewModel için idealdir",
                "Regression hatalarını önler"
              ],
              "questions": []
            },
            {
              "topicId": 4603,
              "title": "Mocking (Mockito)",
              "summary": "Mocking, gerçek bağımlılıkların yerine sahte (mock) nesneler kullanarak test yazmayı sağlar.",
              "content": "## Mocking\n\nRepository, API veya database bağımlılıkları mock'lanır.\n\nTest izolasyonu sağlar.\n\nMockito Android'de sık kullanılır.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Mockito Kullanımı",
                  "code": "val repo = mock(UserRepository::class.java)\n`when`(repo.getUsers()).thenReturn(listOf())",
                  "explanation": "Repository davranışı taklit edilir."
                }
              ],
              "keyPoints": [
                "Bağımlılıkları izole eder",
                "Test senaryolarını kontrol etmeyi sağlar",
                "Gerçek API çağrısı yapılmaz",
                "Test stabilitesini artırır"
              ],
              "questions": []
            },
            {
              "topicId": 4604,
              "title": "UI Test (Espresso)",
              "summary": "UI Test, uygulamanın kullanıcı arayüzünün doğru çalışıp çalışmadığını otomatik olarak test etmeyi sağlar.",
              "content": "## UI Test\n\nEspresso Android'in resmi UI test aracıdır.\n\nKullanıcı etkileşimlerini simüle eder.\n\nGerçek cihaz veya emülatör üzerinde çalışır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Espresso Örneği",
                  "code": "onView(withId(R.id.button)).perform(click())",
                  "explanation": "Butona tıklama işlemi test edilir."
                }
              ],
              "keyPoints": [
                "Gerçek kullanıcı davranışını test eder",
                "UI hatalarını yakalar",
                "Yavaş çalışır ama etkilidir",
                "Release öncesi kritik öneme sahiptir"
              ],
              "questions": []
            },
            {
              "topicId": 4605,
              "title": "Test Pyramid",
              "summary": "Test Pyramid, test stratejisinde hangi test türüne ne kadar ağırlık verilmesi gerektiğini tanımlar.",
              "content": "## Test Pyramid\n\n- Unit Test → Çok\n- Integration Test → Orta\n- UI Test → Az\n\nBu yapı test maliyetini optimize eder.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Unit test ağırlıklı olmalı",
                "UI test sayısı sınırlı tutulmalı",
                "Bakım maliyetini düşürür",
                "Doğru test stratejisi sağlar"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4700,
          "sectionTitle": "Performance & Memory Management",
          "sectionDescription": "Android uygulamalarda performans sorunlarını tespit etmek, bellek yönetimini doğru yapmak ve ANR/crash risklerini azaltmak",
          "order": 7,
          "topics": [
            {
              "topicId": 4701,
              "title": "Performance Nedir",
              "summary": "Performance, bir Android uygulamasının hızlı, akıcı ve kaynakları verimli kullanarak çalışmasıdır. Kötü performans kullanıcı kaybına yol açar.",
              "content": "## Performance\n\nAndroid'de performans; CPU, memory, disk ve network kullanımına bağlıdır.\n\nAkıcı UI için ana thread'in bloklanmaması gerekir.\n\nGoogle Play puanlamasını doğrudan etkiler.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Akıcı UI kullanıcı deneyimini artırır",
                "Ana thread bloklanmamalıdır",
                "Performans doğrudan Play Store puanını etkiler",
                "Profiling ile ölçülmelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4702,
              "title": "ANR (Application Not Responding)",
              "summary": "ANR, ana thread uzun süre bloklandığında Android tarafından uygulamanın durdurulmasıdır.",
              "content": "## ANR\n\nGenellikle network, database veya heavy işlem ana thread'de yapıldığında oluşur.\n\n5 saniyeden uzun UI bloklanması ANR sebebidir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Yanlış Kullanım",
                  "code": "Thread.sleep(6000)",
                  "explanation": "Ana thread'de bekleme ANR oluşturur."
                }
              ],
              "keyPoints": [
                "Ana thread bloklanmamalı",
                "Uzun işlemler background thread'e taşınmalı",
                "Coroutines / WorkManager kullanılmalı",
                "ANR Play Console'da raporlanır"
              ],
              "questions": []
            },
            {
              "topicId": 4703,
              "title": "Memory Leak",
              "summary": "Memory leak, artık kullanılmayan nesnelerin bellekten temizlenmemesi durumudur ve uygulamanın yavaşlamasına veya çökmesine neden olur.",
              "content": "## Memory Leak\n\nEn sık nedenler:\n\n- Static Activity referansı\n- Yanlış Context kullanımı\n- Lifecycle'a bağlı olmayan observer'lar",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Yanlış Context Kullanımı",
                  "code": "object Manager {\n    lateinit var context: Context\n}",
                  "explanation": "Activity context'i tutulursa leak oluşur."
                }
              ],
              "keyPoints": [
                "Context dikkatli kullanılmalı",
                "Lifecycle-aware bileşenler tercih edilmeli",
                "LeakCanary ile tespit edilebilir",
                "Static referanslardan kaçınılmalı"
              ],
              "questions": []
            },
            {
              "topicId": 4704,
              "title": "Garbage Collection",
              "summary": "Garbage Collector, kullanılmayan nesneleri bellekten otomatik olarak temizleyen mekanizmadır.",
              "content": "## Garbage Collection\n\nSık GC çalışması performans düşüşüne neden olur.\n\nAşırı nesne oluşturmak GC baskısı yaratır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Aşırı nesne üretiminden kaçınılmalı",
                "Reusable objeler tercih edilmeli",
                "GC UI thread'i etkileyebilir",
                "Profiling ile izlenmelidir"
              ],
              "questions": []
            },
            {
              "topicId": 4705,
              "title": "Android Profiler",
              "summary": "Android Profiler, CPU, memory ve network kullanımını analiz etmek için kullanılan resmi Android Studio aracıdır.",
              "content": "## Android Profiler\n\nGerçek zamanlı performans ölçümü sağlar.\n\nMemory leak ve ANR analizinde kullanılır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "CPU, Memory, Network analiz edilir",
                "Gerçek cihazda ölçüm önerilir",
                "Bottleneck tespiti yapılır",
                "Performans iyileştirme için şarttır"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        },
        {
          "sectionId": 4800,
          "sectionTitle": "Modularization (Multi-Module Android)",
          "sectionDescription": "Büyük Android projelerinde kodun yönetilebilirliğini, test edilebilirliğini ve build performansını artırmak için kullanılan çok modüllü mimari yaklaşımı",
          "order": 8,
          "topics": [
            {
              "topicId": 4801,
              "title": "Modularization Nedir",
              "summary": "Modularization, bir Android uygulamasını bağımsız ve yeniden kullanılabilir modüllere bölme yaklaşımıdır. Büyük projelerde karmaşıklığı azaltır.",
              "content": "## Modularization Nedir\n\nUygulama tek bir module yerine birden fazla module ayrılır.\n\nHer modül belirli bir sorumluluğa sahiptir.\n\nTakım çalışmasını ve ölçeklenebilirliği artırır.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Kod karmaşıklığını azaltır",
                "Takım çalışmasını kolaylaştırır",
                "Bağımlılık yönetimini iyileştirir",
                "Büyük projeler için idealdir"
              ],
              "questions": []
            },
            {
              "topicId": 4802,
              "title": "Module Türleri",
              "summary": "Android projelerinde farklı amaçlara hizmet eden çeşitli modül türleri bulunur.",
              "content": "## Module Türleri\n\n- App Module\n- Library Module\n- Feature Module (Dynamic Feature)\n\nHer modül farklı sorumluluklar üstlenir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "App module uygulamanın giriş noktasıdır",
                "Library module yeniden kullanılabilir kod içerir",
                "Feature module opsiyonel özellikler sunar",
                "Dynamic Feature ile indirme boyutu küçülür"
              ],
              "questions": []
            },
            {
              "topicId": 4803,
              "title": "Gradle Module Yapısı",
              "summary": "Multi-module projelerde Gradle, modüller arası bağımlılıkları ve build sürecini yönetir.",
              "content": "## Gradle Module Yapısı\n\nsettings.gradle dosyası modülleri tanımlar.\n\nModüller arası bağımlılıklar implementation(project()) ile eklenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Module Bağımlılığı",
                  "code": "implementation(project(\":core\"))",
                  "explanation": "core modülünü app modülüne dahil eder."
                }
              ],
              "keyPoints": [
                "Modüller arası bağımlılık açıkça tanımlanır",
                "Yanlış bağımlılık circular dependency oluşturabilir",
                "Build süresi optimize edilir",
                "Gradle yapılandırması kritik öneme sahiptir"
              ],
              "questions": []
            },
            {
              "topicId": 4804,
              "title": "Clean Architecture ile Modularization",
              "summary": "Clean Architecture, modüller arası bağımlılıkların tek yönlü olmasını sağlar ve kodun test edilebilirliğini artırır.",
              "content": "## Clean Architecture & Modules\n\nGenellikle şu yapı kullanılır:\n\n- data\n- domain\n- ui\n\nDomain katmanı hiçbir Android bağımlılığı içermez.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Bağımlılıklar içe doğru olmalıdır",
                "Domain katmanı saf Kotlin içerir",
                "Test yazımı kolaylaşır",
                "Uzun vadeli sürdürülebilirlik sağlar"
              ],
              "questions": []
            },
            {
              "topicId": 4805,
              "title": "Modularization Avantajları ve Dezavantajları",
              "summary": "Multi-module mimari birçok avantaj sunsa da yanlış kullanımda karmaşıklık yaratabilir.",
              "content": "## Avantajlar & Dezavantajlar\n\nAvantajlar:\n- Daha hızlı build\n- Daha temiz kod\n\nDezavantajlar:\n- İlk kurulum karmaşıktır\n- Küçük projeler için gereksiz olabilir",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Büyük projelerde ciddi fayda sağlar",
                "Küçük projelerde overengineering olabilir",
                "Doğru planlama şarttır",
                "Senior seviye mimari bilgisidir"
              ],
              "questions": []
            }
          ],
          "sectionMixedQuestions": []
        }
      ]
    }
  ]
}

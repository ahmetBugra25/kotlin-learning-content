{
  "version": "1.0.0",
  "lastUpdate": "2025-01-06T10:00:00Z",
  "categories": [
    {
      "categoryId": 1,
      "categoryTitle": "Kotlin Programlama Dili",
      "categoryDescription": "Kotlin dilinin temel ve ileri seviye özellikleri",
      "order": 1,
      "sections": [
        {
        "sectionId": 101,
        "sectionTitle": "Kotlin'e Giriş",
        "sectionDescription": "Bu bölümde Kotlin programlama dilinin ne olduğu ve hangi alanlarda kullanıldığı hakkında temel bilgiler verilmektedir.",
        "order": 1,
        "topics": [
            {
            "topicId": 1001,
            "title": "Kotlin Nedir",
            "summary": "Kotlin, JetBrains tarafından geliştirilen, modern, güvenli ve okunabilirliği yüksek bir programlama dilidir. JVM üzerinde çalışır ve Java ile %100 uyumludur. Null safety, kısa söz dizimi ve fonksiyonel programlama desteği sayesinde hataları azaltır ve geliştirme sürecini hızlandırır. Günümüzde Android uygulama geliştirmenin resmi dili olarak kabul edilmektedir.",
            "content": "## Kotlin Nedir?\n\nKotlin, JetBrains tarafından geliştirilmiş modern bir programlama dilidir.\n\n- Java ile %100 uyumludur\n- Null safety ile hataları azaltır\n- Daha az kod ile daha fazla iş yapılmasını sağlar\n\nAndroid geliştirme başta olmak üzere backend, web ve multiplatform projelerde kullanılır.",
            "difficulty": "easy",
            "order": 1,
            "codeExamples": [
                {
                "title": "Basit Kotlin Kodu",
                "code": "fun main() {\n    println(\"Hello Kotlin\")\n}",
                "explanation": "Kotlin'de ana fonksiyon fun anahtar kelimesi ile tanımlanır ve println ile konsola çıktı verilir."
                }
            ],
            "keyPoints": [
                "JetBrains tarafından geliştirilmiştir",
                "Java ile %100 uyumludur",
                "Null safety özelliği vardır",
                "Android'in resmi dilidir"
            ],
            "questions": []
            },
            {
            "topicId": 1002,
            "title": "Kotlin Nerelerde Kullanılır",
            "summary": "Kotlin, başta Android mobil uygulama geliştirme olmak üzere birçok alanda kullanılır. Backend tarafında (Spring Boot, Ktor), masaüstü uygulamalarda, web geliştirmede (Kotlin/JS) ve çoklu platform projelerinde (Kotlin Multiplatform) tercih edilir. Java ile uyumlu olması sayesinde mevcut Java projelerine kolayca entegre edilebilir.",
            "content": "",
            "difficulty": "easy",
            "order": 2,
            "codeExamples": [],
            "keyPoints": [
                "Android uygulama geliştirme",
                "Backend (Spring Boot, Ktor)",
                "Web (Kotlin/JS)",
                "Multiplatform projeler",
                "Mevcut Java projeleri"
            ],
            "questions": []
            }
          ],
        "sectionMixedQuestions": []
        },
        {
          "sectionId": 102,
          "sectionTitle": "Değişkenler ve Veri Tipleri",
          "sectionDescription": "",
          "order": 2,
          "topics": [
            {
            "topicId": 1101,
            "title": "var ve val",
            "summary": "Kotlin'de değişken tanımlamak için var ve val anahtar kelimeleri kullanılır. var ile tanımlanan değişkenlerin değeri sonradan değiştirilebilirken, val ile tanımlanan değişkenler yalnızca bir kez atanabilir. Güvenli ve okunabilir kod yazımı için mümkün olduğunca val kullanılması önerilir.",
            "content": "## var ve val\n\nKotlin'de değişken tanımlamak için iki temel anahtar kelime bulunur:\n\n- **val (value)**: Değeri sonradan değiştirilemeyen, immutable değişkenlerdir.\n- **var (variable)**: Değeri sonradan değiştirilebilen, mutable değişkenlerdir.\n\nKotlin'de best practice olarak, değişmeyecek değerler için **val**, gerçekten değişmesi gereken durumlarda **var** kullanılması önerilir. Bu yaklaşım hem kod güvenliğini artırır hem de hataları azaltır.\n\nÖnemli bir detay olarak; val ile tanımlanan bir referans değiştirilemez ancak eğer referans bir mutable nesne tutuyorsa, nesnenin içeriği değiştirilebilir.",
            "difficulty": "easy",
            "order": 1,
            "codeExamples": [
                {
                "title": "Temel var ve val Kullanımı",
                "code": "val name = \"Ahmet\"\nvar age = 25\n\nage = 26      // Geçerli\n// name = \"Mehmet\"  // HATA",
                "explanation": "val ile tanımlanan name değişkeni yeniden atanamaz. var ile tanımlanan age değişkeni ise güncellenebilir."
                },
                {
                "title": "val ve Mutable Nesne",
                "code": "val numbers = mutableListOf(1, 2, 3)\nnumbers.add(4)\n\nprintln(numbers)",
                "explanation": "numbers referansı val olsa bile, mutable bir liste tuttuğu için listenin içeriği değiştirilebilir."
                }
            ],
            "keyPoints": [
                "val değiştirilemez (immutable)",
                "var değiştirilebilir (mutable)",
                "Varsayılan olarak val tercih edilmelidir",
                "val referansı değişmez, içeriği mutable olabilir",
                "Daha güvenli ve okunabilir kod için val kullanımı önerilir"
            ],
            "questions": [
                {
                "questionId": 110101,
                "question": "Kotlin'de değeri sonradan değiştirilemeyen değişken hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "var",
                    "val",
                    "let",
                    "const"
                ],
                "correctAnswerIndex": 1,
                "explanation": "val anahtar kelimesi ile tanımlanan değişkenler immutable'dır ve bir kez atandıktan sonra değiştirilemez.",
                "tags": ["val", "var", "basics"]
                },
                {
                "questionId": 110102,
                "question": "Aşağıdakilerden hangisi var için doğrudur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "Bir kez atanır ve değiştirilemez",
                    "Sadece sınıf içinde kullanılır",
                    "Değeri sonradan değiştirilebilir",
                    "Sadece sabit değerler için kullanılır"
                ],
                "correctAnswerIndex": 2,
                "explanation": "var ile tanımlanan değişkenlerin değeri program çalışırken değiştirilebilir.",
                "tags": ["var", "basics"]
                },
                {
                "questionId": 110103,
                "question": "Aşağıdaki kodda hangi satır hata verir?",
                "questionType": "multiple_choice",
                "code": "val x = 10\nvar y = 20\nx = 15\ny = 25",
                "difficulty": "medium",
                "options": [
                    "Satır 1",
                    "Satır 2",
                    "Satır 3",
                    "Satır 4"
                ],
                "correctAnswerIndex": 2,
                "explanation": "x değişkeni val ile tanımlandığı için yeniden değer atanamaz. Bu nedenle Satır 3 compile-time hatası verir.",
                "tags": ["val", "compile-error"]
                },
                {
                "questionId": 110104,
                "question": "Aşağıdakilerden hangisi Kotlin best practice'lerine daha uygundur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Her zaman var kullanmak",
                    "Değişmeyecek değerler için val kullanmak",
                    "Sadece global değişkenlerde val kullanmak",
                    "val ve var arasında fark yoktur"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Değişmeyecek değerler için val kullanmak kod güvenliğini ve okunabilirliği artırır.",
                "tags": ["best-practice", "val"]
                },
                {
                "questionId": 110105,
                "question": "val ile tanımlanan mutable bir liste için aşağıdakilerden hangisi doğrudur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Listeye eleman eklenemez",
                    "Liste referansı değiştirilebilir",
                    "Listenin içeriği değiştirilebilir",
                    "Compile-time hatası oluşur"
                ],
                "correctAnswerIndex": 2,
                "explanation": "val referansı değiştirilemez ancak mutable bir nesne tutuyorsa, nesnenin içeriği değiştirilebilir.",
                "tags": ["val", "collections", "mutable"]
                }
            ]
            },
            {
            "topicId": 1102,
            "title": "Int ve Long",
            "summary": "Kotlin'de Int ve Long, tam sayı (integer) değerleri temsil eden veri tipleridir. Int 32-bit, Long ise 64-bit bellek alanı kullanır. Daha büyük sayılarla çalışılması gereken durumlarda Long tercih edilir. Kotlin'de sayı taşmalarını önlemek ve performansı korumak için uygun veri tipi seçilmelidir.",
            "content": "## Int ve Long\n\nKotlin'de tam sayılar için en sık kullanılan veri tipleri **Int** ve **Long**'dur.\n\n- **Int**: 32-bit signed tam sayı tipidir. -2,147,483,648 ile 2,147,483,647 arasında değer alabilir.\n- **Long**: 64-bit signed tam sayı tipidir. Çok daha büyük sayılarla çalışmak için kullanılır.\n\nKotlin'de sayısal sabitler varsayılan olarak **Int** kabul edilir. Bir sayının Long olduğunu belirtmek için sonuna **L** veya **l** eklenmelidir.\n\nDoğru veri tipini seçmek hem bellek kullanımı hem de uygulama performansı açısından önemlidir.",
            "difficulty": "easy",
            "order": 2,
            "codeExamples": [
                {
                "title": "Int ve Long Tanımlama",
                "code": "val age: Int = 25\nval distance: Long = 1_000_000L",
                "explanation": "Int 32-bit, Long 64-bit veri tipidir. Long değerlerde L takısı kullanılır."
                },
                {
                "title": "Varsayılan Int Davranışı",
                "code": "val number = 100\nval bigNumber = 10000000000L",
                "explanation": "Kotlin'de sayısal sabitler varsayılan olarak Int kabul edilir. Daha büyük değerler için Long kullanılır."
                }
            ],
            "keyPoints": [
                "Int 32-bit tam sayı tipidir",
                "Long 64-bit tam sayı tipidir",
                "Varsayılan tam sayı tipi Int'tir",
                "Long değerler L takısı ile belirtilir",
                "Büyük sayılar için Long tercih edilmelidir"
            ],
            "questions": [
                {
                "questionId": 110201,
                "question": "Kotlin'de varsayılan tam sayı veri tipi hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "Long",
                    "Short",
                    "Int",
                    "Byte"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Kotlin'de sayısal sabitler varsayılan olarak Int veri tipi kabul edilir.",
                "tags": ["int", "basics"]
                },
                {
                "questionId": 110202,
                "question": "Aşağıdakilerden hangisi Long tipinde bir değerdir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                    "100",
                    "5000",
                    "9999999999L",
                    "42"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Long değerler L takısı ile belirtilir.",
                "tags": ["long", "basics"]
                },
                {
                "questionId": 110203,
                "question": "Int veri tipinin maksimum değeri yaklaşık olarak hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "2 milyar",
                    "4 milyar",
                    "9 kentilyon",
                    "Sınırsız"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Int 32-bit olduğu için maksimum değeri yaklaşık 2.1 milyardır.",
                "tags": ["int", "range"]
                },
                {
                "questionId": 110204,
                "question": "Aşağıdaki kodlardan hangisi compile-time hatası verir?",
                "questionType": "multiple_choice",
                "code": "val number: Int = 10000000000",
                "difficulty": "medium",
                "options": [
                    "Kod hata vermez",
                    "Runtime hatası verir",
                    "Compile-time hatası verir",
                    "Long'a otomatik dönüşür"
                ],
                "correctAnswerIndex": 2,
                "explanation": "10000000000 Int aralığını aştığı için compile-time hatası oluşur.",
                "tags": ["int", "error"]
                },
                {
                "questionId": 110205,
                "question": "Aşağıdakilerden hangisi Int yerine Long kullanılmasını gerektirir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                    "Kullanıcı yaşı",
                    "Ürün adedi",
                    "Dosya boyutu (byte)",
                    "Sınıf öğrenci sayısı"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Dosya boyutları çok büyük olabileceği için Long kullanımı daha uygundur.",
                "tags": ["long", "use-case"]
                }
            ]
            },
            {
              "topicId": 1103,
              "title": "Float ve Double",
              "summary": "Float ve Double, Kotlin'de ondalıklı (virgüllü) sayıları temsil eden veri tipleridir. Float 32-bit, Double ise 64-bit hassasiyete sahiptir. Kotlin'de ondalıklı sayılar varsayılan olarak Double kabul edilir. Daha yüksek hassasiyet gereken durumlarda Double tercih edilir.",
              "content": "## Float ve Double\n\nKotlin'de ondalıklı sayılarla çalışmak için **Float** ve **Double** veri tipleri kullanılır.\n\n- **Float**: 32-bit hassasiyete sahiptir. Daha az bellek kullanır ancak doğruluk düşüktür.\n- **Double**: 64-bit hassasiyete sahiptir. Daha yüksek doğruluk sunar ve Kotlin'de varsayılan ondalıklı sayı tipidir.\n\nFloat değerler tanımlanırken sonuna **F** veya **f** eklenmelidir. Aksi halde Kotlin bu değeri Double olarak kabul eder.\n\nFinansal hesaplamalar, ölçümler ve hassas sonuçlar gerektiren işlemlerde genellikle Double tercih edilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Float ve Double Tanımlama",
                  "code": "val piDouble: Double = 3.14159\nval piFloat: Float = 3.14F",
                  "explanation": "Float değerlerde F takısı zorunludur. Aksi halde değer Double kabul edilir."
                },
                {
                  "title": "Varsayılan Double Davranışı",
                  "code": "val number = 2.5\nval preciseNumber = 2.5F",
                  "explanation": "Ondalıklı sayılar varsayılan olarak Double tipindedir."
                }
              ],
              "keyPoints": [
                "Float 32-bit hassasiyete sahiptir",
                "Double 64-bit hassasiyete sahiptir",
                "Varsayılan ondalıklı sayı tipi Double'dır",
                "Float değerler F takısı ile belirtilir",
                "Hassas hesaplamalar için Double tercih edilir"
              ],
              "questions": [
                {
                  "questionId": 110301,
                  "question": "Kotlin'de varsayılan ondalıklı sayı veri tipi hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Float",
                    "Double",
                    "Int",
                    "Long"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de ondalıklı sayılar varsayılan olarak Double kabul edilir.",
                  "tags": ["double", "basics"]
                },
                {
                  "questionId": 110302,
                  "question": "Aşağıdakilerden hangisi Float tipinde bir değerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "3.14",
                    "2.5",
                    "1.0",
                    "3.14F"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Float değerler F veya f takısı ile belirtilir.",
                  "tags": ["float", "basics"]
                },
                {
                  "questionId": 110303,
                  "question": "Float ve Double arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Float daha hassastır",
                    "Double daha az bellek kullanır",
                    "Double daha yüksek hassasiyet sunar",
                    "Aralarında fark yoktur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Double 64-bit olduğu için Float'a göre daha yüksek hassasiyet sunar.",
                  "tags": ["precision", "comparison"]
                },
                {
                  "questionId": 110304,
                  "question": "Aşağıdaki kodlardan hangisi compile-time hatası verir?",
                  "questionType": "multiple_choice",
                  "code": "val value: Float = 2.5",
                  "difficulty": "medium",
                  "options": [
                    "Kod hata vermez",
                    "Runtime hatası verir",
                    "Compile-time hatası verir",
                    "Otomatik Float'a dönüşür"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "2.5 varsayılan olarak Double olduğu için Float'a atanamaz. F takısı gereklidir.",
                  "tags": ["float", "error"]
                },
                {
                  "questionId": 110305,
                  "question": "Aşağıdaki kullanım senaryolarından hangisinde Double tercih edilmelidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Ekran parlaklığı değeri",
                    "Sıcaklık ölçümü",
                    "Para hesaplamaları",
                    "Sayaç artışı"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Para ve hassas hesaplamalarda Double tercih edilir (daha doğrusu BigDecimal ama Float kullanılmamalıdır).",
                  "tags": ["double", "use-case"]
                }
              ]
            },
            {
              "topicId": 1104,
              "title": "String",
              "summary": "String, Kotlin'de metinsel ifadeleri temsil eden veri tipidir. Karakter dizilerinden oluşur ve immutable (değiştirilemez) yapıdadır. Kotlin'de String'ler güçlü fonksiyonlar, string interpolation ve çok satırlı yazım desteği sunar.",
              "content": "## String\n\nKotlin'de **String**, metin verilerini temsil eder ve **immutable** bir veri tipidir. Yani bir String oluşturulduktan sonra içeriği değiştirilemez.\n\nKotlin String'leri birçok hazır fonksiyon ile birlikte gelir. Ayrıca **string interpolation** sayesinde değişkenler doğrudan metin içinde kullanılabilir.\n\nKotlin'de String oluşturmanın iki temel yolu vardır:\n\n- Çift tırnak (\" \") ile tek satırlı String\n- Üç tırnak (\"\"\" \"\"\") ile çok satırlı String\n\nString işlemleri güvenli, okunabilir ve performanslı bir şekilde yapılabilir.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "String Tanımlama",
                  "code": "val name: String = \"Ahmet\"\nval city = \"Erzurum\"",
                  "explanation": "String değerler çift tırnak içinde tanımlanır. Kotlin type inference sayesinde türü otomatik belirler."
                },
                {
                  "title": "String Interpolation",
                  "code": "val age = 25\nval message = \"Yaşım $age\"\nval result = \"5 + 3 = ${5 + 3}\"",
                  "explanation": "$ işareti ile değişkenler, ${} ile ifadeler String içine gömülebilir."
                },
                {
                  "title": "Çok Satırlı String",
                  "code": "val text = \"\"\"\n    Kotlin öğreniyorum\n    Android geliştiriyorum\n\"\"\".trimIndent()",
                  "explanation": "Üç tırnak kullanılarak çok satırlı String tanımlanabilir."
                }
              ],
              "keyPoints": [
                "String immutable bir veri tipidir",
                "Metinsel veriler için kullanılır",
                "String interpolation desteklenir",
                "Çok satırlı String yazımı mümkündür",
                "Birçok hazır fonksiyon içerir (length, contains, substring)"
              ],
              "questions": [
                {
                  "questionId": 110401,
                  "question": "Kotlin'de String veri tipi hangi özelliğe sahiptir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Mutable",
                    "Immutable",
                    "Sadece okunur",
                    "Null olabilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de String immutable'dır, yani oluşturulduktan sonra değiştirilemez.",
                  "tags": ["string", "basics"]
                },
                {
                  "questionId": 110402,
                  "question": "String interpolation için hangi sembol kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "#",
                    "$",
                    "%",
                    "&"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de $ sembolü ile String interpolation yapılır.",
                  "tags": ["string", "interpolation"]
                },
                {
                  "questionId": 110403,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val name = \"Ali\"\nprintln(\"Merhaba $name\")",
                  "difficulty": "easy",
                  "options": [
                    "Merhaba name",
                    "Merhaba $name",
                    "Merhaba Ali",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "$name ifadesi String içine gömülür ve değeri yazdırılır.",
                  "tags": ["string", "output"]
                },
                {
                  "questionId": 110404,
                  "question": "Çok satırlı String tanımlamak için hangi yapı kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "\" \"",
                    "''' '''",
                    "\"\"\" \"\"\"",
                    "` `"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de üç tırnak (\"\"\" \"\"\") çok satırlı String tanımlamak için kullanılır.",
                  "tags": ["string", "multiline"]
                },
                {
                  "questionId": 110405,
                  "question": "Aşağıdakilerden hangisi String fonksiyonu değildir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "length",
                    "contains",
                    "substring",
                    "add"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "String sınıfında add() fonksiyonu yoktur.",
                  "tags": ["string", "functions"]
                }
              ]
            },
            {
              "topicId": 1105,
              "title": "Boolean",
              "summary": "Boolean, Kotlin'de mantıksal (doğru/yanlış) değerleri temsil eden veri tipidir. Sadece true veya false değerlerini alabilir ve genellikle koşul ifadelerinde, karşılaştırmalarda ve kontrol yapılarında kullanılır.",
              "content": "## Boolean\n\nKotlin'de **Boolean** veri tipi, mantıksal ifadeleri temsil eder ve yalnızca iki değer alabilir: **true** veya **false**.\n\nBoolean'lar genellikle **if**, **when**, **while** gibi kontrol yapılarında ve karşılaştırma işlemlerinde kullanılır. Ayrıca mantıksal operatörlerle (&&, ||, !) birlikte güçlü kontrol mekanizmaları sağlar.\n\nBoolean ifadeler, uygulamanın akışını kontrol etmek için temel yapı taşlarından biridir.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Boolean Tanımlama",
                  "code": "val isActive: Boolean = true\nval isAdmin = false",
                  "explanation": "Boolean değişkenler true veya false değerlerini alabilir."
                },
                {
                  "title": "Karşılaştırma Sonucu Boolean",
                  "code": "val age = 18\nval isAdult = age >= 18",
                  "explanation": "Karşılaştırma işlemleri Boolean sonuç döner."
                },
                {
                  "title": "Mantıksal Operatörler",
                  "code": "val hasAccount = true\nval isLoggedIn = false\n\nval canAccess = hasAccount && isLoggedIn",
                  "explanation": "&& (AND), || (OR) ve ! (NOT) operatörleri Boolean işlemlerinde kullanılır."
                }
              ],
              "keyPoints": [
                "Boolean sadece true veya false değerlerini alır",
                "Kontrol yapılarının temelini oluşturur",
                "Karşılaştırma işlemleri Boolean döner",
                "Mantıksal operatörlerle birlikte kullanılır",
                "Uygulama akışını kontrol etmek için kritiktir"
              ],
              "questions": [
                {
                  "questionId": 110501,
                  "question": "Boolean veri tipi hangi değerleri alabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "1 ve 0",
                    "true ve false",
                    "Evet ve Hayır",
                    "On ve Off"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Boolean veri tipi sadece true ve false değerlerini alabilir.",
                  "tags": ["boolean", "basics"]
                },
                {
                  "questionId": 110502,
                  "question": "Aşağıdaki karşılaştırmalardan hangisi Boolean döner?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "5 + 3",
                    "10 * 2",
                    "8 > 3",
                    "7 - 4"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Karşılaştırma işlemleri Boolean (true/false) döner.",
                  "tags": ["boolean", "comparison"]
                },
                {
                  "questionId": 110503,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val isOpen = true\nval isAdmin = false\nprintln(isOpen && isAdmin)",
                  "difficulty": "medium",
                  "options": [
                    "true",
                    "false",
                    "Compile-time hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "&& operatörü AND işlemi yapar. true && false sonucu false olur.",
                  "tags": ["boolean", "operators"]
                },
                {
                  "questionId": 110504,
                  "question": "Mantıksal OR işlemi hangi operatör ile yapılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "&&",
                    "||",
                    "!",
                    "=="
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "|| operatörü mantıksal OR (veya) işlemi yapar.",
                  "tags": ["boolean", "operators"]
                },
                {
                  "questionId": 110505,
                  "question": "Aşağıdakilerden hangisi Boolean operatörü değildir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "&&",
                    "||",
                    "!",
                    "+"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "+ operatörü aritmetik işlemler içindir, Boolean işlemi yapmaz.",
                  "tags": ["boolean", "operators"]
                }
              ]
            },
            {
              "topicId": 1106,
              "title": "Tip Dönüşümleri",
              "summary": "Tip dönüşümleri, bir veri tipinin başka bir veri tipine çevrilmesi işlemidir. Kotlin'de veri kaybını ve hataları önlemek için otomatik dönüşümler yerine açık (explicit) tip dönüşümleri kullanılır.",
              "content": "## Tip Dönüşümleri\n\nKotlin'de veri tipleri arasında **otomatik dönüşüm yapılmaz**. Bu, özellikle Java'dan gelen geliştiriciler için önemli bir farktır.\n\nKotlin, güvenliği artırmak için dönüşümlerin **açıkça belirtilmesini (explicit conversion)** ister. Bunun için her veri tipinin sağladığı dönüşüm fonksiyonları kullanılır.\n\nEn sık kullanılan dönüşüm fonksiyonları:\n- toInt()\n- toLong()\n- toFloat()\n- toDouble()\n- toString()\n- toBoolean()\n\nBu yaklaşım, runtime hatalarını azaltır ve kodun daha okunabilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 6,
              "codeExamples": [
                {
                  "title": "Sayısal Tip Dönüşümü",
                  "code": "val number: Int = 10\nval longNumber: Long = number.toLong()",
                  "explanation": "Int tipi doğrudan Long'a atanamaz, toLong() fonksiyonu kullanılmalıdır."
                },
                {
                  "title": "String'den Sayıya Dönüşüm",
                  "code": "val text = \"123\"\nval value = text.toInt()",
                  "explanation": "String içeriği sayıya uygunsa toInt() ile dönüştürülebilir."
                },
                {
                  "title": "Hatalı Dönüşüm Örneği",
                  "code": "val text = \"abc\"\n// val number = text.toInt() // Runtime hatası",
                  "explanation": "Sayısal olmayan bir String, toInt() ile dönüştürülürse runtime hatası oluşur."
                },
                {
                  "title": "Güvenli Dönüşüm",
                  "code": "val text = \"abc\"\nval number = text.toIntOrNull()",
                  "explanation": "toIntOrNull() dönüşüm başarısız olursa null döner ve uygulama çökmez."
                }
              ],
              "keyPoints": [
                "Kotlin'de otomatik tip dönüşümü yoktur",
                "Dönüşümler explicit olarak yapılır",
                "toInt(), toDouble() gibi fonksiyonlar kullanılır",
                "Hatalı dönüşümler runtime hatası oluşturur",
                "toIntOrNull() gibi güvenli fonksiyonlar tercih edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 110601,
                  "question": "Kotlin'de Int bir değişken doğrudan Long'a atanabilir mi?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet, otomatik dönüşür",
                    "Hayır, toLong() kullanılmalıdır",
                    "Sadece val ile tanımlanırsa",
                    "Sadece var ile tanımlanırsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin otomatik tip dönüşümüne izin vermez. Açık dönüşüm gerekir.",
                  "tags": ["type-conversion", "basics"]
                },
                {
                  "questionId": 110602,
                  "question": "Aşağıdakilerden hangisi güvenli tip dönüşümü sağlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "toInt()",
                    "toLong()",
                    "toIntOrNull()",
                    "toDouble()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "toIntOrNull() dönüşüm başarısız olursa null döner.",
                  "tags": ["type-conversion", "null-safety"]
                },
                {
                  "questionId": 110603,
                  "question": "Aşağıdaki kod çalıştırıldığında ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val text = \"abc\"\nval number = text.toInt()\nprintln(number)",
                  "difficulty": "medium",
                  "options": [
                    "0 yazdırır",
                    "null yazdırır",
                    "Compile-time hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Sayısal olmayan bir String toInt() ile dönüştürülürse runtime hatası oluşur.",
                  "tags": ["type-conversion", "runtime"]
                },
                {
                  "questionId": 110604,
                  "question": "Aşağıdakilerden hangisi String'e dönüşüm yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "toInt()",
                    "toFloat()",
                    "toString()",
                    "toBoolean()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "toString() metodu değeri String'e çevirir.",
                  "tags": ["type-conversion", "string"]
                },
                {
                  "questionId": 110605,
                  "question": "Kotlin'de neden otomatik tip dönüşümü yoktur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performans düşüklüğü",
                    "Derleyici hatası",
                    "Kod güvenliğini artırmak",
                    "Java ile uyumsuzluk"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Açık tip dönüşümü, veri kaybını ve beklenmeyen hataları önler.",
                  "tags": ["type-conversion", "best-practices"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 12001,
            "question": "Kotlin'de değiştirilemeyen (immutable) değişken tanımlamak için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "var",
              "val",
              "let",
              "const"
            ],
            "correctAnswerIndex": 1,
            "explanation": "val ile tanımlanan değişkenler immutable'dır ve bir kez değer atandıktan sonra değiştirilemez.",
            "tags": ["val", "var"]
          },
          {
            "questionId": 12002,
            "question": "Aşağıdaki kodlardan hangisi derleme (compile-time) hatası verir?",
            "questionType": "multiple_choice",
            "code": "val number = 10\nnumber = 20",
            "difficulty": "easy",
            "options": [
              "Kod hatasız çalışır",
              "Runtime hatası verir",
              "Compile-time hatası verir",
              "Sadece uyarı verir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "val ile tanımlanan değişkenlere yeniden değer atanamaz. Bu nedenle compile-time hatası oluşur.",
            "tags": ["val", "compile-error"]
          },
          {
            "questionId": 12003,
            "question": "Kotlin'de aşağıdaki tam sayı tiplerinden hangisi daha fazla bellek kullanır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Int",
              "Short",
              "Long",
              "Byte"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Long 64-bit, Int ise 32-bit bellek kullanır. Bu nedenle Long daha fazla bellek tüketir.",
            "tags": ["int", "long"]
          },
          {
            "questionId": 12004,
            "question": "Aşağıdaki ifadelerden hangisi Double veri tipine aittir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "10",
              "10L",
              "10.5",
              "true"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Ondalıklı (kesirli) sayılar varsayılan olarak Double tipindedir.",
            "tags": ["double", "float"]
          },
          {
            "questionId": 12005,
            "question": "Kotlin'de Float tipinde bir sayı tanımlamak için hangi kullanım doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "val x = 10.5",
              "val x = 10.5D",
              "val x = 10.5F",
              "val x = Float(10.5)"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de Float tanımlamak için sayı sonuna 'F' eklenmelidir.",
            "tags": ["float", "double"]
          },
          {
            "questionId": 12006,
            "question": "Kotlin'de String birleştirme için hangi yöntem kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "+ operatörü",
              "$ operatörü",
              "& operatörü",
              "% operatörü"
            ],
            "correctAnswerIndex": 0,
            "explanation": "String'ler + operatörü ile birleştirilebilir. Ayrıca string template de kullanılabilir.",
            "tags": ["string"]
          },
          {
            "questionId": 12007,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val name = \"Ahmet\"\nprintln(\"Merhaba $name\")",
            "difficulty": "easy",
            "options": [
              "Merhaba name",
              "Merhaba $name",
              "Merhaba Ahmet",
              "Compile hatası"
            ],
            "correctAnswerIndex": 2,
            "explanation": "String template sayesinde $name ifadesi değişkenin değeriyle değiştirilir.",
            "tags": ["string", "template"]
          },
          {
            "questionId": 12008,
            "question": "Kotlin'de Boolean veri tipi hangi değerleri alabilir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "0 ve 1",
              "\"true\" ve \"false\"",
              "true ve false",
              "yes ve no"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Boolean veri tipi yalnızca true veya false değerlerini alır.",
            "tags": ["boolean"]
          },
          {
            "questionId": 12009,
            "question": "Aşağıdaki dönüşümlerden hangisi Kotlin'de doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "val x: Int = \"10\"",
              "val x = 10.toString()",
              "val x: String = 10",
              "val x = Int(\"10\")"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de tip dönüşümleri açık yapılır. toString() doğru bir kullanımdır.",
            "tags": ["type-conversion"]
          },
          {
            "questionId": 12010,
            "question": "Kotlin'de neden otomatik (implicit) tip dönüşümü yoktur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Performansı düşürdüğü için",
              "Okunabilirliği azalttığı için",
              "Tip güvenliğini artırmak için",
              "Sadece Java uyumluluğu için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin, tip güvenliğini artırmak ve olası hataları önlemek için implicit type casting yapmaz.",
            "tags": ["type-safety", "conversion"]
          }
        ]
        },
        {
          "sectionId": 103,
          "sectionTitle": "Kontrol Yapıları",
          "sectionDescription": "",
          "order": 3,
          "topics": [
            {
              "topicId": 1201,
              "title": "if / else",
              "summary": "if / else yapıları, Kotlin'de koşullu durumları kontrol etmek için kullanılır. Belirli bir şart sağlandığında çalışacak kod bloklarını tanımlamaya olanak tanır ve uygulama akışını yönlendirmek için temel bir kontrol mekanizmasıdır.",
              "content": "## if / else\n\nKotlin'de **if / else**, belirli koşullara göre kodun çalışıp çalışmayacağını kontrol etmek için kullanılır.\n\nKoşul ifadesi her zaman **Boolean** (true / false) olmalıdır. Kotlin'de if yapısı sadece bir kontrol mekanizması değil, aynı zamanda **bir ifade (expression)** olarak da kullanılabilir. Bu sayede if bloğu bir değer döndürebilir.\n\nBu özellik, Kotlin kodlarını daha kısa ve okunabilir hale getirir.\n\nif / else yapıları tek başına veya iç içe (nested) şekilde kullanılabilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit if Kullanımı",
                  "code": "val age = 20\n\nif (age >= 18) {\n    println(\"Reşit\")\n}",
                  "explanation": "Koşul true ise if bloğu çalışır."
                },
                {
                  "title": "if - else Kullanımı",
                  "code": "val age = 16\n\nif (age >= 18) {\n    println(\"Reşit\")\n} else {\n    println(\"Reşit değil\")\n}",
                  "explanation": "Koşul false olduğunda else bloğu çalışır."
                },
                {
                  "title": "if Expression Olarak Kullanımı",
                  "code": "val score = 75\n\nval result = if (score >= 60) {\n    \"Geçti\"\n} else {\n    \"Kaldı\"\n}",
                  "explanation": "Kotlin'de if bir değer döndürebilir ve değişkene atanabilir."
                },
                {
                  "title": "else if Kullanımı",
                  "code": "val note = 85\n\nval grade = if (note >= 90) {\n    \"AA\"\n} else if (note >= 80) {\n    \"BB\"\n} else {\n    \"CC\"\n}",
                  "explanation": "Birden fazla koşul else if ile kontrol edilebilir."
                }
              ],
              "keyPoints": [
                "Koşul mutlaka Boolean olmalıdır",
                "if bir expression olarak kullanılabilir",
                "else if ile çoklu koşullar kontrol edilir",
                "Kod okunabilirliği için süslü parantez önerilir",
                "Kontrol yapılarının temelidir"
              ],
              "questions": [
                {
                  "questionId": 120101,
                  "question": "if koşulu hangi türde değer almalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Int",
                    "String",
                    "Boolean",
                    "Any"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "if koşulu true veya false dönen bir ifade olmalıdır.",
                  "tags": ["if", "basics"]
                },
                {
                  "questionId": 120102,
                  "question": "Kotlin'de if yapısının önemli farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece kontrol yapısıdır",
                    "Sadece döngülerle çalışır",
                    "Bir ifade (expression) olarak değer döndürebilir",
                    "Sadece else ile kullanılır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de if bir expression'dır ve değer döndürebilir.",
                  "tags": ["if", "expression"]
                },
                {
                  "questionId": 120103,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val x = 10\nval y = 20\n\nval max = if (x > y) x else y\nprintln(max)",
                  "difficulty": "medium",
                  "options": [
                    "10",
                    "20",
                    "true",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "x > y false olduğu için else bloğu çalışır ve y değeri yazdırılır.",
                  "tags": ["if", "expression"]
                },
                {
                  "questionId": 120104,
                  "question": "else if ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Tek koşul varsa",
                    "Birden fazla koşul kontrol edilecekse",
                    "Sadece Boolean false ise",
                    "if kullanılamıyorsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Birden fazla koşul kontrol edilecekse else if kullanılır.",
                  "tags": ["if", "conditions"]
                },
                {
                  "questionId": 120105,
                  "question": "Aşağıdakilerden hangisi Kotlin'de geçerli bir if ifadesidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "if (x = 5)",
                    "if x > 5",
                    "if (x > 5) println(x)",
                    "if x > 5 then"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de koşul parantez içinde yazılır ve doğru sözdizimi gerekir.",
                  "tags": ["if", "syntax"]
                }
              ]
            },            
            {
              "topicId": 1202,
              "title": "when",
              "summary": "when yapısı, Kotlin'de çoklu koşulları kontrol etmek için kullanılan güçlü bir kontrol yapısıdır. Java'daki switch yapısının gelişmiş bir versiyonudur ve hem değer hem de koşul bazlı kontroller yapabilir.",
              "content": "## when\n\nKotlin'de **when**, bir değişkenin veya ifadenin farklı durumlara göre değerlendirilmesini sağlar. Java'daki switch yapısına benzer ancak çok daha esnek ve güçlüdür.\n\nwhen sadece sabit değerlerle değil; aralıklar, koleksiyonlar, tip kontrolleri ve Boolean koşullarla da çalışabilir. Ayrıca **if gibi bir expression** olarak kullanılarak değer döndürebilir.\n\nwhen yapısı, okunabilirliği artırır ve çoklu if-else bloklarının yerini alabilir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Basit when Kullanımı",
                  "code": "val day = 3\n\nwhen (day) {\n    1 -> println(\"Pazartesi\")\n    2 -> println(\"Salı\")\n    3 -> println(\"Çarşamba\")\n    else -> println(\"Geçersiz gün\")\n}",
                  "explanation": "Değer, eşleşen case'e göre çalışır."
                },
                {
                  "title": "Birden Fazla Değerle when",
                  "code": "val number = 2\n\nwhen (number) {\n    1, 3, 5 -> println(\"Tek\")\n    2, 4, 6 -> println(\"Çift\")\n}",
                  "explanation": "Tek bir case içinde birden fazla değer kontrol edilebilir."
                },
                {
                  "title": "when Expression Olarak Kullanımı",
                  "code": "val score = 85\n\nval result = when (score) {\n    in 90..100 -> \"AA\"\n    in 80..89 -> \"BB\"\n    else -> \"CC\"\n}",
                  "explanation": "when bir expression olarak değer döndürebilir."
                },
                {
                  "title": "Koşulsuz when Kullanımı",
                  "code": "val age = 20\n\nwhen {\n    age < 18 -> println(\"Reşit değil\")\n    age >= 18 -> println(\"Reşit\")\n}",
                  "explanation": "Koşulsuz when, Boolean ifadelerle çalışır."
                }
              ],
              "keyPoints": [
                "switch yerine kullanılır",
                "Birden fazla değeri aynı anda kontrol edebilir",
                "Aralıklar (in) ile çalışabilir",
                "Expression olarak değer döndürebilir",
                "Koşulsuz when kullanımı mümkündür"
              ],
              "questions": [
                {
                  "questionId": 120201,
                  "question": "when yapısı hangi kontrol yapısının yerine kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "if",
                    "for",
                    "switch",
                    "while"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "when, Java'daki switch yapısının gelişmiş halidir.",
                  "tags": ["when", "basics"]
                },
                {
                  "questionId": 120202,
                  "question": "Kotlin'de when yapısının önemli avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece sabit değerlerle çalışır",
                    "Expression olarak değer döndürebilir",
                    "Sadece Int ile çalışır",
                    "if yerine kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "when bir expression'dır ve değer döndürebilir.",
                  "tags": ["when", "expression"]
                },
                {
                  "questionId": 120203,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val x = 7\n\nval result = when (x) {\n    in 1..5 -> \"Düşük\"\n    in 6..10 -> \"Yüksek\"\n    else -> \"Bilinmiyor\"\n}\nprintln(result)",
                  "difficulty": "medium",
                  "options": [
                    "Düşük",
                    "Yüksek",
                    "Bilinmiyor",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "7 değeri 6..10 aralığında olduğu için \"Yüksek\" yazdırılır.",
                  "tags": ["when", "range"]
                },
                {
                  "questionId": 120204,
                  "question": "Koşulsuz when ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sabit değerler kontrol edilecekse",
                    "Boolean ifadelerle kontrol yapılacaksa",
                    "Sadece String değerler için",
                    "when kullanılamıyorsa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Koşulsuz when, Boolean ifadelerle çalışır.",
                  "tags": ["when", "conditions"]
                },
                {
                  "questionId": 120205,
                  "question": "Aşağıdakilerden hangisi when yapısında kullanılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Int",
                    "Sadece String",
                    "Sabit değerler",
                    "Sabitler, aralıklar ve koşullar"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "when; sabitler, aralıklar, koleksiyonlar ve koşullarla çalışabilir.",
                  "tags": ["when", "advanced"]
                }
              ]
            },
            {
              "topicId": 1203,
              "title": "for Döngüsü",
              "summary": "for döngüsü, Kotlin'de belirli bir aralıkta veya koleksiyon üzerinde tekrar eden işlemleri gerçekleştirmek için kullanılır. Sayaç kontrollü ve koleksiyon tabanlı döngüler için en yaygın kullanılan yapıdır.",
              "content": "## for Döngüsü\n\nKotlin'de **for döngüsü**, bir aralık (range) veya koleksiyon (Array, List, Set, Map) üzerinde dolaşmak için kullanılır.\n\nKotlin'de klasik index tabanlı for yerine daha okunabilir ve güvenli yapılar tercih edilir. Range ifadeleri, step, downTo ve until gibi anahtar kelimelerle güçlü bir kullanım sunar.\n\nfor döngüsü özellikle listeleme, veri işleme ve tekrar eden görevler için idealdir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Basit for Döngüsü",
                  "code": "for (i in 1..5) {\n    println(i)\n}",
                  "explanation": "1'den 5'e kadar (5 dahil) döner."
                },
                {
                  "title": "until Kullanımı",
                  "code": "for (i in 0 until 5) {\n    println(i)\n}",
                  "explanation": "0'dan 4'e kadar döner. 5 dahil değildir."
                },
                {
                  "title": "step ve downTo Kullanımı",
                  "code": "for (i in 10 downTo 0 step 2) {\n    println(i)\n}",
                  "explanation": "10'dan 0'a doğru 2'şer azalarak döner."
                },
                {
                  "title": "Koleksiyon Üzerinde for",
                  "code": "val names = listOf(\"Ali\", \"Ayşe\", \"Mehmet\")\n\nfor (name in names) {\n    println(name)\n}",
                  "explanation": "Liste elemanları üzerinde tek tek dolaşır."
                }
              ],
              "keyPoints": [
                "Range veya koleksiyon üzerinde çalışır",
                "until, downTo ve step desteklenir",
                "Index hatalarını azaltır",
                "Okunabilir ve güvenlidir",
                "Koleksiyon işlemlerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 120301,
                  "question": "Aşağıdaki for döngüsü kaç kez çalışır?",
                  "questionType": "multiple_choice",
                  "code": "for (i in 1..3) {\n    println(i)\n}",
                  "difficulty": "easy",
                  "options": [
                    "2",
                    "3",
                    "4",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "1..3 aralığı 1, 2 ve 3 değerlerini kapsar.",
                  "tags": ["for", "range"]
                },
                {
                  "questionId": 120302,
                  "question": "until anahtar kelimesinin farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Başlangıç değerini almaz",
                    "Bitiş değerini dahil etmez",
                    "Sadece geriye doğru çalışır",
                    "step ile kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "until, bitiş değerini dahil etmez.",
                  "tags": ["for", "until"]
                },
                {
                  "questionId": 120303,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "for (i in 5 downTo 1) {\n    print(i)\n}",
                  "difficulty": "medium",
                  "options": [
                    "12345",
                    "54321",
                    "01234",
                    "Compile-time hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "downTo geriye doğru sayar.",
                  "tags": ["for", "downTo"]
                },
                {
                  "questionId": 120304,
                  "question": "Bir koleksiyon üzerinde dolaşmak için hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "for (i = 0; i < list.size; i++)",
                    "for (item in list)",
                    "while (list)",
                    "loop (list)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de koleksiyonlar doğrudan for-in ile gezilir.",
                  "tags": ["for", "collections"]
                },
                {
                  "questionId": 120305,
                  "question": "step anahtar kelimesi ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Döngüyü durdurur",
                    "Adım sayısını belirler",
                    "Sadece ileri sayar",
                    "Bitiş değerini değiştirir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "step, döngünün kaçar kaçar ilerleyeceğini belirler.",
                  "tags": ["for", "step"]
                }
              ]
            },
            {
              "topicId": 1204,
              "title": "while / do-while Döngüsü",
              "summary": "while ve do-while döngüleri, koşul doğru olduğu sürece çalışan kontrol yapılarıdır. while döngüsünde koşul başta kontrol edilirken, do-while döngüsünde döngü en az bir kez çalışır.",
              "content": "## while ve do-while Döngüsü\n\nKotlin'de **while döngüsü**, koşul doğru olduğu sürece çalışır. Koşul döngünün başında kontrol edilir.\n\n**do-while döngüsü** ise koşulu sonda kontrol eder. Bu sayede döngü bloğu **en az bir kez** çalıştırılır.\n\nBu döngüler genellikle tekrar sayısı önceden bilinmeyen durumlarda, kullanıcıdan veri alma, API'den cevap bekleme gibi senaryolarda kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Basit while Döngüsü",
                  "code": "var i = 1\n\nwhile (i <= 5) {\n    println(i)\n    i++\n}",
                  "explanation": "Koşul doğru olduğu sürece döngü çalışır."
                },
                {
                  "title": "Yanlış Koşulda while",
                  "code": "var x = 10\n\nwhile (x < 5) {\n    println(x)\n}",
                  "explanation": "Koşul baştan false olduğu için döngü hiç çalışmaz."
                },
                {
                  "title": "do-while Döngüsü",
                  "code": "var y = 10\n\ndo {\n    println(y)\n} while (y < 5)",
                  "explanation": "Koşul false olsa bile do-while en az bir kez çalışır."
                },
                {
                  "title": "Kullanıcıdan Veri Alma Senaryosu",
                  "code": "var password: String\n\ndo {\n    password = readLine() ?: \"\"\n} while (password.length < 6)",
                  "explanation": "Şifre en az 6 karakter olana kadar döngü devam eder."
                }
              ],
              "keyPoints": [
                "while döngüsünde koşul başta kontrol edilir",
                "do-while döngüsü en az bir kez çalışır",
                "Tekrar sayısı bilinmeyen durumlar için uygundur",
                "Yanlış koşulda while hiç çalışmayabilir",
                "Sonsuz döngülere dikkat edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 120401,
                  "question": "while döngüsünün temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "En az bir kez çalışır",
                    "Koşul sonda kontrol edilir",
                    "Koşul doğru olduğu sürece çalışır",
                    "Sadece sayılarla çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "while döngüsü koşul true olduğu sürece çalışır.",
                  "tags": ["while"]
                },
                {
                  "questionId": 120402,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "var i = 5\n\nwhile (i < 3) {\n    println(i)\n}",
                  "difficulty": "easy",
                  "options": [
                    "5",
                    "3",
                    "Hiçbir çıktı olmaz",
                    "Sonsuz döngü"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Koşul baştan false olduğu için döngü çalışmaz.",
                  "tags": ["while"]
                },
                {
                  "questionId": 120403,
                  "question": "do-while döngüsünün farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Koşul başta kontrol edilir",
                    "Sadece Boolean ile çalışır",
                    "En az bir kez çalışır",
                    "Sonsuz döngü oluşturur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "do-while koşuldan bağımsız olarak en az bir kez çalışır.",
                  "tags": ["do-while"]
                },
                {
                  "questionId": 120404,
                  "question": "Aşağıdaki kod kaç kez çalışır?",
                  "questionType": "multiple_choice",
                  "code": "var x = 0\n\ndo {\n    x++\n} while (x < 3)",
                  "difficulty": "medium",
                  "options": [
                    "1",
                    "2",
                    "3",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "x değeri 0,1,2 iken döngü çalışır. Toplam 3 kez.",
                  "tags": ["do-while"]
                },
                {
                  "questionId": 120405,
                  "question": "Sonsuz döngüye sebep olan durum hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Koşulun hiç güncellenmemesi",
                    "Koşulun false olması",
                    "Koşulun başta kontrol edilmesi",
                    "do-while kullanılması"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Koşul değişmezse döngü sonsuza kadar devam edebilir.",
                  "tags": ["while", "do-while"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 13001,
            "question": "Kotlin'de if yapısı hakkında aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece koşul kontrolü için kullanılır, değer döndüremez",
              "Sadece Boolean döndürür",
              "Bir ifade (expression) olarak değer döndürebilir",
              "Sadece Java uyumluluğu için vardır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de if bir expression'dır ve bir değer döndürebilir.",
            "tags": ["if", "else"]
          },
          {
            "questionId": 13002,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val x = 10\nval result = if (x > 5) \"Büyük\" else \"Küçük\"\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "Küçük",
              "Büyük",
              "true",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "x değeri 5'ten büyük olduğu için if bloğu çalışır ve \"Büyük\" yazdırılır.",
            "tags": ["if", "else"]
          },
          {
            "questionId": 13003,
            "question": "Kotlin'de when yapısı için aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece switch yerine kullanılır",
              "Sadece Int tipleriyle çalışır",
              "Hem koşul hem değer döndürebilir",
              "Sadece Boolean döndürür"
            ],
            "correctAnswerIndex": 2,
            "explanation": "when, Kotlin'de güçlü bir kontrol yapısıdır ve expression olarak değer döndürebilir.",
            "tags": ["when"]
          },
          {
            "questionId": 13004,
            "question": "Aşağıdaki when bloğunun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val day = 3\nval result = when(day) {\n    1 -> \"Pazartesi\"\n    2 -> \"Salı\"\n    3 -> \"Çarşamba\"\n    else -> \"Bilinmiyor\"\n}\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "Salı",
              "Çarşamba",
              "Pazartesi",
              "Bilinmiyor"
            ],
            "correctAnswerIndex": 1,
            "explanation": "day değeri 3 olduğu için when bloğunda \"Çarşamba\" çalışır.",
            "tags": ["when"]
          },
          {
            "questionId": 13005,
            "question": "Aşağıdaki for döngüsü kaç kez çalışır?",
            "questionType": "multiple_choice",
            "code": "for (i in 1..5) {\n    println(i)\n}",
            "difficulty": "easy",
            "options": [
              "4",
              "5",
              "6",
              "Sonsuz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "1..5 aralığı her iki sınırı da dahil eder, döngü 5 kez çalışır.",
            "tags": ["for"]
          },
          {
            "questionId": 13006,
            "question": "Kotlin'de aşağıdaki aralıklardan hangisi 5 değerini içermez?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "1..5",
              "1 until 5",
              "5 downTo 1",
              "1..10"
            ],
            "correctAnswerIndex": 1,
            "explanation": "until üst sınırı dahil etmez, bu nedenle 5 değeri aralığa dahil değildir.",
            "tags": ["for", "range"]
          },
          {
            "questionId": 13007,
            "question": "Aşağıdaki while döngüsü ile ilgili hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "En az bir kez çalışır",
              "Koşul sağlanmazsa hiç çalışmaz",
              "Sadece Int ile çalışır",
              "for döngüsünden daha hızlıdır"
            ],
            "correctAnswerIndex": 1,
            "explanation": "while döngüsünde koşul başta kontrol edilir, koşul false ise döngü hiç çalışmaz.",
            "tags": ["while"]
          },
          {
            "questionId": 13008,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "var i = 0\nwhile (i < 3) {\n    print(i)\n    i++\n}",
            "difficulty": "easy",
            "options": [
              "012",
              "123",
              "03",
              "Sonsuz döngü"
            ],
            "correctAnswerIndex": 0,
            "explanation": "i değeri 0'dan başlayarak 3'e kadar artırılır ve ekrana 012 yazdırılır.",
            "tags": ["while"]
          },
          {
            "questionId": 13009,
            "question": "Kotlin'de if-else yerine when kullanmanın avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Daha hızlı çalışır",
              "Daha az bellek kullanır",
              "Daha okunabilir ve genişletilebilir yapı sunar",
              "Sadece Boolean destekler"
            ],
            "correctAnswerIndex": 2,
            "explanation": "when, çoklu koşullarda kodun okunabilirliğini ve bakımını artırır.",
            "tags": ["when", "if"]
          },
          {
            "questionId": 13010,
            "question": "Kotlin'de for döngüsünde index'e erişmek için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "withIndex()",
              "getIndex()",
              "indexOf()",
              "forEachIndex()"
            ],
            "correctAnswerIndex": 0,
            "explanation": "withIndex() fonksiyonu, eleman ve index bilgisine birlikte erişim sağlar.",
            "tags": ["for", "index"]
          }
        ]
        },
        {
          "sectionId": 104,
          "sectionTitle": "Koleksiyonlar",
          "sectionDescription": "",
          "order": 4,
          "topics": [
            {
              "topicId": 1301,
              "title": "Array",
              "summary": "Array, aynı türden birden fazla veriyi tek bir değişken altında saklamaya yarayan sabit boyutlu bir veri yapısıdır. Kotlin'de Array'ler index mantığıyla çalışır ve elemanlara 0'dan başlayarak erişilir.",
              "content": "## Array (Dizi)\n\nArray, Kotlin'de belirli sayıda ve **aynı türde** veriyi saklamak için kullanılır. Array'lerin boyutu tanımlandıktan sonra değiştirilemez.\n\nHer eleman bir index numarasına sahiptir ve index'ler **0'dan başlar**. Array'ler genellikle sabit veri listeleri veya performansın önemli olduğu durumlarda tercih edilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Array Tanımlama",
                  "code": "val numbers = arrayOf(1, 2, 3, 4, 5)",
                  "explanation": "Integer türünde bir Array oluşturulur."
                },
                {
                  "title": "Index ile Erişim",
                  "code": "val cities = arrayOf(\"Ankara\", \"İstanbul\", \"İzmir\")\nprintln(cities[0])",
                  "explanation": "Array'in ilk elemanına erişilir."
                },
                {
                  "title": "Array Elemanı Güncelleme",
                  "code": "val ages = arrayOf(18, 20, 25)\nages[1] = 21",
                  "explanation": "Index kullanılarak eleman güncellenebilir."
                },
                {
                  "title": "Array Boyutu",
                  "code": "val names = arrayOf(\"Ali\", \"Veli\")\nprintln(names.size)",
                  "explanation": "Array içindeki eleman sayısını verir."
                },
                {
                  "title": "Döngü ile Array Gezme",
                  "code": "val scores = arrayOf(60, 70, 80)\nfor (score in scores) {\n    println(score)\n}",
                  "explanation": "for döngüsü ile tüm elemanlar gezilir."
                }
              ],
              "keyPoints": [
                "Array sabit boyutludur",
                "Aynı türden veriler saklanır",
                "Index'ler 0'dan başlar",
                "size özelliği eleman sayısını verir",
                "Elemanlar değiştirilebilir ama boyut değiştirilemez"
              ],
              "questions": [
                {
                  "questionId": 130101,
                  "question": "Array nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Farklı türden verileri tutan yapı",
                    "Sabit boyutlu veri koleksiyonu",
                    "Sonsuz eleman tutan liste",
                    "Sadece String tutan yapı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Array sabit boyutlu ve aynı türden verileri tutar.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130102,
                  "question": "Array index'leri kaçtan başlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "1",
                    "-1",
                    "0",
                    "2"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de Array index'leri 0'dan başlar.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130103,
                  "question": "Aşağıdaki kodun çıktısı nedir?",
                  "questionType": "multiple_choice",
                  "code": "val arr = arrayOf(10, 20, 30)\nprintln(arr[1])",
                  "difficulty": "easy",
                  "options": [
                    "10",
                    "20",
                    "30",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Index 1 ikinci elemanı temsil eder.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130104,
                  "question": "Array ile ilgili hangisi yanlıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Boyutu sonradan değiştirilebilir",
                    "Elemanlara index ile erişilir",
                    "Aynı türde veri tutar",
                    "size özelliği vardır"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Array'in boyutu tanımlandıktan sonra değiştirilemez.",
                  "tags": ["array"]
                },
                {
                  "questionId": 130105,
                  "question": "Array hangi durumda daha uygundur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Eleman sayısı sürekli değişiyorsa",
                    "Sabit ve küçük veri listesi varsa",
                    "Farklı türler birlikte tutulacaksa",
                    "Dinamik ekleme çıkarma yapılacaksa"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Array sabit boyutlu olduğu için değişmeyen veri listelerinde uygundur.",
                  "tags": ["array"]
                }
              ]
            },
            {
              "topicId": 1302,
              "title": "List ve MutableList",
              "summary": "List ve MutableList, Kotlin'de sıralı veri koleksiyonlarını temsil eder. List değiştirilemez (immutable) bir yapı sunarken, MutableList eleman ekleme, silme ve güncelleme gibi işlemlere izin verir.",
              "content": "## List ve MutableList\n\nKotlin'de List ve MutableList, aynı türden birden fazla veriyi sıralı şekilde saklamak için kullanılır.\n\n- **List**: Değiştirilemez (immutable). Eleman ekleme, silme veya güncelleme yapılamaz.\n- **MutableList**: Değiştirilebilir (mutable). Eleman ekleme, silme ve güncelleme yapılabilir.\n\nBest practice olarak, eğer koleksiyon değişmeyecekse List kullanılması önerilir. Bu yaklaşım kod güvenliğini ve okunabilirliği artırır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "List Tanımlama",
                  "code": "val names = listOf(\"Ali\", \"Veli\", \"Ayşe\")",
                  "explanation": "Değiştirilemez bir List oluşturulur."
                },
                {
                  "title": "MutableList Tanımlama",
                  "code": "val numbers = mutableListOf(1, 2, 3)",
                  "explanation": "Değiştirilebilir bir MutableList oluşturulur."
                },
                {
                  "title": "MutableList'e Eleman Ekleme",
                  "code": "val cities = mutableListOf(\"Ankara\", \"İstanbul\")\ncities.add(\"İzmir\")",
                  "explanation": "MutableList'e add() metodu ile eleman eklenir."
                },
                {
                  "title": "MutableList Eleman Güncelleme",
                  "code": "val ages = mutableListOf(18, 20, 25)\nages[1] = 21",
                  "explanation": "Index kullanılarak eleman güncellenebilir."
                },
                {
                  "title": "List Üzerinde Döngü",
                  "code": "val scores = listOf(60, 70, 80)\nfor (score in scores) {\n    println(score)\n}",
                  "explanation": "for döngüsü ile List elemanları gezilir."
                }
              ],
              "keyPoints": [
                "List immutable'dır, değiştirilemez",
                "MutableList mutable'dır, değiştirilebilir",
                "Index'ler 0'dan başlar",
                "List güvenli ve okunabilir kod sağlar",
                "Değişmeyecek koleksiyonlar için List tercih edilmelidir"
              ],
              "questions": [
                {
                  "questionId": 130201,
                  "question": "List ve MutableList arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "List daha hızlıdır",
                    "MutableList sadece String tutar",
                    "List değiştirilemez, MutableList değiştirilebilir",
                    "Aralarında fark yoktur"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "List immutable, MutableList mutable bir koleksiyondur.",
                  "tags": ["list", "mutablelist"]
                },
                {
                  "questionId": 130202,
                  "question": "Aşağıdakilerden hangisi eleman eklemeye izin verir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "listOf",
                    "List",
                    "MutableList",
                    "Array"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "MutableList eleman ekleme ve silmeye izin verir.",
                  "tags": ["mutablelist"]
                },
                {
                  "questionId": 130203,
                  "question": "Aşağıdaki kodda hangi satır hata verir?",
                  "questionType": "multiple_choice",
                  "code": "val list = listOf(1, 2, 3)\nlist.add(4)",
                  "difficulty": "medium",
                  "options": [
                    "Satır 1",
                    "Satır 2",
                    "İkisi de çalışır",
                    "Runtime hatası olur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "listOf ile oluşturulan List immutable olduğu için add() kullanılamaz.",
                  "tags": ["list"]
                },
                {
                  "questionId": 130204,
                  "question": "MutableList ile aşağıdakilerden hangisi yapılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Boyutunu değiştirmek",
                    "Sadece okuma yapmak",
                    "Sabit veri saklamak",
                    "Sadece compile-time'da kullanmak"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "MutableList eleman ekleme, silme ve güncellemeye izin verir.",
                  "tags": ["mutablelist"]
                },
                {
                  "questionId": 130205,
                  "question": "Best practice olarak hangisi önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her zaman MutableList kullanmak",
                    "Değişmeyecekse List kullanmak",
                    "Array yerine her zaman MutableList kullanmak",
                    "List kullanmamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Değişmeyecek koleksiyonlar için List kullanmak kod güvenliğini artırır.",
                  "tags": ["best-practice", "list"]
                }
              ]
            },
            {
              "topicId": 1303,
              "title": "Set",
              "summary": "Set, Kotlin'de benzersiz (unique) elemanlar tutan bir koleksiyon türüdür. Aynı elemandan birden fazla bulunmasına izin vermez ve genellikle tekrar eden verileri engellemek için kullanılır.",
              "content": "## Set\n\nSet, aynı türden benzersiz elemanları saklamak için kullanılan bir koleksiyondur.\n\n- **Set**: Değiştirilemez (immutable)\n- **MutableSet**: Değiştirilebilir (mutable)\n\nSet'lerde elemanların sırası garanti edilmez. Aynı değer birden fazla kez eklenmeye çalışılırsa sadece bir tanesi saklanır.\n\nTekrar eden verileri otomatik olarak filtrelemek için ideal bir yapıdır.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Set Tanımlama",
                  "code": "val numbers = setOf(1, 2, 3, 3, 4)",
                  "explanation": "Set tekrar eden elemanları otomatik olarak tekilleştirir."
                },
                {
                  "title": "MutableSet Tanımlama",
                  "code": "val cities = mutableSetOf(\"Ankara\", \"İstanbul\")",
                  "explanation": "Değiştirilebilir bir MutableSet oluşturulur."
                },
                {
                  "title": "MutableSet'e Eleman Ekleme",
                  "code": "val colors = mutableSetOf(\"Red\", \"Blue\")\ncolors.add(\"Green\")",
                  "explanation": "add() metodu ile yeni eleman eklenebilir."
                },
                {
                  "title": "Tekrar Eden Eleman Ekleme",
                  "code": "val set = mutableSetOf(1, 2, 3)\nset.add(2)\nprintln(set.size)",
                  "explanation": "Aynı eleman tekrar eklense bile Set içinde bir kez bulunur."
                },
                {
                  "title": "Set Üzerinde Döngü",
                  "code": "val fruits = setOf(\"Apple\", \"Banana\", \"Orange\")\nfor (fruit in fruits) {\n    println(fruit)\n}",
                  "explanation": "for döngüsü ile Set elemanları gezilebilir."
                }
              ],
              "keyPoints": [
                "Set benzersiz elemanlar tutar",
                "Aynı eleman Set içinde birden fazla kez bulunamaz",
                "Set immutable, MutableSet mutable'dır",
                "Eleman sırası garanti edilmez",
                "Tekrar eden verileri engellemek için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 130301,
                  "question": "Set koleksiyonunun temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sıralı elemanlar tutar",
                    "Tekrar eden elemanlara izin verir",
                    "Benzersiz elemanlar tutar",
                    "Sadece sayısal veri saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set aynı elemandan yalnızca bir tane tutar.",
                  "tags": ["set"]
                },
                {
                  "questionId": 130302,
                  "question": "Aşağıdakilerden hangisi değiştirilebilir Set oluşturur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "setOf",
                    "listOf",
                    "mutableSetOf",
                    "arrayOf"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "mutableSetOf ile MutableSet oluşturulur.",
                  "tags": ["mutableset"]
                },
                {
                  "questionId": 130303,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val set = setOf(1, 2, 2, 3)\nprintln(set.size)",
                  "difficulty": "medium",
                  "options": [
                    "2",
                    "3",
                    "4",
                    "Compile hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Set tekrar eden elemanları tekilleştirir, bu yüzden size 3 olur.",
                  "tags": ["set"]
                },
                {
                  "questionId": 130304,
                  "question": "Set kullanmanın en uygun olduğu senaryo hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sıralı veri gerektiğinde",
                    "Index ile erişim gerektiğinde",
                    "Tekrar eden verilerin engellenmesi gerektiğinde",
                    "Elemanların sürekli güncellendiği durumlarda"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set, tekrar eden elemanları otomatik olarak engeller.",
                  "tags": ["set", "use-case"]
                },
                {
                  "questionId": 130305,
                  "question": "Set koleksiyonları hakkında hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Set index kullanır",
                    "Set sıralı çalışır",
                    "Set tekrar eden elemanları tutmaz",
                    "Set sadece String saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Set aynı elemanı birden fazla kez tutmaz.",
                  "tags": ["set"]
                }
              ]
            },
            {
              "topicId": 1304,
              "title": "Map",
              "summary": "Map, Kotlin'de anahtar-değer (key-value) mantığıyla çalışan bir koleksiyon türüdür. Her anahtar benzersizdir ve bir değere karşılık gelir. Verilere anahtar üzerinden hızlı erişim sağlar.",
              "content": "## Map\n\nMap, verileri anahtar (key) ve değer (value) çiftleri halinde saklar.\n\n- **Map**: Değiştirilemez (immutable)\n- **MutableMap**: Değiştirilebilir (mutable)\n\nMap'lerde anahtarlar benzersizdir. Aynı anahtar tekrar eklenirse eski değer güncellenir. Android geliştirmede JSON verileri, ayarlar ve cache işlemlerinde sıkça kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Map Tanımlama",
                  "code": "val ages = mapOf(\"Ahmet\" to 25, \"Mehmet\" to 30)",
                  "explanation": "mapOf ile değiştirilemez bir Map oluşturulur."
                },
                {
                  "title": "MutableMap Tanımlama",
                  "code": "val scores = mutableMapOf(\"Math\" to 90, \"Physics\" to 85)",
                  "explanation": "mutableMapOf ile değiştirilebilir bir Map oluşturulur."
                },
                {
                  "title": "Map'ten Veri Okuma",
                  "code": "val cities = mapOf(\"TR\" to \"Ankara\", \"FR\" to \"Paris\")\nprintln(cities[\"TR\"])",
                  "explanation": "Anahtar kullanılarak değere erişilir."
                },
                {
                  "title": "MutableMap'e Veri Ekleme",
                  "code": "val prices = mutableMapOf(\"Apple\" to 5)\nprices[\"Banana\"] = 3",
                  "explanation": "Yeni anahtar-değer çifti eklenir."
                },
                {
                  "title": "Aynı Anahtarla Güncelleme",
                  "code": "val map = mutableMapOf(\"A\" to 1)\nmap[\"A\"] = 2\nprintln(map[\"A\"])",
                  "explanation": "Aynı anahtar tekrar eklenirse değer güncellenir."
                }
              ],
              "keyPoints": [
                "Map key-value yapısı ile çalışır",
                "Anahtarlar benzersizdir",
                "Map immutable, MutableMap mutable'dır",
                "Anahtar ile hızlı veri erişimi sağlar",
                "Android'de JSON ve ayar verilerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 130401,
                  "question": "Map koleksiyonunun temel özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sıralı elemanlar tutar",
                    "Index ile erişim sağlar",
                    "Anahtar-değer yapısıyla çalışır",
                    "Tek tip veri saklar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map, anahtar-değer (key-value) yapısına sahiptir.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130402,
                  "question": "Aşağıdakilerden hangisi değiştirilebilir Map oluşturur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "mapOf",
                    "listOf",
                    "mutableMapOf",
                    "setOf"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "mutableMapOf ile MutableMap oluşturulur.",
                  "tags": ["mutablemap"]
                },
                {
                  "questionId": 130403,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val map = mapOf(\"A\" to 1, \"A\" to 2)\nprintln(map.size)",
                  "difficulty": "medium",
                  "options": [
                    "1",
                    "2",
                    "Compile hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Map anahtarları benzersizdir. Aynı anahtar tekrar kullanıldığında son değer geçerli olur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130404,
                  "question": "Map'ten veri okumak için hangisi kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "map.getKey()",
                    "map.value()",
                    "map[key]",
                    "map.indexOf()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map'te değerler anahtar kullanılarak map[key] şeklinde okunur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 130405,
                  "question": "Map kullanımı için en uygun senaryo hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sıralı veri gerektiğinde",
                    "Index ile erişim gerektiğinde",
                    "Anahtar ile hızlı erişim gerektiğinde",
                    "Tekrar eden veriler gerektiğinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map, anahtar üzerinden hızlı erişim gereken durumlarda kullanılır.",
                  "tags": ["map", "use-case"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 14001,
            "question": "Kotlin'de Array ile List arasındaki temel fark nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Array immutable, List mutable'dır",
              "Array sabit boyutludur, List dinamik boyutludur",
              "Array sadece Int tutar",
              "List sadece String tutar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Array sabit boyutludur, List ise dinamik olarak büyüyüp küçülebilir.",
            "tags": ["array", "list"]
          },
          {
            "questionId": 14002,
            "question": "Aşağıdaki Array tanımının çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val numbers = arrayOf(1, 2, 3)\nprintln(numbers[1])",
            "difficulty": "easy",
            "options": [
              "1",
              "2",
              "3",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Array indexleri 0'dan başlar, index 1 değeri 2'dir.",
            "tags": ["array"]
          },
          {
            "questionId": 14003,
            "question": "Kotlin'de List ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Eleman eklenip çıkarılabilir",
              "Sadece MutableList ile eleman eklenebilir",
              "Index yapısı yoktur",
              "Sadece Int tutar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "List immutable'dır, eleman ekleme/çıkarma işlemleri MutableList ile yapılır.",
            "tags": ["list", "mutablelist"]
          },
          {
            "questionId": 14004,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val list = mutableListOf(10, 20)\nlist.add(30)\nprintln(list.size)",
            "difficulty": "easy",
            "options": [
              "2",
              "3",
              "30",
              "Hata verir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "MutableList'e eleman eklenebilir, toplam eleman sayısı 3 olur.",
            "tags": ["mutablelist"]
          },
          {
            "questionId": 14005,
            "question": "Set koleksiyonunun temel özelliği nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Index yapısı vardır",
              "Aynı elemandan birden fazla olabilir",
              "Tekrarlı elemanlara izin vermez",
              "Sıralı çalışmak zorundadır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Set, duplicate (tekrarlı) elemanlara izin vermez.",
            "tags": ["set"]
          },
          {
            "questionId": 14006,
            "question": "Aşağıdaki Set tanımının çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val set = setOf(1, 2, 2, 3)\nprintln(set.size)",
            "difficulty": "medium",
            "options": [
              "4",
              "3",
              "2",
              "Hata verir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Set tekrarlı elemanları kabul etmez, sadece 1,2,3 tutulur.",
            "tags": ["set"]
          },
          {
            "questionId": 14007,
            "question": "Map koleksiyonunda veriler nasıl tutulur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Index - Value",
              "Key - Value",
              "Value - Value",
              "Key - Key"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Map yapısı key-value (anahtar-değer) mantığıyla çalışır.",
            "tags": ["map"]
          },
          {
            "questionId": 14008,
            "question": "Aşağıdaki Map kullanımında ekrana ne yazdırılır?",
            "questionType": "multiple_choice",
            "code": "val map = mapOf(\"a\" to 1, \"b\" to 2)\nprintln(map[\"b\"])",
            "difficulty": "easy",
            "options": [
              "a",
              "1",
              "2",
              "null"
            ],
            "correctAnswerIndex": 2,
            "explanation": "\"b\" anahtarının karşılığı 2'dir.",
            "tags": ["map"]
          },
          {
            "questionId": 14009,
            "question": "MutableMap ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "code": null,
            "options": [
              "Yeni key-value eklenemez",
              "Sadece okunabilir",
              "Key-value ekleme ve silme yapılabilir",
              "Index kullanır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "MutableMap, Map'in değiştirilebilir versiyonudur.",
            "tags": ["map", "mutablemap"]
          },
          {
            "questionId": 14010,
            "question": "Aşağıdaki koleksiyonlardan hangisi benzersiz veri tutmak için en uygundur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Array",
              "List",
              "Set",
              "Map"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Set yapısı duplicate elemanları otomatik olarak engeller.",
            "tags": ["set", "collections"]
          }
        ]
        },
        {
          "sectionId": 105,
          "sectionTitle": "Fonksiyonlar ve Null Safety",
          "sectionDescription": "",
          "order": 5,
          "topics": [
            {
              "topicId": 1401,
              "title": "Fonksiyonlar",
              "summary": "Fonksiyonlar, belirli bir işi yapmak için yazılan ve gerektiğinde tekrar tekrar çağrılabilen kod bloklarıdır. Kotlin'de fonksiyonlar daha okunabilir, kısa ve güvenli bir yapı sunar.",
              "content": "## Fonksiyonlar\n\nFonksiyonlar, kod tekrarını önlemek ve uygulamayı daha düzenli hale getirmek için kullanılır.\n\nKotlin'de fonksiyonlar `fun` anahtar kelimesi ile tanımlanır. Fonksiyonlar parametre alabilir, değer döndürebilir veya sadece işlem yapabilir.\n\nKotlin'in kısa söz dizimi sayesinde tek satırlık fonksiyonlar sade bir şekilde yazılabilir. Fonksiyonlar Android geliştirmede UI işlemleri, veri işleme ve iş mantığını ayırmak için sıkça kullanılır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Parametresiz Fonksiyon",
                  "code": "fun sayHello() {\n    println(\"Merhaba Kotlin\")\n}",
                  "explanation": "Parametre almayan ve sadece işlem yapan basit bir fonksiyon."
                },
                {
                  "title": "Parametre Alan Fonksiyon",
                  "code": "fun greet(name: String) {\n    println(\"Merhaba $name\")\n}",
                  "explanation": "Fonksiyon dışarıdan parametre alabilir."
                },
                {
                  "title": "Geriye Değer Döndüren Fonksiyon",
                  "code": "fun sum(a: Int, b: Int): Int {\n    return a + b\n}",
                  "explanation": "Fonksiyon hesaplama yapıp bir değer döndürebilir."
                },
                {
                  "title": "Tek Satırlık Fonksiyon",
                  "code": "fun multiply(a: Int, b: Int): Int = a * b",
                  "explanation": "Tek satırlık fonksiyonlarda return yazmaya gerek yoktur."
                },
                {
                  "title": "Fonksiyon Çağırma",
                  "code": "val result = sum(5, 3)\nprintln(result)",
                  "explanation": "Fonksiyon çağrılarak dönen değer kullanılabilir."
                }
              ],
              "keyPoints": [
                "Fonksiyonlar fun anahtar kelimesi ile tanımlanır",
                "Parametre alabilir veya almayabilir",
                "Geriye değer döndürebilir",
                "Kod tekrarını önler",
                "Android projelerinde iş mantığını ayırmak için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 140101,
                  "question": "Kotlin'de fonksiyon tanımlamak için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "function",
                    "def",
                    "fun",
                    "method"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de fonksiyonlar fun anahtar kelimesi ile tanımlanır.",
                  "tags": ["functions", "basics"]
                },
                {
                  "questionId": 140102,
                  "question": "Bir fonksiyonun geriye değer döndürmesi için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "println kullanılmalı",
                    "return kullanılmalı",
                    "val kullanılmalı",
                    "var kullanılmalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlar return anahtar kelimesi ile değer döndürür.",
                  "tags": ["functions", "return"]
                },
                {
                  "questionId": 140103,
                  "question": "Aşağıdaki fonksiyonlardan hangisi doğru tanımlanmıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "fun sum(a, b): Int",
                    "fun sum(a: Int, b: Int): Int = a + b",
                    "function sum(a: Int, b: Int)",
                    "def sum(a: Int, b: Int)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de parametre tipleri belirtilmeli ve fun anahtar kelimesi kullanılmalıdır.",
                  "tags": ["functions", "syntax"]
                },
                {
                  "questionId": 140104,
                  "question": "Tek satırlık fonksiyonlarda hangisi kullanılmaz?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "return",
                    "fun",
                    "Parametreler",
                    "Dönüş tipi"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Tek satırlık fonksiyonlarda return anahtar kelimesi kullanılmaz.",
                  "tags": ["functions"]
                },
                {
                  "questionId": 140105,
                  "question": "Fonksiyonların en büyük faydası nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kod boyutunu artırmak",
                    "Kod tekrarını azaltmak",
                    "Daha fazla değişken oluşturmak",
                    "Sadece çıktı almak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlar kod tekrarını azaltır ve düzenli kod yazılmasını sağlar.",
                  "tags": ["functions", "best-practice"]
                }
              ]
            },
            {
              "topicId": 1402,
              "title": "Parametreler ve Geri Dönüş Tipleri",
              "summary": "Parametreler, fonksiyonlara dışarıdan veri göndermeyi sağlar. Geri dönüş tipi ise fonksiyonun yaptığı işlemin sonucunda döndürdüğü veri tipini belirtir. Kotlin'de fonksiyonlar farklı parametreler alabilir ve farklı türlerde değerler döndürebilir.",
              "content": "## Parametreler ve Geri Dönüş Tipleri\n\nFonksiyonlar, dışarıdan veri alabilmek için parametre kullanır. Parametrelerin türleri açıkça belirtilmelidir.\n\nGeri dönüş tipi, fonksiyonun yaptığı işlem sonucunda hangi türde bir değer döndüreceğini ifade eder. Eğer fonksiyon bir değer döndürmüyorsa dönüş tipi `Unit` olarak kabul edilir.\n\nKotlin'de varsayılan parametreler, isimli parametreler ve Unit dönüş tipi gibi modern özellikler bulunmaktadır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Tek Parametreli Fonksiyon",
                  "code": "fun printAge(age: Int) {\n    println(age)\n}",
                  "explanation": "Fonksiyon tek bir parametre alabilir."
                },
                {
                  "title": "Birden Fazla Parametre",
                  "code": "fun sum(a: Int, b: Int): Int {\n    return a + b\n}",
                  "explanation": "Fonksiyon birden fazla parametre alabilir."
                },
                {
                  "title": "Unit Dönüş Tipi",
                  "code": "fun showMessage(message: String): Unit {\n    println(message)\n}",
                  "explanation": "Değer döndürmeyen fonksiyonların dönüş tipi Unit'tir."
                },
                {
                  "title": "Varsayılan Parametre",
                  "code": "fun greet(name: String = \"Misafir\") {\n    println(\"Merhaba $name\")\n}",
                  "explanation": "Parametreye varsayılan değer atanabilir."
                },
                {
                  "title": "İsimli Parametre Kullanımı",
                  "code": "greet(name = \"Ahmet\")",
                  "explanation": "Parametreler isimleriyle çağrılabilir."
                }
              ],
              "keyPoints": [
                "Parametreler fonksiyonlara veri aktarır",
                "Parametre tipleri belirtilmelidir",
                "Fonksiyonlar değer döndürebilir veya Unit döndürür",
                "Varsayılan parametreler kullanılabilir",
                "İsimli parametreler okunabilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 140201,
                  "question": "Fonksiyonlara dışarıdan veri göndermek için ne kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Return",
                    "Parametre",
                    "Variable",
                    "Unit"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Fonksiyonlara veri parametreler aracılığıyla gönderilir.",
                  "tags": ["parameters"]
                },
                {
                  "questionId": 140202,
                  "question": "Değer döndürmeyen fonksiyonların dönüş tipi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Void",
                    "Null",
                    "Unit",
                    "None"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin'de değer döndürmeyen fonksiyonların dönüş tipi Unit'tir.",
                  "tags": ["unit"]
                },
                {
                  "questionId": 140203,
                  "question": "Aşağıdaki fonksiyonlardan hangisi varsayılan parametre kullanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "fun test(a: Int)",
                    "fun test(a: Int = 5)",
                    "fun test(a)",
                    "fun test(): Int"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Varsayılan parametre, parametreye başlangıç değeri verilerek tanımlanır.",
                  "tags": ["default-parameters"]
                },
                {
                  "questionId": 140204,
                  "question": "İsimli parametrelerin en büyük avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performansı artırmak",
                    "Hafıza kullanımını azaltmak",
                    "Kod okunabilirliğini artırmak",
                    "Daha az parametre kullanmak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "İsimli parametreler, fonksiyon çağrılarını daha okunabilir yapar.",
                  "tags": ["named-parameters"]
                },
                {
                  "questionId": 140205,
                  "question": "Bir fonksiyonun dönüş tipini belirtmek için hangi sembol kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "=",
                    "->",
                    ":",
                    "::"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Fonksiyon dönüş tipi iki nokta (:) ile belirtilir.",
                  "tags": ["return-type"]
                }
              ]
            },
            {
              "topicId": 1403,
              "title": "Null Safety",
              "summary": "Null Safety, Kotlin'in null referans hatalarını (NullPointerException) önlemek için sunduğu bir güvenlik mekanizmasıdır. Kotlin'de bir değişken varsayılan olarak null olamaz, bu da uygulamaların daha güvenli çalışmasını sağlar.",
              "content": "## Null Safety\n\nKotlin'de değişkenler varsayılan olarak null olamaz. Eğer bir değişkenin null değer alabilmesini istiyorsak, tipinin sonuna `?` eklememiz gerekir.\n\nKotlin, null değerlerle güvenli çalışmak için çeşitli operatörler sunar:\n\n- `?` : Nullable değişken\n- `?.` : Safe call (güvenli çağrı)\n- `?:` : Elvis operatörü (varsayılan değer)\n- `!!` : Not-null assertion (risklidir)\n\nBu yapı sayesinde NullPointerException hataları büyük ölçüde engellenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Nullable Değişken",
                  "code": "var name: String? = null",
                  "explanation": "String? ifadesi değişkenin null olabileceğini belirtir."
                },
                {
                  "title": "Safe Call (?.)",
                  "code": "val length = name?.length",
                  "explanation": "Eğer name null ise hata vermez, sonuç null olur."
                },
                {
                  "title": "Elvis Operatörü (?:)",
                  "code": "val length = name?.length ?: 0",
                  "explanation": "Eğer name null ise varsayılan olarak 0 atanır."
                },
                {
                  "title": "Not-Null Assertion (!!)",
                  "code": "val length = name!!.length",
                  "explanation": "name null ise uygulama çöker. Dikkatli kullanılmalıdır."
                },
                {
                  "title": "if ile Null Kontrolü",
                  "code": "if (name != null) {\n    println(name.length)\n}",
                  "explanation": "Klasik null kontrolü yapılabilir."
                }
              ],
              "keyPoints": [
                "Kotlin'de değişkenler varsayılan olarak null olamaz",
                "Nullable değişkenler ? ile tanımlanır",
                "Safe call (?.) NullPointerException'ı önler",
                "Elvis operatörü varsayılan değer sağlar",
                "!! operatörü risklidir ve önerilmez"
              ],
              "questions": [
                {
                  "questionId": 140301,
                  "question": "Kotlin'de bir değişkenin null olabilmesi için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val kullanmak",
                    "var kullanmak",
                    "Tipin sonuna ? eklemek",
                    "!! kullanmak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Nullable değişkenler ? ile tanımlanır.",
                  "tags": ["null-safety"]
                },
                {
                  "questionId": 140302,
                  "question": "Safe call operatörü hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "!!",
                    "?:",
                    "?.",
                    "::"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "?. operatörü null güvenli çağrı sağlar.",
                  "tags": ["safe-call"]
                },
                {
                  "questionId": 140303,
                  "question": "Aşağıdaki kodda name null ise length değeri ne olur?",
                  "questionType": "multiple_choice",
                  "code": "val name: String? = null\nval length = name?.length ?: 0",
                  "difficulty": "medium",
                  "options": [
                    "null",
                    "Hata verir",
                    "0",
                    "1"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Elvis operatörü sayesinde null durumda 0 atanır.",
                  "tags": ["elvis-operator"]
                },
                {
                  "questionId": 140304,
                  "question": "!! operatörü ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Null kontrolü yapar",
                    "Null ise varsayılan değer atar",
                    "Null değilse çalışır, null ise crash olur",
                    "Her zaman güvenlidir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "!! operatörü null ise NullPointerException fırlatır.",
                  "tags": ["not-null-assertion"]
                },
                {
                  "questionId": 140305,
                  "question": "Null Safety'nin temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kod yazmayı zorlaştırmak",
                    "Daha fazla değişken oluşturmak",
                    "NullPointerException hatalarını önlemek",
                    "Performansı düşürmek"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Null Safety, NullPointerException hatalarını minimize eder.",
                  "tags": ["null-safety", "best-practice"]
                }
              ]
            },
            {
              "topicId": 1404,
              "title": "lateinit ve lazy",
              "summary": "lateinit ve lazy, Kotlin'de değişkenlerin geç (sonradan) başlatılmasını sağlayan iki farklı yaklaşımdır. lateinit mutable değişkenler için kullanılırken, lazy immutable değişkenler için kullanılır.",
              "content": "## lateinit ve lazy\n\nKotlin'de normalde bir değişken tanımlandığında hemen başlatılmalıdır. Ancak bazı durumlarda değişkenin değeri daha sonra atanır.\n\nBu durumlar için Kotlin iki çözüm sunar:\n\n- **lateinit**: var ile kullanılan, daha sonra başlatılacak değişkenler için\n- **lazy**: val ile kullanılan, ilk erişimde başlatılan değişkenler için\n\nAndroid geliştirmede özellikle ViewBinding, Activity ve Fragment yapılarında sıkça kullanılır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "lateinit Kullanımı",
                  "code": "lateinit var name: String\n\nfun initName() {\n    name = \"Ahmet\"\n}",
                  "explanation": "lateinit, var ile kullanılır ve sonradan değer atanır."
                },
                {
                  "title": "lateinit Kontrolü",
                  "code": "if (::name.isInitialized) {\n    println(name)\n}",
                  "explanation": "lateinit değişkenin başlatılıp başlatılmadığı kontrol edilebilir."
                },
                {
                  "title": "lazy Kullanımı",
                  "code": "val age: Int by lazy {\n    25\n}",
                  "explanation": "lazy, değişken ilk kez kullanıldığında çalışır."
                },
                {
                  "title": "lazy Çalışma Mantığı",
                  "code": "val message: String by lazy {\n    println(\"Initialized\")\n    \"Merhaba\"\n}",
                  "explanation": "lazy blok yalnızca ilk erişimde çalışır."
                },
                {
                  "title": "Android Örneği (ViewBinding)",
                  "code": "private lateinit var binding: ActivityMainBinding",
                  "explanation": "Android'de ViewBinding genellikle lateinit ile tanımlanır."
                }
              ],
              "keyPoints": [
                "lateinit sadece var ile kullanılır",
                "lazy sadece val ile kullanılır",
                "lateinit primitive tiplerde kullanılamaz",
                "lazy ilk erişimde çalışır",
                "Android'de ViewBinding için yaygın olarak kullanılır"
              ],
              "questions": [
                {
                  "questionId": 140401,
                  "question": "lateinit hangi değişken türü ile kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val",
                    "const",
                    "var",
                    "let"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lateinit sadece var ile kullanılabilir.",
                  "tags": ["lateinit"]
                },
                {
                  "questionId": 140402,
                  "question": "lazy hangi durumda çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Uygulama başlarken",
                    "Değişken tanımlandığında",
                    "İlk erişildiğinde",
                    "Fonksiyon çağrıldığında"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lazy blok ilk erişimde çalışır.",
                  "tags": ["lazy"]
                },
                {
                  "questionId": 140403,
                  "question": "Aşağıdakilerden hangisi lazy için doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "var ile kullanılır",
                    "Null olabilir",
                    "Sadece val ile kullanılır",
                    "Her zaman hemen çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "lazy sadece val ile kullanılır.",
                  "tags": ["lazy"]
                },
                {
                  "questionId": 140404,
                  "question": "lateinit ile ilgili hangisi yanlıştır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "var ile kullanılır",
                    "Primitive tiplerde kullanılabilir",
                    "Sonradan değer atanır",
                    "Null Safety ile ilişkilidir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "lateinit primitive tiplerde (Int, Boolean vb.) kullanılamaz.",
                  "tags": ["lateinit"]
                },
                {
                  "questionId": 140405,
                  "question": "Android'de ViewBinding genellikle nasıl tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "val binding = ActivityMainBinding()",
                    "lateinit var binding",
                    "val binding by lazy",
                    "var binding?"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewBinding genellikle lateinit var ile tanımlanır.",
                  "tags": ["android", "viewbinding"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 16001,
            "question": "Kotlin'de nullable bir değişken nasıl tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "String name",
              "String! name",
              "String? name",
              "nullable String name"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de nullable değişkenler '?' işareti ile tanımlanır.",
            "tags": ["null_safety", "nullable"]
          },
          {
            "questionId": 16002,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "fun printLength(text: String?) {\n    println(text?.length)\n}\n\nprintLength(null)",
            "difficulty": "easy",
            "options": [
              "0",
              "null",
              "Compile-time hatası",
              "Runtime hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe call (?.) kullanıldığı için null durumda hata oluşmaz ve null yazdırılır.",
            "tags": ["safe_call", "null_safety"]
          },
          {
            "questionId": 16003,
            "question": "Elvis operatörü (?:) ne amaçla kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Null kontrolü yapmak",
              "Exception fırlatmak",
              "Null durumunda varsayılan değer vermek",
              "Tip dönüşümü yapmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Elvis operatörü, ifade null ise alternatif bir değer döndürmek için kullanılır.",
            "tags": ["elvis_operator", "null_safety"]
          },
          {
            "questionId": 16004,
            "question": "Aşağıdaki kod çalıştığında ne olur?",
            "questionType": "multiple_choice",
            "code": "val name: String? = null\nprintln(name!!)",
            "difficulty": "medium",
            "options": [
              "null yazdırılır",
              "Boş string yazdırılır",
              "Compile-time hatası",
              "NullPointerException"
            ],
            "correctAnswerIndex": 3,
            "explanation": "!! operatörü null olmayan varsayımı yapar. Değer null olduğu için runtime'da NullPointerException fırlatılır.",
            "tags": ["not_null_assertion", "exception"]
          },
          {
            "questionId": 16005,
            "question": "Aşağıdakilerden hangisi lateinit için doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Primitive tiplerde kullanılabilir",
              "val ile kullanılabilir",
              "Nullable değişkenlerde kullanılır",
              "Sonradan initialize edilen non-null değişkenler için kullanılır"
            ],
            "correctAnswerIndex": 3,
            "explanation": "lateinit, non-null ve sonradan initialize edilecek var değişkenler için kullanılır.",
            "tags": ["lateinit"]
          },
          {
            "questionId": 16006,
            "question": "Aşağıdaki kod neden hatalıdır?",
            "questionType": "multiple_choice",
            "code": "lateinit var age: Int",
            "difficulty": "medium",
            "options": [
              "var yerine val kullanılması gerekir",
              "lateinit sadece String için geçerlidir",
              "Primitive tiplerde kullanılamaz",
              "Int nullable olmadığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "lateinit primitive tiplerde kullanılamaz, sadece reference type'lar için geçerlidir.",
            "tags": ["lateinit", "primitive"]
          },
          {
            "questionId": 16007,
            "question": "lazy delegate ile ilgili aşağıdakilerden hangisi doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her erişimde yeniden hesaplanır",
              "Sadece var ile kullanılabilir",
              "İlk erişimde initialize edilir",
              "Nullable değişkenler için zorunludur"
            ],
            "correctAnswerIndex": 2,
            "explanation": "lazy, değişkeni ilk erişimde initialize eder ve sonucu saklar.",
            "tags": ["lazy"]
          },
          {
            "questionId": 16008,
            "question": "Aşağıdaki kodun çıktısı nedir?",
            "questionType": "multiple_choice",
            "code": "val number: Int? = null\nval result = number ?: 10\nprintln(result)",
            "difficulty": "easy",
            "options": [
              "null",
              "0",
              "10",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 2,
            "explanation": "number null olduğu için Elvis operatörü 10 değerini döndürür.",
            "tags": ["elvis_operator"]
          },
          {
            "questionId": 16009,
            "question": "Fonksiyon parametreleri nullable olabilir mi?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Hayır",
              "Sadece varsayılan parametrelerde",
              "Evet, '?' kullanılarak",
              "Sadece lateinit ile"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fonksiyon parametreleri nullable olabilir ve '?' ile belirtilir.",
            "tags": ["function", "nullable"]
          },
          {
            "questionId": 16010,
            "question": "lateinit ve lazy arasındaki temel fark nedir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "lateinit thread-safe'dir, lazy değildir",
              "lateinit var ile, lazy val ile kullanılır",
              "lazy nullable değişkenler içindir",
              "lateinit ilk erişimde initialize olur"
            ],
            "correctAnswerIndex": 1,
            "explanation": "lateinit yalnızca var ile kullanılır, lazy ise val ile ve ilk erişimde initialize edilir.",
            "tags": ["lateinit", "lazy", "difference"]
          }
        ]
        },
        {
          "sectionId": 106,
          "sectionTitle": "Nesne Yönelimli Programlama",
          "sectionDescription": "",
          "order": 6,
          "topics": [
            {
              "topicId": 1501,
              "title": "Sınıflara Giriş (Classlar)",
              "summary": "Sınıflar (class), nesne tabanlı programlamanın temel yapı taşlarıdır. Kotlin'de sınıflar; özellikleri (property) ve davranışları (fonksiyon) bir arada tutarak gerçek hayattaki nesneleri temsil eder.",
              "content": "## Sınıflara Giriş (Classlar)\n\nNesne tabanlı programlamada (OOP), sınıflar bir nesnenin taslağını (şablonunu) temsil eder. Bir sınıftan birden fazla nesne (object) oluşturulabilir.\n\nKotlin'de sınıflar `class` anahtar kelimesi ile tanımlanır. Sınıflar; değişkenler (property) ve fonksiyonlar (method) içerebilir.\n\nAndroid geliştirmede Activity, Fragment, ViewModel gibi tüm yapılar birer sınıftır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Sınıf Tanımı",
                  "code": "class Person {\n    var name: String = \"\"\n    var age: Int = 0\n}",
                  "explanation": "Person sınıfı iki property içerir."
                },
                {
                  "title": "Nesne Oluşturma",
                  "code": "val person = Person()\nperson.name = \"Ahmet\"\nperson.age = 25",
                  "explanation": "Sınıftan bir nesne (object) oluşturulur."
                },
                {
                  "title": "Sınıf İçinde Fonksiyon",
                  "code": "class Car {\n    var brand: String = \"\"\n\n    fun drive() {\n        println(\"Araba sürülüyor\")\n    }\n}",
                  "explanation": "Sınıf içinde fonksiyon tanımlanabilir."
                },
                {
                  "title": "Fonksiyon Çağırma",
                  "code": "val car = Car()\ncar.drive()",
                  "explanation": "Sınıf fonksiyonları nesne üzerinden çağrılır."
                },
                {
                  "title": "Birden Fazla Nesne",
                  "code": "val p1 = Person()\nval p2 = Person()",
                  "explanation": "Aynı sınıftan birden fazla nesne oluşturulabilir."
                }
              ],
              "keyPoints": [
                "Sınıflar OOP'nin temel yapı taşıdır",
                "class anahtar kelimesi ile tanımlanır",
                "Sınıflardan nesneler (object) oluşturulur",
                "Sınıflar property ve fonksiyon içerir",
                "Android'deki her yapı aslında bir sınıftır"
              ],
              "questions": [
                {
                  "questionId": 150101,
                  "question": "Kotlin'de sınıf tanımlamak için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "object",
                    "class",
                    "struct",
                    "type"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de sınıflar class anahtar kelimesi ile tanımlanır.",
                  "tags": ["class", "oop"]
                },
                {
                  "questionId": 150102,
                  "question": "Bir sınıftan oluşturulan örneğe ne ad verilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Method",
                    "Property",
                    "Object",
                    "Package"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sınıftan oluşturulan her örnek bir object'tir.",
                  "tags": ["object", "oop"]
                },
                {
                  "questionId": 150103,
                  "question": "Aşağıdakilerden hangisi sınıf içinde bulunabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece değişken",
                    "Sadece fonksiyon",
                    "Değişken ve fonksiyon",
                    "Sadece constructor"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sınıflar hem property hem fonksiyon içerebilir.",
                  "tags": ["class"]
                },
                {
                  "questionId": 150104,
                  "question": "Aşağıdaki ifadelerden hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Bir sınıftan sadece bir nesne oluşturulur",
                    "Sınıflar sadece veri tutar",
                    "Bir sınıftan birden fazla nesne oluşturulabilir",
                    "Sınıflar fonksiyon içeremez"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Aynı sınıftan birden fazla nesne oluşturulabilir.",
                  "tags": ["oop"]
                },
                {
                  "questionId": 150105,
                  "question": "Android'de Activity ve Fragment ne tür yapılardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fonksiyon",
                    "Değişken",
                    "Sınıf",
                    "Paket"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Activity ve Fragment, Kotlin'de sınıf olarak tanımlanır.",
                  "tags": ["android", "class"]
                }
              ]
            },
            {
              "topicId": 1502,
              "title": "Constructor",
              "summary": "Constructor, bir sınıftan nesne oluşturulurken çalışan özel bir yapıdır. Kotlin'de constructor'lar sayesinde sınıfın başlangıç değerleri belirlenir ve nesne oluşturma süreci kontrol altına alınır.",
              "content": "## Constructor (Yapıcı Metot)\n\nConstructor, bir sınıftan nesne oluşturulduğu anda otomatik olarak çalışan özel bir fonksiyondur. Kotlin'de constructor kullanımı oldukça basittir ve genellikle sınıf başlığında tanımlanır.\n\nKotlin'de iki tür constructor vardır:\n- Primary Constructor (Birincil)\n- Secondary Constructor (İkincil)\n\nPrimary constructor sınıf başlığında tanımlanır ve en çok kullanılan yöntemdir. Secondary constructor ise ek senaryolar için kullanılır.\n\nAndroid geliştirmede model sınıfları, ViewModel'ler ve adapter yapıları constructor mantığına dayanır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Primary Constructor",
                  "code": "class User(val name: String, val age: Int)",
                  "explanation": "Primary constructor sınıf başlığında tanımlanır."
                },
                {
                  "title": "Nesne Oluşturma",
                  "code": "val user = User(\"Ahmet\", 25)",
                  "explanation": "Constructor parametreleri nesne oluştururken gönderilir."
                },
                {
                  "title": "Init Bloğu",
                  "code": "class Product(val price: Int) {\n    init {\n        println(\"Ürün fiyatı: $price\")\n    }\n}",
                  "explanation": "init bloğu constructor çalıştığında otomatik olarak tetiklenir."
                },
                {
                  "title": "Secondary Constructor",
                  "code": "class Car {\n    var brand: String\n\n    constructor(brand: String) {\n        this.brand = brand\n    }\n}",
                  "explanation": "Secondary constructor, class içinde constructor anahtar kelimesi ile tanımlanır."
                },
                {
                  "title": "Birden Fazla Constructor",
                  "code": "class Person(val name: String) {\n    var age: Int = 0\n\n    constructor(name: String, age: Int) : this(name) {\n        this.age = age\n    }\n}",
                  "explanation": "Secondary constructor, primary constructor'ı çağırmak zorundadır."
                }
              ],
              "keyPoints": [
                "Constructor nesne oluşturulurken çalışır",
                "Primary constructor en çok kullanılan yöntemdir",
                "init bloğu constructor ile birlikte çalışır",
                "Secondary constructor ek senaryolar için kullanılır",
                "Android model sınıfları constructor yapısını yoğun kullanır"
              ],
              "questions": [
                {
                  "questionId": 150201,
                  "question": "Constructor ne zaman çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sınıf tanımlandığında",
                    "Fonksiyon çağrıldığında",
                    "Nesne oluşturulduğunda",
                    "Uygulama kapandığında"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Constructor, sınıftan nesne oluşturulduğu anda çalışır.",
                  "tags": ["constructor", "oop"]
                },
                {
                  "questionId": 150202,
                  "question": "Primary constructor nerede tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fonksiyon içinde",
                    "Sınıf başlığında",
                    "init bloğunda",
                    "Companion object içinde"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Primary constructor sınıf başlığında tanımlanır.",
                  "tags": ["constructor"]
                },
                {
                  "questionId": 150203,
                  "question": "init bloğu ne zaman çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Uygulama açıldığında",
                    "Fonksiyon çağrıldığında",
                    "Constructor çalıştığında",
                    "Sınıf silindiğinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "init bloğu constructor ile birlikte otomatik olarak çalışır.",
                  "tags": ["init", "constructor"]
                },
                {
                  "questionId": 150204,
                  "question": "Secondary constructor hangi anahtar kelime ile tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "init",
                    "class",
                    "new",
                    "constructor"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Secondary constructor, constructor anahtar kelimesi ile tanımlanır.",
                  "tags": ["constructor"]
                },
                {
                  "questionId": 150205,
                  "question": "Secondary constructor için aşağıdakilerden hangisi zorunludur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "init bloğu çağırmak",
                    "Primary constructor'ı çağırmak",
                    "open sınıf olmak",
                    "abstract sınıf olmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Secondary constructor, primary constructor'ı çağırmak zorundadır.",
                  "tags": ["oop", "constructor"]
                }
              ]
            },
            {
              "topicId": 1503,
              "title": "Encapsulation",
              "summary": "Encapsulation (kapsülleme), nesneye ait verilerin doğrudan erişime kapatılması ve kontrollü bir şekilde dışarıya açılması prensibidir. Kotlin'de bu işlem access modifier'lar ve getter/setter yapıları ile sağlanır.",
              "content": "## Encapsulation (Kapsülleme)\n\nEncapsulation, nesne yönelimli programlamanın (OOP) temel prensiplerinden biridir. Amaç, bir sınıfın iç detaylarını gizleyerek dış dünyaya yalnızca gerekli olan kısmı açmaktır.\n\nKotlin'de encapsulation genellikle **private**, **public**, **protected** gibi erişim belirleyiciler ve **getter/setter** yapıları ile uygulanır.\n\nBu yaklaşım sayesinde:\n- Kod güvenliği artar\n- Hatalı kullanımlar engellenir\n- Sınıflar daha sürdürülebilir hale gelir\n\nAndroid geliştirmede ViewModel, Repository ve Model sınıflarında encapsulation yoğun şekilde kullanılır.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Private Property Kullanımı",
                  "code": "class User {\n    private var password: String = \"1234\"\n\n    fun checkPassword(input: String): Boolean {\n        return input == password\n    }\n}",
                  "explanation": "password değişkeni private olduğu için dışarıdan doğrudan erişilemez."
                },
                {
                  "title": "Public Getter - Private Setter",
                  "code": "class Account {\n    var balance: Int = 0\n        private set\n}",
                  "explanation": "balance değeri dışarıdan okunabilir ama değiştirilemez."
                },
                {
                  "title": "Custom Getter ve Setter",
                  "code": "class Product {\n    var price: Int = 0\n        get() = field\n        set(value) {\n            if (value >= 0) {\n                field = value\n            }\n        }\n}",
                  "explanation": "Setter içinde kontrol yapılarak hatalı değer atamaları engellenir."
                },
                {
                  "title": "Encapsulation ile Veri Koruma",
                  "code": "class BankAccount {\n    private var balance: Int = 0\n\n    fun deposit(amount: Int) {\n        if (amount > 0) balance += amount\n    }\n\n    fun getBalance(): Int = balance\n}",
                  "explanation": "balance sadece sınıf içinden değiştirilebilir, dışarıya kontrollü açılır."
                }
              ],
              "keyPoints": [
                "Encapsulation, veriyi gizleyip kontrollü açma prensibidir",
                "private erişim belirleyicisi sık kullanılır",
                "Getter ve setter ile kontrollü erişim sağlanır",
                "Hatalı veri girişleri engellenir",
                "Kodun güvenliği ve sürdürülebilirliği artar"
              ],
              "questions": [
                {
                  "questionId": 150301,
                  "question": "Encapsulation'ın temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kodu uzatmak",
                    "Veriyi gizlemek ve kontrollü erişim sağlamak",
                    "Daha fazla sınıf oluşturmak",
                    "Sadece performansı artırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Encapsulation, veriyi gizleyip kontrollü erişim sağlamak için kullanılır.",
                  "tags": ["encapsulation", "oop"]
                },
                {
                  "questionId": 150302,
                  "question": "Bir değişkenin dışarıdan erişimini tamamen kapatmak için hangi access modifier kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "public",
                    "protected",
                    "internal",
                    "private"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "private ile tanımlanan değişkenlere sadece sınıf içinden erişilebilir.",
                  "tags": ["access-modifiers"]
                },
                {
                  "questionId": 150303,
                  "question": "Aşağıdaki yapılardan hangisi encapsulation örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Tüm değişkenleri public yapmak",
                    "private property + public method kullanmak",
                    "Her sınıfı abstract yapmak",
                    "Sadece data class kullanmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Veriyi private yapıp kontrollü metotlarla erişmek encapsulation'dır.",
                  "tags": ["encapsulation"]
                },
                {
                  "questionId": 150304,
                  "question": "Aşağıdaki kodda balance neden private tanımlanmıştır?",
                  "questionType": "multiple_choice",
                  "code": "class Account {\n    private var balance = 0\n\n    fun deposit(amount: Int) {\n        balance += amount\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "Performans için",
                    "Dışarıdan doğrudan değiştirilmesini engellemek için",
                    "Derleme süresini kısaltmak için",
                    "Zorunlu olduğu için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Encapsulation sayesinde balance sadece kontrollü şekilde değiştirilebilir.",
                  "tags": ["encapsulation", "security"]
                },
                {
                  "questionId": 150305,
                  "question": "Getter ve setter'ların temel görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sınıf oluşturmak",
                    "Veriyi silmek",
                    "Değişkenlere kontrollü erişim sağlamak",
                    "Inheritance sağlamak"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Getter ve setter, değişkenlere kontrollü erişim sağlar.",
                  "tags": ["getter", "setter"]
                }
              ]
            },
            {
              "topicId": 1504,
              "title": "Inheritance",
              "summary": "Inheritance (kalıtım), bir sınıfın başka bir sınıfın özelliklerini ve davranışlarını miras almasını sağlar. Kotlin'de kalıtım, kod tekrarını azaltmak ve sınıflar arasında hiyerarşik bir yapı kurmak için kullanılır.",
              "content": "## Inheritance (Kalıtım)\n\nInheritance, nesne yönelimli programlamanın temel prensiplerinden biridir. Bir sınıfın başka bir sınıftan türemesini sağlar.\n\nKotlin'de bir sınıf varsayılan olarak **final**'dır. Kalıtım yapılabilmesi için **open** anahtar kelimesi kullanılır.\n\nAlt sınıflar (**child / subclass**), üst sınıfın (**parent / superclass**) public ve protected üyelerine erişebilir.\n\nAndroid geliştirmede Activity, Fragment, ViewModel gibi yapılar kalıtımın en yaygın kullanıldığı örneklerdir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Basit Kalıtım Örneği",
                  "code": "open class Animal {\n    fun makeSound() {\n        println(\"Ses çıkarıyor\")\n    }\n}\n\nclass Dog : Animal() {\n    fun bark() {\n        println(\"Hav hav\")\n    }\n}",
                  "explanation": "Dog sınıfı, Animal sınıfından kalıtım alır ve onun fonksiyonlarını kullanabilir."
                },
                {
                  "title": "Constructor ile Kalıtım",
                  "code": "open class Vehicle(val brand: String)\n\nclass Car(brand: String, val doors: Int) : Vehicle(brand)",
                  "explanation": "Alt sınıf, üst sınıfın constructor'ına parametre gönderebilir."
                },
                {
                  "title": "open ve override Kullanımı",
                  "code": "open class Shape {\n    open fun draw() {\n        println(\"Şekil çiziliyor\")\n    }\n}\n\nclass Circle : Shape() {\n    override fun draw() {\n        println(\"Daire çiziliyor\")\n    }\n}",
                  "explanation": "Bir fonksiyon override edilecekse üst sınıfta open olarak tanımlanmalıdır."
                },
                {
                  "title": "super Anahtar Kelimesi",
                  "code": "open class User {\n    open fun getRole() {\n        println(\"User\")\n    }\n}\n\nclass Admin : User() {\n    override fun getRole() {\n        super.getRole()\n        println(\"Admin\")\n    }\n}",
                  "explanation": "super ile üst sınıfın fonksiyonuna erişilebilir."
                }
              ],
              "keyPoints": [
                "Kotlin'de sınıflar varsayılan olarak final'dır",
                "Kalıtım için open anahtar kelimesi gerekir",
                "Alt sınıf, üst sınıfın public ve protected üyelerine erişebilir",
                "override edilen fonksiyonlar open olmalıdır",
                "super anahtar kelimesi ile üst sınıfa erişilir"
              ],
              "questions": [
                {
                  "questionId": 150401,
                  "question": "Kotlin'de bir sınıfın kalıtım alabilmesi için hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "abstract",
                    "open",
                    "inherit",
                    "extends"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır. Kalıtım için open kullanılmalıdır.",
                  "tags": ["inheritance", "open"]
                },
                {
                  "questionId": 150402,
                  "question": "Aşağıdakilerden hangisi override edilebilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "final fonksiyon",
                    "private fonksiyon",
                    "open fonksiyon",
                    "local fonksiyon"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Sadece open olarak tanımlanan fonksiyonlar override edilebilir.",
                  "tags": ["override"]
                },
                {
                  "questionId": 150403,
                  "question": "super anahtar kelimesi ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Alt sınıfı çağırır",
                    "Üst sınıfın üyelerine erişir",
                    "Yeni nesne oluşturur",
                    "Interface implement eder"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "super, üst sınıfın fonksiyon ve property'lerine erişmek için kullanılır.",
                  "tags": ["super"]
                },
                {
                  "questionId": 150404,
                  "question": "Aşağıdaki kodda hata oluşmasının sebebi nedir?",
                  "questionType": "multiple_choice",
                  "code": "class A\n\nclass B : A()",
                  "difficulty": "medium",
                  "options": [
                    "Constructor eksik",
                    "A sınıfı open değil",
                    "B sınıfı final",
                    "override eksik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "A sınıfı open olmadığı için kalıtım alınamaz.",
                  "tags": ["inheritance", "error"]
                },
                {
                  "questionId": 150405,
                  "question": "Android'de aşağıdakilerden hangisi inheritance örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Activity : AppCompatActivity",
                    "Intent kullanımı",
                    "SharedPreferences",
                    "DataBinding"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Activity'ler genellikle AppCompatActivity'den kalıtım alır.",
                  "tags": ["android", "inheritance"]
                }
              ]
            },
            {
              "topicId": 1505,
              "title": "Polymorphism",
              "summary": "Polymorphism (çok biçimlilik), aynı arayüz veya üst sınıf referansı ile farklı nesnelerin farklı davranışlar sergilemesini sağlar. Kotlin'de polymorphism, inheritance ve override mekanizmaları ile uygulanır.",
              "content": "## Polymorphism (Çok Biçimlilik)\n\nPolymorphism, nesne yönelimli programlamanın temel prensiplerinden biridir. Aynı türden referanslar kullanılarak farklı nesnelerin kendi davranışlarını sergilemesini sağlar.\n\nKotlin'de polymorphism genellikle:\n- open ve override fonksiyonlar\n- Üst sınıf referansı ile alt sınıf nesnesi oluşturma\n- Interface ve abstract class yapıları\n\nüzerinden uygulanır.\n\nAndroid geliştirmede polymorphism; Adapter, ViewModel, Repository ve callback yapılarında sıkça kullanılır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Üst Sınıf Referansı ile Alt Sınıf Nesnesi",
                  "code": "open class Animal {\n    open fun makeSound() {\n        println(\"Ses çıkarıyor\")\n    }\n}\n\nclass Cat : Animal() {\n    override fun makeSound() {\n        println(\"Miyav\")\n    }\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Hav hav\")\n    }\n}",
                  "explanation": "Animal referansı, farklı alt sınıf nesneleri için farklı çıktılar üretir."
                },
                {
                  "title": "Polymorphism Kullanımı",
                  "code": "fun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nanimalSound(Cat())\nanimalSound(Dog())",
                  "explanation": "Fonksiyon, Animal türü alır ama gelen nesneye göre davranış değişir."
                },
                {
                  "title": "Liste Üzerinden Polymorphism",
                  "code": "val animals: List<Animal> = listOf(Cat(), Dog())\n\nfor (animal in animals) {\n    animal.makeSound()\n}",
                  "explanation": "Aynı liste içinde farklı alt sınıflar kendi davranışlarını sergiler."
                },
                {
                  "title": "Android'de Polymorphism Örneği",
                  "code": "open class BaseViewModel\n\nclass MainViewModel : BaseViewModel()\nclass DetailViewModel : BaseViewModel()",
                  "explanation": "ViewModel'lar genellikle ortak bir üst sınıftan türetilir."
                }
              ],
              "keyPoints": [
                "Polymorphism, tek referans ile farklı davranışlar üretir",
                "Inheritance polymorphism için temel şarttır",
                "override edilen fonksiyonlar runtime'da çağrılır",
                "Üst sınıf referansı alt sınıf nesnesini tutabilir",
                "Kod esnekliği ve genişletilebilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 150501,
                  "question": "Polymorphism neyi ifade eder?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Bir sınıfın tek görevi olmasını",
                    "Aynı referans ile farklı davranışlar sergilenmesini",
                    "Sınıfların birbirini çağırmasını",
                    "Sadece interface kullanımını"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism, aynı referans ile farklı nesnelerin farklı davranış göstermesidir.",
                  "tags": ["polymorphism", "oop"]
                },
                {
                  "questionId": 150502,
                  "question": "Aşağıdakilerden hangisi polymorphism için gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Data class",
                    "Inheritance",
                    "Singleton",
                    "Companion object"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism genellikle inheritance ve override ile sağlanır.",
                  "tags": ["inheritance"]
                },
                {
                  "questionId": 150503,
                  "question": "Aşağıdaki kodun çıktısı ne olur?",
                  "questionType": "multiple_choice",
                  "code": "open class A {\n    open fun print() {\n        println(\"A\")\n    }\n}\n\nclass B : A() {\n    override fun print() {\n        println(\"B\")\n    }\n}\n\nval obj: A = B()\nobj.print()",
                  "difficulty": "medium",
                  "options": [
                    "A",
                    "B",
                    "Compile hatası",
                    "Runtime hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Runtime'da nesnenin gerçek tipi (B) çalışır.",
                  "tags": ["runtime", "override"]
                },
                {
                  "questionId": 150504,
                  "question": "Override edilen fonksiyon ne zaman belirlenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Compile time",
                    "Runtime",
                    "Build time",
                    "Install time"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Polymorphism runtime binding kullanır.",
                  "tags": ["runtime"]
                },
                {
                  "questionId": 150505,
                  "question": "Android'de Adapter yapılarında polymorphism neden kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI tasarlamak için",
                    "Farklı item tiplerini yönetmek için",
                    "Performansı düşürmek için",
                    "Veritabanı bağlantısı için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Adapter'larda farklı view type'lar polymorphism ile yönetilir.",
                  "tags": ["android", "adapter"]
                }
              ]
            },
            {
              "topicId": 1506,
              "title": "Abstraction",
              "summary": "Abstraction (soyutlama), bir nesnenin sadece gerekli özelliklerini dışarıya sunup detayları gizleme prensibidir. Kotlin'de abstraction, abstract class ve interface yapıları ile uygulanır.",
              "content": "## Abstraction (Soyutlama)\n\nAbstraction, nesne yönelimli programlamanın en önemli prensiplerinden biridir. Amaç, **ne yapıldığını** göstermek, **nasıl yapıldığını** gizlemektir.\n\nKotlin'de abstraction iki temel yapı ile sağlanır:\n\n- **Abstract Class**: Gövdeli ve gövdesiz (abstract) fonksiyonlar içerebilir, state tutabilir.\n- **Interface**: Fonksiyon imzaları tanımlar, çoklu implementasyona izin verir.\n\nAndroid geliştirmede abstraction; Repository, DataSource, Callback, Listener ve Service yapılarında yoğun şekilde kullanılır.",
              "difficulty": "medium",
              "order": 6,
              "codeExamples": [
                {
                  "title": "Abstract Class Örneği",
                  "code": "abstract class Vehicle {\n    abstract fun move()\n\n    fun stop() {\n        println(\"Araç durdu\")\n    }\n}\n\nclass Car : Vehicle() {\n    override fun move() {\n        println(\"Araba hareket ediyor\")\n    }\n}",
                  "explanation": "Abstract class hem gövdeli hem gövdesiz fonksiyonlar içerebilir."
                },
                {
                  "title": "Interface Örneği",
                  "code": "interface Flyable {\n    fun fly()\n}\n\nclass Bird : Flyable {\n    override fun fly() {\n        println(\"Kuş uçuyor\")\n    }\n}",
                  "explanation": "Interface, sınıflara davranış kazandırmak için kullanılır."
                },
                {
                  "title": "Abstract Property Kullanımı",
                  "code": "abstract class Employee {\n    abstract val salary: Int\n}\n\nclass Developer : Employee() {\n    override val salary: Int = 30000\n}",
                  "explanation": "Abstract class'lar abstract property tanımlayabilir."
                },
                {
                  "title": "Android'de Abstraction Örneği",
                  "code": "interface UserRepository {\n    fun getUsers(): List<String>\n}\n\nclass UserRepositoryImpl : UserRepository {\n    override fun getUsers(): List<String> {\n        return listOf(\"Ahmet\", \"Mehmet\")\n    }\n}",
                  "explanation": "Repository pattern abstraction kullanılarak uygulanır."
                }
              ],
              "keyPoints": [
                "Abstraction, detayları gizleyip gerekli kısmı sunar",
                "Abstract class hem state hem fonksiyon içerebilir",
                "Interface çoklu implementasyona izin verir",
                "Abstract class'tan nesne oluşturulamaz",
                "Android mimarilerinde abstraction temel yapı taşıdır"
              ],
              "questions": [
                {
                  "questionId": 150601,
                  "question": "Abstraction'ın temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kodu uzatmak",
                    "Detayları gizleyip gerekli yapıyı sunmak",
                    "Daha fazla sınıf oluşturmak",
                    "Performansı artırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Abstraction, ne yapıldığını gösterip nasıl yapıldığını gizler.",
                  "tags": ["abstraction", "oop"]
                },
                {
                  "questionId": 150602,
                  "question": "Abstract class ile ilgili hangisi doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Nesnesi oluşturulabilir",
                    "Sadece abstract fonksiyon içerir",
                    "Hem gövdeli hem gövdesiz fonksiyon içerebilir",
                    "Çoklu kalıtımı destekler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Abstract class'lar hem normal hem abstract fonksiyonlar içerebilir.",
                  "tags": ["abstract-class"]
                },
                {
                  "questionId": 150603,
                  "question": "Interface'lerin en önemli avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "State tutabilmeleri",
                    "Constructor içermeleri",
                    "Çoklu implementasyona izin vermeleri",
                    "Sadece Android'de çalışmaları"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Kotlin interface'leri çoklu implementasyona izin verir.",
                  "tags": ["interface"]
                },
                {
                  "questionId": 150604,
                  "question": "Aşağıdakilerden hangisi abstraction örneğidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Concrete class kullanımı",
                    "private değişken tanımlama",
                    "Repository interface kullanımı",
                    "Data class oluşturma"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Repository interface, abstraction'ın en yaygın kullanım alanlarından biridir.",
                  "tags": ["android", "architecture"]
                },
                {
                  "questionId": 150605,
                  "question": "Android mimarilerinde abstraction neden önemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI tasarımı için",
                    "Test edilebilirliği artırmak için",
                    "APK boyutunu küçültmek için",
                    "XML yazmamak için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Abstraction sayesinde kod daha test edilebilir ve sürdürülebilir olur.",
                  "tags": ["mvvm", "clean-architecture"]
                }
              ]
            },
            {
              "topicId": 1507,
              "title": "Visibility Modifiers",
              "summary": "Visibility Modifiers (erişim belirleyiciler), sınıfların, fonksiyonların ve değişkenlerin nerelerden erişilebilir olduğunu belirler. Kotlin'de public, private, protected ve internal olmak üzere dört temel erişim belirleyici bulunur.",
              "content": "## Visibility Modifiers (Erişim Belirleyiciler)\n\nVisibility modifiers, bir sınıfın veya üyenin (property, fonksiyon) hangi kapsamdan erişilebileceğini kontrol eder.\n\nKotlin'de dört temel erişim belirleyici vardır:\n\n- **public**: Her yerden erişilebilir (varsayılan)\n- **private**: Sadece tanımlandığı dosya veya sınıf içinden erişilebilir\n- **protected**: Sadece sınıf ve alt sınıflar tarafından erişilebilir\n- **internal**: Aynı module (modül) içerisinden erişilebilir\n\nDoğru visibility kullanımı, encapsulation ve abstraction prensiplerinin temelini oluşturur.",
              "difficulty": "medium",
              "order": 7,
              "codeExamples": [
                {
                  "title": "Public (Varsayılan) Kullanımı",
                  "code": "class User {\n    val name: String = \"Ahmet\"\n}",
                  "explanation": "public varsayılan olduğu için name her yerden erişilebilir."
                },
                {
                  "title": "Private Kullanımı",
                  "code": "class Account {\n    private var balance: Int = 0\n\n    fun getBalance(): Int {\n        return balance\n    }\n}",
                  "explanation": "balance sadece Account sınıfı içinden erişilebilir."
                },
                {
                  "title": "Protected Kullanımı",
                  "code": "open class Person {\n    protected val age: Int = 30\n}\n\nclass Employee : Person() {\n    fun printAge() {\n        println(age)\n    }\n}",
                  "explanation": "protected üyeler alt sınıflar tarafından erişilebilir."
                },
                {
                  "title": "Internal Kullanımı",
                  "code": "internal class Logger {\n    fun log(message: String) {\n        println(message)\n    }\n}",
                  "explanation": "internal tanımlanan sınıf sadece aynı module içinde erişilebilir."
                },
                {
                  "title": "Constructor Visibility",
                  "code": "class Singleton private constructor() {\n    companion object {\n        val instance = Singleton()\n    }\n}",
                  "explanation": "private constructor ile dışarıdan nesne oluşturulması engellenir."
                }
              ],
              "keyPoints": [
                "Kotlin'de varsayılan visibility public'tir",
                "private en dar erişim seviyesidir",
                "protected sadece inheritance ile çalışır",
                "internal module bazlı erişim sağlar",
                "Doğru visibility kod güvenliğini artırır"
              ],
              "questions": [
                {
                  "questionId": 150701,
                  "question": "Kotlin'de varsayılan visibility modifier hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "private",
                    "protected",
                    "internal",
                    "public"
                  ],
                  "correctAnswerIndex": 3,
                  "explanation": "Kotlin'de herhangi bir modifier belirtilmezse varsayılan olarak public kabul edilir.",
                  "tags": ["visibility", "public"]
                },
                {
                  "questionId": 150702,
                  "question": "Aynı module içinden erişim sağlayan visibility hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "private",
                    "protected",
                    "internal",
                    "public"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "internal modifier, sadece aynı module içinden erişime izin verir.",
                  "tags": ["internal"]
                },
                {
                  "questionId": 150703,
                  "question": "protected modifier hangi durumda anlam kazanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Top-level fonksiyonlarda",
                    "Inheritance (kalıtım) durumunda",
                    "Data class'larda",
                    "Singleton yapısında"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "protected sadece sınıf ve alt sınıflar için geçerlidir.",
                  "tags": ["protected", "inheritance"]
                },
                {
                  "questionId": 150704,
                  "question": "Aşağıdaki kodda hangi üyeye dışarıdan erişilemez?",
                  "questionType": "multiple_choice",
                  "code": "class Test {\n    private val a = 1\n    val b = 2\n}",
                  "difficulty": "easy",
                  "options": [
                    "a",
                    "b",
                    "İkisine de erişilebilir",
                    "Hiçbirine erişilemez"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "private tanımlanan a değişkenine sınıf dışından erişilemez.",
                  "tags": ["private"]
                },
                {
                  "questionId": 150705,
                  "question": "Android projelerinde internal genellikle ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI bileşenleri",
                    "Test edilebilirliği artırmak",
                    "Module içi sınıfları sınırlamak",
                    "Veritabanı tabloları"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "internal, module sınırları içinde erişimi kısıtlamak için kullanılır.",
                  "tags": ["android", "module"]
                }
              ]
            }

          ],
          "sectionMixedQuestions": [
          {
            "questionId": 17001,
            "question": "Kotlin'de bir sınıf (class) nasıl tanımlanır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "class MyClass {}",
              "MyClass class {}",
              "define class MyClass {}",
              "object MyClass {}"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de sınıflar 'class' anahtar kelimesi ile tanımlanır.",
            "tags": ["class", "oop"]
          },
          {
            "questionId": 17002,
            "question": "Primary constructor aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "class User { constructor(name: String) {} }",
              "class User(name: String)",
              "fun constructor() {}",
              "init(name: String)"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Primary constructor, class tanımının yanında parantez içinde tanımlanır.",
            "tags": ["constructor", "primary_constructor"]
          },
          {
            "questionId": 17003,
            "question": "Encapsulation'ın temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Kodun daha hızlı çalışmasını sağlamak",
              "Sınıflar arası kalıtım sağlamak",
              "Veriyi dış müdahalelere karşı korumak",
              "Aynı isimli fonksiyonları kullanmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Encapsulation, sınıf içindeki veriyi private yaparak kontrollü erişim sağlamayı amaçlar.",
            "tags": ["encapsulation", "oop"]
          },
          {
            "questionId": 17004,
            "question": "Aşağıdaki visibility modifier'lardan hangisi sadece aynı sınıf içinde erişime izin verir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "public",
              "internal",
              "protected",
              "private"
            ],
            "correctAnswerIndex": 3,
            "explanation": "private, yalnızca tanımlandığı sınıf içinde erişilebilir.",
            "tags": ["visibility", "private"]
          },
          {
            "questionId": 17005,
            "question": "Kotlin'de inheritance (kalıtım) için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "extends",
              "inherits",
              ":",
              "implements"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de bir sınıf başka bir sınıftan ':' operatörü ile türetilir.",
            "tags": ["inheritance"]
          },
          {
            "questionId": 17006,
            "question": "Bir sınıfın miras alınabilmesi için hangi anahtar kelime ile işaretlenmesi gerekir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "abstract",
              "open",
              "public",
              "override"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır. Miras alınabilmesi için open olarak tanımlanmalıdır.",
            "tags": ["open", "inheritance"]
          },
          {
            "questionId": 17007,
            "question": "Polymorphism aşağıdakilerden hangisini ifade eder?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Bir sınıfın birden fazla constructor'a sahip olması",
              "Aynı fonksiyonun farklı davranışlar sergilemesi",
              "Sınıfların gizlenmesi",
              "Verilerin kapsüllenmesi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Polymorphism, aynı isimli fonksiyonların farklı sınıflarda farklı davranışlar göstermesidir.",
            "tags": ["polymorphism"]
          },
          {
            "questionId": 17008,
            "question": "Aşağıdakilerden hangisi abstraction için doğrudur?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Abstract class instance alınabilir",
              "Abstract fonksiyonların gövdesi olmak zorundadır",
              "Detayları gizleyip sadece gerekli yapıyı sunar",
              "Sadece interface ile yapılır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Abstraction, karmaşık detayları gizleyerek kullanıcıya sade bir yapı sunar.",
            "tags": ["abstraction"]
          },
          {
            "questionId": 17009,
            "question": "Aşağıdaki kodda hangi OOP prensibi uygulanmaktadır?",
            "questionType": "multiple_choice",
            "code": "open class Animal {\n    open fun sound() {}\n}\n\nclass Dog : Animal() {\n    override fun sound() {}\n}",
            "difficulty": "hard",
            "options": [
              "Encapsulation",
              "Inheritance",
              "Polymorphism",
              "Abstraction"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Aynı fonksiyonun (sound) farklı sınıflarda farklı şekilde override edilmesi polymorphism örneğidir.",
            "tags": ["polymorphism", "override"]
          },
          {
            "questionId": 17010,
            "question": "protected visibility modifier ne anlama gelir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Her yerden erişilebilir",
              "Sadece aynı dosya içinden erişilebilir",
              "Sadece aynı sınıf ve alt sınıflardan erişilebilir",
              "Sadece aynı modülden erişilebilir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "protected, tanımlandığı sınıf ve o sınıftan türeyen alt sınıflar tarafından erişilebilir.",
            "tags": ["protected", "visibility"]
          }
        ]
        },
        {
          "sectionId": 107,
          "sectionTitle": "Fonksiyonel Programlama",
          "sectionDescription": "",
          "order": 7,
          "topics": [
            {
              "topicId": 1601,
              "title": "Lambda",
              "summary": "Lambda, isimsiz (anonim) fonksiyonlardır ve fonksiyonel programlamanın temel yapı taşlarından biridir. Kotlin'de lambda ifadeleri, fonksiyonları değişken gibi kullanmayı ve daha okunabilir, esnek kod yazmayı sağlar.",
              "content": "## Lambda\n\nLambda ifadeleri, kısa ve tek kullanımlık fonksiyonlar tanımlamak için kullanılır. Kotlin'de fonksiyonlar birer first-class citizen'dır, yani değişkenlere atanabilir, parametre olarak gönderilebilir ve fonksiyondan döndürülebilir.\n\nLambda yapısı:\n\n```\n{ parametreler -> işlem }\n```\n\nLambda'lar genellikle collection işlemleri, callback yapıları ve asenkron işlemlerde kullanılır.\n\nAndroid geliştirmede onClick listener'lar, adapter callback'leri ve higher-order function'lar lambda kullanımının en yaygın örnekleridir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Lambda Tanımı",
                  "code": "val sum = { a: Int, b: Int -> a + b }\n\nprintln(sum(3, 5))",
                  "explanation": "Lambda bir değişkene atanabilir ve fonksiyon gibi çağrılabilir."
                },
                {
                  "title": "Tek Parametreli Lambda (it)",
                  "code": "val printNumber: (Int) -> Unit = { println(it) }\n\nprintNumber(10)",
                  "explanation": "Tek parametre varsa it anahtar kelimesi kullanılabilir."
                },
                {
                  "title": "Fonksiyon Parametresi Olarak Lambda",
                  "code": "fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {\n    return operation(a, b)\n}\n\nval result = calculate(4, 2) { x, y -> x * y }",
                  "explanation": "Fonksiyonlar parametre olarak lambda alabilir."
                },
                {
                  "title": "Android'de Lambda Kullanımı",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "explanation": "Listener yapıları lambda ile sadeleşir."
                }
              ],
              "keyPoints": [
                "Lambda ifadeleri isimsiz fonksiyonlardır",
                "Fonksiyonlar Kotlin'de first-class citizen'dır",
                "Lambda'lar değişkene atanabilir",
                "Fonksiyonlara parametre olarak gönderilebilir",
                "Android callback'lerinde yaygın kullanılır"
              ],
              "questions": [
                {
                  "questionId": 160101,
                  "question": "Lambda ifadesi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "İsimli fonksiyon",
                    "Anonim (isimsiz) fonksiyon",
                    "Sadece Android'e özel yapı",
                    "Class türü"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda, isimsiz fonksiyonlardır.",
                  "tags": ["lambda", "functional"]
                },
                {
                  "questionId": 160102,
                  "question": "Tek parametreli lambda'da hangi anahtar kelime kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "this",
                    "param",
                    "it",
                    "self"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Tek parametreli lambda'da it kullanılır.",
                  "tags": ["lambda"]
                },
                {
                  "questionId": 160103,
                  "question": "Aşağıdakilerden hangisi doğru lambda tanımıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "{ a, b => a + b }",
                    "{ a: Int, b: Int -> a + b }",
                    "(a, b) -> a + b",
                    "lambda(a, b)"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de lambda tanımı bu şekildedir.",
                  "tags": ["syntax"]
                },
                {
                  "questionId": 160104,
                  "question": "Lambda'lar genellikle hangi yapılarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "XML layout",
                    "Callback ve collection işlemleri",
                    "Manifest dosyası",
                    "Gradle script"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda'lar callback ve collection işlemlerinde yaygındır.",
                  "tags": ["collections", "callback"]
                },
                {
                  "questionId": 160105,
                  "question": "Android'de lambda kullanımının avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha fazla kod yazmak",
                    "Okunabilirliği ve sadeliği artırmak",
                    "Sadece performans kazanmak",
                    "Java uyumluluğunu kaldırmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lambda, boilerplate kodu azaltır ve okunabilirliği artırır.",
                  "tags": ["android", "lambda"]
                }
              ]
            },
            {
              "topicId": 1602,
              "title": "Map ve Filter",
              "summary": "Map ve Filter, koleksiyonlar üzerinde veri dönüştürme ve filtreleme işlemleri yapmak için kullanılan fonksiyonel programlama araçlarıdır. Kotlin'de okunabilir ve temiz kod yazmayı sağlar.",
              "content": "## Map ve Filter\n\nMap fonksiyonu, bir koleksiyondaki her elemanı dönüştürerek yeni bir koleksiyon oluşturur.\n\nFilter fonksiyonu ise belirli bir koşulu sağlayan elemanları seçerek yeni bir koleksiyon döndürür.\n\nBu fonksiyonlar orijinal koleksiyonu değiştirmez, immutable yapıyı korur.\n\nAndroid geliştirmede listeleme, arama, veri dönüştürme ve UI'ya uygun veri hazırlama işlemlerinde sıkça kullanılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Map Kullanımı",
                  "code": "val numbers = listOf(1, 2, 3, 4)\n\nval doubled = numbers.map { it * 2 }\n\nprintln(doubled)",
                  "explanation": "Map, listedeki her elemanı dönüştürür."
                },
                {
                  "title": "Filter Kullanımı",
                  "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nval evenNumbers = numbers.filter { it % 2 == 0 }\n\nprintln(evenNumbers)",
                  "explanation": "Filter, koşulu sağlayan elemanları seçer."
                },
                {
                  "title": "Map + Filter Birlikte",
                  "code": "val numbers = listOf(1, 2, 3, 4, 5)\n\nval result = numbers.filter { it > 2 }.map { it * 10 }\n\nprintln(result)",
                  "explanation": "Önce filtreleme sonra dönüştürme yapılır."
                },
                {
                  "title": "Android Kullanım Senaryosu",
                  "code": "val users = listOf(\"Ali\", \"Ayşe\", \"Mehmet\")\n\nval uiList = users.map { it.uppercase() }\n\nprintln(uiList)",
                  "explanation": "UI'da gösterilecek veriler map ile dönüştürülür."
                }
              ],
              "keyPoints": [
                "Map koleksiyon elemanlarını dönüştürür",
                "Filter koşula uyan elemanları seçer",
                "Orijinal koleksiyon değişmez",
                "Fonksiyonel ve okunabilir kod sağlar",
                "Android projelerinde sık kullanılır"
              ],
              "questions": [
                {
                  "questionId": 160201,
                  "question": "Map fonksiyonunun temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Elemanları silmek",
                    "Elemanları dönüştürmek",
                    "Listeyi sıralamak",
                    "Listeyi ters çevirmek"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Map, her elemanı dönüştürerek yeni bir koleksiyon oluşturur.",
                  "tags": ["map"]
                },
                {
                  "questionId": 160202,
                  "question": "Filter fonksiyonu ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Elemanları değiştirir",
                    "Koşula uyan elemanları seçer",
                    "Listeyi kopyalar",
                    "Listeyi sıralar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Filter, verilen koşulu sağlayan elemanları döndürür.",
                  "tags": ["filter"]
                },
                {
                  "questionId": 160203,
                  "question": "Aşağıdaki kodun çıktısı nedir?\n\nnumbers.filter { it > 3 }.map { it * 2 }",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "[2, 4, 6]",
                    "[8, 10]",
                    "[4, 6, 8]",
                    "[6, 8, 10]"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Önce 3'ten büyükler seçilir, sonra 2 ile çarpılır.",
                  "tags": ["map", "filter"]
                },
                {
                  "questionId": 160204,
                  "question": "Map ve Filter kullanıldığında koleksiyon nasıl etkilenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Orijinal liste değişir",
                    "Orijinal liste silinir",
                    "Yeni bir liste oluşturulur",
                    "Sadece ilk eleman değişir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Map ve Filter yeni bir koleksiyon döndürür.",
                  "tags": ["collections"]
                },
                {
                  "questionId": 160205,
                  "question": "Map & Filter Android'de en çok nerede kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Manifest dosyasında",
                    "Gradle ayarlarında",
                    "UI için veri hazırlamada",
                    "XML layout içinde"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Veriyi UI'ya uygun hale getirmek için sıkça kullanılır.",
                  "tags": ["android", "functional"]
                }
              ]
            },
            {
              "topicId": 1603,
              "title": "Scope Fonksiyonları",
              "summary": "Scope fonksiyonları, bir nesne üzerinde geçici bir kapsam (scope) oluşturarak daha okunabilir ve düzenli kod yazmayı sağlar. Kotlin'de let, run, apply, also ve with olmak üzere beş adet scope fonksiyonu bulunur.",
              "content": "## Scope Fonksiyonları\n\nScope fonksiyonları bir nesne ile birlikte çalışırken tekrar tekrar nesne adını yazma ihtiyacını ortadan kaldırır.\n\nBu fonksiyonlar, nesneye erişim şekline (this / it) ve geri dönüş tipine göre birbirinden ayrılır.\n\nAndroid geliştirmede null kontrolü, view binding, nesne yapılandırma ve zincirleme işlemler için sıkça kullanılır.\n\n### Scope Fonksiyonları Özeti\n- let → it kullanır, sonuç döndürür\n- run → this kullanır, sonuç döndürür\n- apply → this kullanır, nesnenin kendisini döndürür\n- also → it kullanır, nesnenin kendisini döndürür\n- with → this kullanır, sonuç döndürür (extension değildir)",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "let Kullanımı",
                  "code": "val name: String? = \"Ahmet\"\n\nname?.let {\n    println(it.uppercase())\n}",
                  "explanation": "let genellikle null kontrolü için kullanılır."
                },
                {
                  "title": "run Kullanımı",
                  "code": "val user = \"Kotlin\"\n\nval length = user.run {\n    this.length\n}\n\nprintln(length)",
                  "explanation": "run, this ile erişim sağlar ve sonuç döndürür."
                },
                {
                  "title": "apply Kullanımı",
                  "code": "val list = mutableListOf<String>().apply {\n    add(\"A\")\n    add(\"B\")\n}",
                  "explanation": "apply nesneyi yapılandırmak için kullanılır."
                },
                {
                  "title": "also Kullanımı",
                  "code": "val numbers = mutableListOf(1, 2, 3)\n    .also { println(\"Liste oluşturuldu: $it\") }",
                  "explanation": "also yan işlemler (log, debug) için idealdir."
                },
                {
                  "title": "with Kullanımı",
                  "code": "val user = StringBuilder()\n\nwith(user) {\n    append(\"Hello \")\n    append(\"Kotlin\")\n}\n\nprintln(user.toString())",
                  "explanation": "with bir nesneyle blok halinde çalışmayı sağlar."
                }
              ],
              "keyPoints": [
                "Scope fonksiyonları kod okunabilirliğini artırır",
                "let ve also -> it kullanır",
                "run, apply, with -> this kullanır",
                "apply ve also nesnenin kendisini döndürür",
                "Android projelerinde ViewBinding ve null kontrolünde yaygındır"
              ],
              "questions": [
                {
                  "questionId": 160301,
                  "question": "Hangi scope fonksiyonu null kontrolü için en sık kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "apply",
                    "with",
                    "let",
                    "also"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "let genellikle nullable nesnelerle kullanılır.",
                  "tags": ["scope", "let"]
                },
                {
                  "questionId": 160302,
                  "question": "Hangi scope fonksiyonu nesnenin kendisini döndürür?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "run",
                    "apply",
                    "with",
                    "let"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "apply yapılandırma sonrası nesnenin kendisini döndürür.",
                  "tags": ["apply"]
                },
                {
                  "questionId": 160303,
                  "question": "this anahtar kelimesiyle çalışan scope fonksiyonları hangileridir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "let ve also",
                    "apply ve run",
                    "let ve run",
                    "also ve with"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "apply ve run this ile erişim sağlar.",
                  "tags": ["scope"]
                },
                {
                  "questionId": 160304,
                  "question": "Log veya debug amaçlı en uygun scope fonksiyonu hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "run",
                    "with",
                    "also",
                    "let"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "also yan işlemler için tasarlanmıştır.",
                  "tags": ["also"]
                },
                {
                  "questionId": 160305,
                  "question": "with fonksiyonunun diğerlerinden farkı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Extension fonksiyon olması",
                    "Nesnenin kendisini döndürmesi",
                    "Extension olmaması",
                    "Null kontrolü yapması"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "with extension değildir, nesne parametre olarak verilir.",
                  "tags": ["with"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 18001,
            "question": "Lambda expression nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "İsimsiz bir sınıf",
              "İsimsiz bir fonksiyon",
              "Bir interface türü",
              "Bir veri tipi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Lambda, isimsiz fonksiyonlardır ve genellikle kısa işlemler için kullanılır.",
            "tags": ["lambda", "functional"]
          },
          {
            "questionId": 18002,
            "question": "Aşağıdakilerden hangisi geçerli bir lambda tanımıdır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "{ x, y -> x + y }",
              "(x, y) => x + y",
              "lambda x y { x + y }",
              "fun(x, y) = x + y"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de lambda tanımı { parametreler -> işlem } şeklindedir.",
            "tags": ["lambda", "syntax"]
          },
          {
            "questionId": 18003,
            "question": "map fonksiyonunun temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Listeyi filtrelemek",
              "Liste elemanlarını dönüştürmek",
              "Listeyi sıralamak",
              "Liste elemanlarını silmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "map, koleksiyonun her elemanını dönüştürerek yeni bir liste oluşturur.",
            "tags": ["map", "collections"]
          },
          {
            "questionId": 18004,
            "question": "filter fonksiyonu ne yapar?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Elemanları dönüştürür",
              "Belirli koşula uyanları seçer",
              "Elemanları gruplar",
              "Listeyi ters çevirir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "filter, verilen koşulu sağlayan elemanlardan yeni bir koleksiyon oluşturur.",
            "tags": ["filter"]
          },
          {
            "questionId": 18005,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "val numbers = listOf(1, 2, 3, 4)\nval result = numbers.map { it * 2 }\nprintln(result)",
            "difficulty": "medium",
            "options": [
              "[1, 2, 3, 4]",
              "[2, 4, 6, 8]",
              "[1, 4, 9, 16]",
              "Compile-time hatası"
            ],
            "correctAnswerIndex": 1,
            "explanation": "map her elemanı 2 ile çarpar ve yeni bir liste döndürür.",
            "tags": ["map"]
          },
          {
            "questionId": 18006,
            "question": "Aşağıdaki scope fonksiyonlarından hangisi 'this' kullanır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "let",
              "also",
              "apply",
              "filter"
            ],
            "correctAnswerIndex": 2,
            "explanation": "apply ve run scope fonksiyonlarında context object 'this' ile temsil edilir.",
            "tags": ["scope_functions", "apply"]
          },
          {
            "questionId": 18007,
            "question": "let scope fonksiyonunun temel kullanım amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Nesneyi yapılandırmak",
              "Yan etkiler oluşturmak",
              "Null kontrolü ve dönüşüm",
              "Thread yönetimi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "let genellikle null kontrolü ve nesne üzerinde işlem yapmak için kullanılır.",
            "tags": ["let", "null_safety"]
          },
          {
            "questionId": 18008,
            "question": "Aşağıdaki kodda hangi scope fonksiyonu kullanılmıştır?",
            "questionType": "multiple_choice",
            "code": "val user = User().apply {\n    name = \"Ahmet\"\n    age = 25\n}",
            "difficulty": "medium",
            "options": [
              "let",
              "run",
              "also",
              "apply"
            ],
            "correctAnswerIndex": 3,
            "explanation": "apply, nesneyi yapılandırmak için kullanılır ve this referansını kullanır.",
            "tags": ["apply", "scope_functions"]
          },
          {
            "questionId": 18009,
            "question": "also scope fonksiyonunun ayırt edici özelliği nedir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "this kullanır",
              "Yeni bir nesne döndürür",
              "Yan etkiler (logging gibi) için kullanılır",
              "Null-safe değildir"
            ],
            "correctAnswerIndex": 2,
            "explanation": "also genellikle loglama gibi yan etkiler için kullanılır ve it referansını kullanır.",
            "tags": ["also"]
          },
          {
            "questionId": 18010,
            "question": "map ve filter birlikte kullanıldığında ne sağlar?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Koleksiyonu sıralar",
              "Koleksiyonu optimize eder",
              "Filtrelenmiş veriyi dönüştürür",
              "Sadece performans artışı sağlar"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Önce filter ile elemanlar seçilir, ardından map ile dönüştürülür. Bu, fonksiyonel programlamanın temel desenidir.",
            "tags": ["map", "filter", "functional"]
          }
        ]
        },
        {
          "sectionId": 1700,
          "sectionTitle": "Hata Yönetimi",
          "sectionDescription": "Uygulama çalışırken oluşabilecek hataların yakalanması, yönetilmesi ve debug edilmesi",
          "order": 7,
          "topics": [
            {
              "topicId": 1701,
              "title": "try-catch",
              "summary": "try-catch yapısı, çalışma zamanında (runtime) oluşabilecek hataları yakalayarak uygulamanın çökmesini engeller. Kotlin'de hataya neden olabilecek kodlar try bloğuna yazılır ve oluşan hata catch bloğunda ele alınır.",
              "content": "## try-catch\n\ntry-catch, özellikle kullanıcı girdileri, network işlemleri ve dosya okuma gibi riskli işlemlerde kullanılır.\n\nKotlin'de birden fazla catch bloğu tanımlanabilir ve finally bloğu isteğe bağlıdır.\n\ntry-catch bir expression olarak da kullanılabilir ve değer döndürebilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit try-catch Kullanımı",
                  "code": "try {\n    val number = \"10a\".toInt()\n} catch (e: NumberFormatException) {\n    println(\"Hatalı sayı formatı\")\n}",
                  "explanation": "String değeri Int'e çevrilirken hata oluşur ve catch bloğu çalışır."
                },
                {
                  "title": "try-catch Expression",
                  "code": "val result = try {\n    10 / 2\n} catch (e: Exception) {\n    0\n}",
                  "explanation": "try-catch bir değer döndürebilir."
                }
              ],
              "keyPoints": [
                "Runtime hatalarını yakalamak için kullanılır",
                "Birden fazla catch bloğu yazılabilir",
                "finally isteğe bağlıdır",
                "try-catch expression olarak kullanılabilir"
              ],
              "questions": [
                {
                  "questionId": 170101,
                  "question": "try-catch yapısının temel amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Compile-time hataları yakalamak",
                    "Runtime hataları yakalamak",
                    "Performansı artırmak",
                    "Değişken tanımlamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "try-catch runtime sırasında oluşan hataları yakalamak için kullanılır.",
                  "tags": ["try-catch"]
                }
              ]
            },
            {
              "topicId": 1702,
              "title": "Exception",
              "summary": "Exception, uygulama çalışırken meydana gelen beklenmeyen hataları temsil eden nesnelerdir. Kotlin'de tüm exception'lar Exception sınıfından türetilir.",
              "content": "## Exception\n\nException'lar programın normal akışını bozar.\n\nKotlin'de checked exception yoktur, bu da kodu daha sade hale getirir.\n\nGeliştirici isterse kendi custom exception sınıflarını da oluşturabilir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Exception Fırlatma",
                  "code": "fun divide(a: Int, b: Int): Int {\n    if (b == 0) {\n        throw IllegalArgumentException(\"Bölen 0 olamaz\")\n    }\n    return a / b\n}",
                  "explanation": "Hatalı durumlarda manuel olarak exception fırlatılabilir."
                }
              ],
              "keyPoints": [
                "Tüm exception'lar Exception sınıfından türetilir",
                "Kotlin'de checked exception yoktur",
                "throw ile manuel exception fırlatılabilir",
                "Custom exception tanımlanabilir"
              ],
              "questions": [
                {
                  "questionId": 170201,
                  "question": "Kotlin'de checked exception var mı?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet",
                    "Hayır",
                    "Sadece Android'de var",
                    "Sadece JVM'de var"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de checked exception yoktur.",
                  "tags": ["exception"]
                }
              ]
            },
            {
              "topicId": 1703,
              "title": "Debug Mantığı",
              "summary": "Debug mantığı, uygulamada oluşan hataların nedenini bulmak ve çözmek için kullanılan sistematik yaklaşımdır. Loglama, breakpoint ve stack trace analizi bu sürecin temel parçalarıdır.",
              "content": "## Debug Mantığı\n\nDebug sürecinde hatanın nerede ve neden oluştuğu analiz edilir.\n\nAndroid Studio debugger, Logcat ve stack trace bu süreçte en önemli araçlardır.\n\nHataları sadece çözmek değil, tekrar oluşmasını engellemek de hedeflenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Log ile Debug",
                  "code": "Log.d(\"DEBUG\", \"Butona tıklandı\")",
                  "explanation": "Log mesajları uygulamanın akışını takip etmek için kullanılır."
                }
              ],
              "keyPoints": [
                "Breakpoint ile kod adım adım çalıştırılabilir",
                "Stack trace hatanın kaynağını gösterir",
                "Loglama debug sürecini kolaylaştırır",
                "Hatanın kök nedeni bulunmalıdır"
              ],
              "questions": [
                {
                  "questionId": 170301,
                  "question": "Stack trace neyi gösterir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI hatalarını",
                    "Memory kullanımını",
                    "Hatanın oluştuğu çağrı zincirini",
                    "Network trafiğini"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Stack trace hatanın hangi method çağrılarında oluştuğunu gösterir.",
                  "tags": ["debug"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
          {
            "questionId": 19001,
            "question": "Kotlin'de hata yakalamak için hangi yapı kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "if-else",
              "try-catch",
              "when",
              "throw-catch"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Kotlin'de runtime hataları yakalamak için try-catch bloğu kullanılır.",
            "tags": ["try_catch", "exception"]
          },
          {
            "questionId": 19002,
            "question": "Aşağıdakilerden hangisi runtime exception örneğidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "Syntax error",
              "NullPointerException",
              "Import hatası",
              "Derleme uyarısı"
            ],
            "correctAnswerIndex": 1,
            "explanation": "NullPointerException, uygulama çalışırken oluşan bir runtime exception'dır.",
            "tags": ["runtime_exception"]
          },
          {
            "questionId": 19003,
            "question": "Aşağıdaki kodda hangi durumda exception oluşur?",
            "questionType": "multiple_choice",
            "code": "val number = 10\nprintln(number / 0)",
            "difficulty": "easy",
            "options": [
              "Compile-time",
              "ArithmeticException",
              "NullPointerException",
              "Hiçbir hata oluşmaz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Sıfıra bölme işlemi ArithmeticException fırlatır.",
            "tags": ["exception", "arithmetic"]
          },
          {
            "questionId": 19004,
            "question": "Kotlin'de finally bloğunun amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Sadece hata oluştuğunda çalışır",
              "Exception fırlatmak için kullanılır",
              "Her durumda çalışır",
              "Sadece try başarılıysa çalışır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "finally bloğu, exception oluşsa da oluşmasa da her zaman çalışır.",
            "tags": ["finally"]
          },
          {
            "questionId": 19005,
            "question": "Aşağıdaki kodun çıktısı ne olur?",
            "questionType": "multiple_choice",
            "code": "try {\n    val list = listOf(1, 2, 3)\n    println(list[5])\n} catch (e: Exception) {\n    println(\"Hata\")\n}",
            "difficulty": "medium",
            "options": [
              "5",
              "Compile-time hatası",
              "Hata",
              "Uygulama kapanır"
            ],
            "correctAnswerIndex": 2,
            "explanation": "IndexOutOfBoundsException oluşur ve catch bloğu çalışır.",
            "tags": ["try_catch", "index"]
          },
          {
            "questionId": 19006,
            "question": "Exception fırlatmak için hangi anahtar kelime kullanılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "options": [
              "throw",
              "throws",
              "exception",
              "error"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Kotlin'de exception fırlatmak için throw anahtar kelimesi kullanılır.",
            "tags": ["throw"]
          },
          {
            "questionId": 19007,
            "question": "Aşağıdakilerden hangisi debug sürecinde en çok kullanılan yöntemlerden biridir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulamayı silip tekrar kurmak",
              "Print/Log kullanmak",
              "Random değerler denemek",
              "Kodları silmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Log veya print kullanımı, hata ayıklamada temel ve etkili bir yöntemdir.",
            "tags": ["debug", "log"]
          },
          {
            "questionId": 19008,
            "question": "Stack trace neyi ifade eder?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "options": [
              "Uygulamanın performansını",
              "Hatanın oluştuğu method zincirini",
              "Bellek kullanımını",
              "UI hatalarını"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Stack trace, hatanın hangi method çağrıları sonucunda oluştuğunu gösterir.",
            "tags": ["stacktrace", "debug"]
          },
          {
            "questionId": 19009,
            "question": "Kotlin'de try-catch bir ifade (expression) olarak kullanılabilir mi?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Hayır",
              "Sadece Java'da",
              "Evet",
              "Sadece finally ile"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Kotlin'de try-catch bir expression'dır ve değer döndürebilir.",
            "tags": ["expression", "try_catch"]
          },
          {
            "questionId": 19010,
            "question": "En sağlıklı debug yaklaşımı aşağıdakilerden hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "options": [
              "Deneme-yanılma",
              "Breakpoint ve adım adım inceleme",
              "Kodun tamamını yazmak",
              "Exception'ları görmezden gelmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Breakpoint kullanarak kodu adım adım incelemek, hatanın kök nedenini bulmada en etkili yöntemdir.",
            "tags": ["debug", "breakpoint"]
          }
        ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 90001,
          "question": "Kotlin'de değiştirilemeyen değişken hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["var", "val", "let", "const"],
          "correctAnswerIndex": 1,
          "explanation": "val immutable değişkenler için kullanılır.",
          "tags": ["val", "variables"]
        },
        {
          "questionId": 90002,
          "question": "Aşağıdaki veri tiplerinden hangisi kesirli sayı tutar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["Int", "Long", "Float", "Boolean"],
          "correctAnswerIndex": 2,
          "explanation": "Float ve Double kesirli sayılar içindir.",
          "tags": ["float", "double"]
        },
        {
          "questionId": 90003,
          "question": "when yapısı neyin alternatifidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["for", "while", "if-else zinciri", "try-catch"],
          "correctAnswerIndex": 2,
          "explanation": "when, if-else zincirlerinin daha okunabilir halidir.",
          "tags": ["when"]
        },
        {
          "questionId": 90004,
          "question": "Aşağıdaki döngülerden hangisi koşul yanlış olsa bile en az bir kez çalışır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["for", "while", "do-while", "repeat"],
          "correctAnswerIndex": 2,
          "explanation": "do-while döngüsü en az bir kez çalışır.",
          "tags": ["loop"]
        },
        {
          "questionId": 90005,
          "question": "Hangi koleksiyon türü benzersiz (unique) elemanlar tutar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["List", "Array", "Set", "Map"],
          "correctAnswerIndex": 2,
          "explanation": "Set aynı elemandan birden fazla tutmaz.",
          "tags": ["set"]
        },
        {
          "questionId": 90006,
          "question": "Map koleksiyonunda veriler nasıl tutulur?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Sadece değer",
            "Index ve değer",
            "Key - Value",
            "Liste şeklinde"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Map key-value yapısıyla çalışır.",
          "tags": ["map"]
        },
        {
          "questionId": 90007,
          "question": "Fonksiyonun bir değer döndürmesini sağlayan yapı hangisidir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["print", "return", "break", "continue"],
          "correctAnswerIndex": 1,
          "explanation": "return fonksiyondan değer döndürür.",
          "tags": ["functions"]
        },
        {
          "questionId": 90008,
          "question": "Nullable bir değişken nasıl tanımlanır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["String name", "String! name", "String? name", "nullable String"],
          "correctAnswerIndex": 2,
          "explanation": "Kotlin'de nullable değişkenler '?' ile tanımlanır.",
          "tags": ["null_safety"]
        },
        {
          "questionId": 90009,
          "question": "Elvis operatörü (?:) ne işe yarar?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Null kontrolü yapar",
            "Exception fırlatır",
            "Null ise varsayılan değer döndürür",
            "Tip dönüşümü yapar"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Null durumunda alternatif değer döndürür.",
          "tags": ["elvis"]
        },
        {
          "questionId": 90010,
          "question": "lateinit ile ilgili hangisi doğrudur?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "val ile kullanılır",
            "Primitive tiplerde kullanılır",
            "Sonradan initialize edilir",
            "Nullable olmak zorundadır"
          ],
          "correctAnswerIndex": 2,
          "explanation": "lateinit, non-null var değişkenlerde kullanılır.",
          "tags": ["lateinit"]
        },
        {
          "questionId": 90011,
          "question": "Bir sınıfın miras alınabilmesi için hangi anahtar kelime gerekir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": ["abstract", "open", "override", "protected"],
          "correctAnswerIndex": 1,
          "explanation": "Kotlin'de sınıflar varsayılan olarak final'dır.",
          "tags": ["inheritance"]
        },
        {
          "questionId": 90012,
          "question": "Encapsulation'ın temel amacı nedir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Performans artırmak",
            "Veriyi gizlemek",
            "Kod kısaltmak",
            "UI ayırmak"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Encapsulation veri güvenliği sağlar.",
          "tags": ["encapsulation"]
        },
        {
          "questionId": 90013,
          "question": "Polymorphism neyi ifade eder?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Çoklu constructor",
            "Aynı metodun farklı davranışı",
            "Veri gizleme",
            "Tek sorumluluk"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Override edilen fonksiyonlar polymorphism örneğidir.",
          "tags": ["polymorphism"]
        },
        {
          "questionId": 90014,
          "question": "Lambda nedir?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "İsimsiz sınıf",
            "İsimsiz fonksiyon",
            "Interface",
            "Değişken"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Lambda isimsiz fonksiyonlardır.",
          "tags": ["lambda"]
        },
        {
          "questionId": 90015,
          "question": "map fonksiyonu ne yapar?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": [
            "Filtreler",
            "Dönüştürür",
            "Siler",
            "Sıralar"
          ],
          "correctAnswerIndex": 1,
          "explanation": "map her elemanı dönüştürür.",
          "tags": ["map"]
        },
        {
          "questionId": 90016,
          "question": "let scope fonksiyonu genellikle ne için kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Nesne oluşturmak",
            "Yan etki",
            "Null kontrolü",
            "Thread yönetimi"
          ],
          "correctAnswerIndex": 2,
          "explanation": "let genellikle nullable işlemler için kullanılır.",
          "tags": ["scope"]
        },
        {
          "questionId": 90017,
          "question": "Exception fırlatmak için hangi anahtar kelime kullanılır?",
          "questionType": "multiple_choice",
          "difficulty": "easy",
          "options": ["throw", "throws", "catch", "error"],
          "correctAnswerIndex": 0,
          "explanation": "throw exception fırlatır.",
          "tags": ["exception"]
        },
        {
          "questionId": 90018,
          "question": "finally bloğu ne zaman çalışır?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "Sadece hata olunca",
            "Sadece try başarılıysa",
            "Her durumda",
            "Hiçbir zaman"
          ],
          "correctAnswerIndex": 2,
          "explanation": "finally her koşulda çalışır.",
          "tags": ["finally"]
        },
        {
          "questionId": 90019,
          "question": "Stack trace neyi gösterir?",
          "questionType": "multiple_choice",
          "difficulty": "medium",
          "options": [
            "UI hatasını",
            "Hata oluşan method zincirini",
            "Performansı",
            "Bellek durumunu"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Stack trace hata yolunu gösterir.",
          "tags": ["debug"]
        },
        {
          "questionId": 90020,
          "question": "Kotlin'de try-catch bir expression olabilir mi?",
          "questionType": "multiple_choice",
          "difficulty": "hard",
          "options": ["Hayır", "Sadece Java'da", "Evet", "Sadece finally ile"],
          "correctAnswerIndex": 2,
          "explanation": "Kotlin'de try-catch değer döndürebilir.",
          "tags": ["try_catch"]
        }
      ]
    },
    {
      "categoryId": 2,
      "categoryTitle": "Android Temelleri",
      "categoryDescription": "Android uygulama geliştirmenin temel kavramları",
      "order": 2,
      "sections": [
        {
          "sectionId": 2100,
          "sectionTitle": "Android’e Giriş",
          "sectionDescription": "Android işletim sisteminin temel yapısı ve Android uygulama geliştirmenin genel mantığı",
          "order": 1,
          "topics": [
            {
              "topicId": 2101,
              "title": "Android Nedir",
              "summary": "Android, Google tarafından geliştirilen, Linux tabanlı, açık kaynaklı bir mobil işletim sistemidir. Akıllı telefonlar, tabletler, TV’ler ve giyilebilir cihazlarda yaygın olarak kullanılır. Android uygulamaları genellikle Kotlin veya Java dili ile geliştirilir.",
              "content": "## Android Nedir\n\nAndroid, mobil cihazlar için geliştirilmiş bir işletim sistemidir.\n\nAçık kaynaklı yapısı sayesinde birçok üretici tarafından özelleştirilerek kullanılır.\n\nAndroid uygulamaları, Android SDK ve Android Studio kullanılarak geliştirilir.\n\nGoogle Play Store, Android uygulamalarının dağıtıldığı resmi platformdur.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Linux tabanlı bir işletim sistemidir",
                "Google tarafından geliştirilir",
                "Açık kaynaklıdır",
                "Kotlin ve Java ile uygulama geliştirilir",
                "Google Play Store üzerinden dağıtılır"
              ],
              "questions": [
                {
                  "questionId": 210101,
                  "question": "Android işletim sistemi hangi şirket tarafından geliştirilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Apple",
                    "Microsoft",
                    "Google",
                    "Samsung"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android, Google tarafından geliştirilen açık kaynaklı bir mobil işletim sistemidir.",
                  "tags": ["android", "temel"]
                },
                {
                  "questionId": 210102,
                  "question": "Android hangi işletim sistemi çekirdeğini kullanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Windows NT",
                    "Linux",
                    "macOS",
                    "Unix"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android, Linux tabanlı bir işletim sistemidir ve Linux çekirdeğini kullanır.",
                  "tags": ["android", "linux"]
                },
                {
                  "questionId": 210103,
                  "question": "Android uygulamaları hangi programlama dilleri ile geliştirilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Swift ve Objective-C",
                    "C# ve VB.NET",
                    "Kotlin ve Java",
                    "Python ve Ruby"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android uygulamaları genellikle Kotlin veya Java dili ile geliştirilir. Google, resmi olarak Kotlin'i tercih etmektedir.",
                  "tags": ["android", "kotlin", "java"]
                },
                {
                  "questionId": 210104,
                  "question": "Android uygulamalarının resmi dağıtım platformu hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "App Store",
                    "Microsoft Store",
                    "Google Play Store",
                    "Amazon Appstore"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Google Play Store, Android uygulamalarının dağıtıldığı resmi platformdur.",
                  "tags": ["android", "play_store"]
                },
                {
                  "questionId": 210105,
                  "question": "Android'in açık kaynaklı olması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Herkes ücretsiz kullanabilir ama değiştiremez",
                    "Sadece Google geliştirebilir",
                    "Kaynak kodları açıktır ve özelleştirilebilir",
                    "Sadece büyük şirketler kullanabilir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Açık kaynaklı olması, Android'in kaynak kodlarının herkese açık olduğu ve cihaz üreticileri tarafından özelleştirilebileceği anlamına gelir.",
                  "tags": ["android", "open_source"]
                },
                {
                  "questionId": 210106,
                  "question": "Android uygulamaları geliştirmek için hangi IDE kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Visual Studio",
                    "Xcode",
                    "Android Studio",
                    "Eclipse"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android Studio, Google'ın resmi olarak desteklediği ve Android SDK'sını içeren entegre geliştirme ortamıdır.",
                  "tags": ["android", "android_studio"]
                },
                {
                  "questionId": 210107,
                  "question": "Android hangi tür cihazlarda kullanılmaz?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Akıllı telefonlar",
                    "Tabletler",
                    "iPhone",
                    "Akıllı TV'ler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "iPhone cihazları iOS işletim sistemini kullanır. Android, akıllı telefonlar, tabletler, TV'ler ve giyilebilir cihazlarda kullanılır.",
                  "tags": ["android", "devices"]
                }
              ]
            },
            {
              "topicId": 2102,
              "title": "Android Proje Yapısı",
              "summary": "Android proje yapısı, uygulamanın kod, kaynak dosyaları ve konfigürasyonlarının düzenli bir şekilde tutulmasını sağlar. Android Studio’da oluşturulan her proje belirli klasör ve dosya yapısına sahiptir.",
              "content": "## Android Proje Yapısı\n\nAndroid projeleri modüler bir yapıya sahiptir.\n\nTemel olarak Java/Kotlin kodları, XML arayüz dosyaları ve uygulama ayarları ayrı klasörlerde tutulur.\n\nBu yapı, büyük projelerin daha yönetilebilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Temel Proje Yapısı",
                  "code": "app/\n ├─ java/ (veya kotlin/)\n │   └─ MainActivity.kt\n ├─ res/\n │   ├─ layout/\n │   ├─ drawable/\n │   └─ values/\n └─ AndroidManifest.xml",
                  "explanation": "Android projelerinde temel klasör ve dosyaların genel görünümü."
                }
              ],
              "keyPoints": [
                "java/kotlin: Uygulama kodları",
                "res/layout: XML arayüz dosyaları",
                "res/drawable: Görseller",
                "res/values: Renk, stil ve string tanımları",
                "AndroidManifest.xml: Uygulama yapılandırması"
              ],
              "questions": [
                {
                  "questionId": 210201,
                  "question": "Android projelerinde uygulama kodları hangi klasörde bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "res/",
                    "java/ veya kotlin/",
                    "drawable/",
                    "manifest/"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Uygulama kodları (Activity, Fragment vb.) java/ veya kotlin/ klasöründe tutulur.",
                  "tags": ["android", "proje_yapisi"]
                },
                {
                  "questionId": 210202,
                  "question": "XML arayüz dosyaları hangi klasörde bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "res/drawable/",
                    "res/values/",
                    "res/layout/",
                    "java/"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "XML arayüz (layout) dosyaları res/layout/ klasöründe tutulur.",
                  "tags": ["android", "layout", "xml"]
                },
                {
                  "questionId": 210203,
                  "question": "AndroidManifest.xml dosyasının amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Activity'leri tanımlar",
                    "Uygulama görsellerini saklar",
                    "Uygulama yapılandırması ve izinlerini tanımlar",
                    "Kod derlemesini sağlar"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "AndroidManifest.xml, uygulamanın temel yapılandırmasını, Activity'leri, Service'leri, izinleri ve diğer bileşenleri tanımlar.",
                  "tags": ["android", "manifest"]
                },
                {
                  "questionId": 210204,
                  "question": "res/drawable klasörü ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "String değerler",
                    "Görseller ve çizilebilir kaynaklar",
                    "Kod dosyaları",
                    "Veritabanı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "res/drawable/ klasörü, görseller, icon'lar ve diğer çizilebilir kaynaklar için kullanılır.",
                  "tags": ["android", "drawable", "resources"]
                },
                {
                  "questionId": 210205,
                  "question": "res/values klasöründe hangi dosyalar bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece renkler",
                    "Sadece string'ler",
                    "Renk, stil, string ve boyut tanımları",
                    "Sadece Activity'ler"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "res/values/ klasöründe strings.xml, colors.xml, styles.xml, dimens.xml gibi kaynak dosyaları bulunur.",
                  "tags": ["android", "values", "resources"]
                },
                {
                  "questionId": 210206,
                  "question": "Aşağıdaki proje yapısında MainActivity.kt dosyası hangi klasördedir?",
                  "questionType": "multiple_choice",
                  "code": "app/\n ├─ kotlin/\n │   └─ MainActivity.kt\n ├─ res/\n │   ├─ layout/\n │   └─ drawable/\n └─ AndroidManifest.xml",
                  "difficulty": "easy",
                  "options": [
                    "res/layout/",
                    "kotlin/",
                    "res/drawable/",
                    "AndroidManifest/"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MainActivity.kt, uygulama kodlarının bulunduğu kotlin/ klasöründedir.",
                  "tags": ["android", "proje_yapisi"]
                },
                {
                  "questionId": 210207,
                  "question": "Android projelerinin modüler yapıda olmasının avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha hızlı derleme",
                    "Daha küçük APK boyutu",
                    "Büyük projelerin daha yönetilebilir olması",
                    "Daha az bellek kullanımı"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Modüler yapı, kod, kaynak ve konfigürasyonların ayrı tutulmasını sağlayarak büyük projelerin daha kolay yönetilmesini sağlar.",
                  "tags": ["android", "modular"]
                },
                {
                  "questionId": 210208,
                  "question": "Bir Android projesinde build.gradle dosyasının rolü nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Arayüz tasarımı",
                    "Proje bağımlılıkları ve derleme ayarları",
                    "Veritabanı şeması",
                    "Kullanıcı izinleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "build.gradle dosyası, projenin bağımlılıklarını (dependency), minimum SDK versiyonunu, hedef SDK'yı ve derleme ayarlarını içerir.",
                  "tags": ["android", "gradle", "build"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 210001,
              "question": "Android uygulamalarını geliştirmek için hangi IDE ve hangi diller kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Xcode, Swift",
                "Android Studio, Kotlin/Java",
                "Visual Studio, C#",
                "Eclipse, Python"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Android uygulamaları Android Studio IDE'si kullanılarak Kotlin veya Java ile geliştirilir.",
              "tags": ["android", "ide", "kotlin"]
            },
            {
              "questionId": 210002,
              "question": "Android'in açık kaynaklı olması geliştiricilere nasıl bir avantaj sağlar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece bedava kullanım",
                "Kaynak kodları inceleyip özelleştirebilme",
                "Daha hızlı çalışma",
                "Otomatik güncelleme"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Açık kaynak, geliştiricilerin Android kaynak kodlarını incelemesine ve cihaz üreticilerinin özelleştirmesine olanak tanır.",
              "tags": ["android", "open_source"]
            },
            {
              "questionId": 210003,
              "question": "Bir Android projesinde uygulama izinleri nerede tanımlanır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "MainActivity.kt",
                "build.gradle",
                "AndroidManifest.xml",
                "strings.xml"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Uygulama izinleri (permissions) AndroidManifest.xml dosyasında tanımlanır.",
              "tags": ["android", "permissions", "manifest"]
            },
            {
              "questionId": 210004,
              "question": "res/layout ve res/values klasörlerinin ortak özelliği nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "İkisi de kod dosyası içerir",
                "İkisi de kaynak (resource) dosyası içerir",
                "İkisi de görsel içerir",
                "İkisi de Java dosyası içerir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Her ikisi de res/ klasörü altında kaynak dosyaları içerir. layout XML arayüzleri, values ise string, renk gibi değerleri tutar.",
              "tags": ["android", "resources"]
            },
            {
              "questionId": 210005,
              "question": "Android'de Linux çekirdeği kullanılmasının avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece performans artışı",
                "Güvenlik, bellek yönetimi ve donanım soyutlaması",
                "Sadece açık kaynak lisansı",
                "Sadece çoklu görev desteği"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Linux çekirdeği, güvenlik, bellek yönetimi, süreç yönetimi ve donanım soyutlaması gibi temel işlevler sağlar.",
              "tags": ["android", "linux", "kernel"]
            },
            {
              "questionId": 210006,
              "question": "Aşağıdakilerden hangisi Android Studio'nun bir parçası değildir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Layout Editor",
                "Emulator",
                "Xcode Interface Builder",
                "Gradle Build System"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Xcode Interface Builder, Apple'ın iOS geliştirme aracıdır ve Android Studio'nun bir parçası değildir.",
              "tags": ["android", "android_studio"]
            },
            {
              "questionId": 210007,
              "question": "Bir Android uygulamasının APK dosyası nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Android kaynak kodu",
                "Android uygulama paketi (yüklenebilir dosya)",
                "Android proje dosyası",
                "Android manifest dosyası"
              ],
              "correctAnswerIndex": 1,
              "explanation": "APK (Android Package Kit), Android uygulamalarının dağıtım ve kurulum formatıdır.",
              "tags": ["android", "apk"]
            },
            {
              "questionId": 210008,
              "question": "MainActivity.kt ve activity_main.xml dosyaları arasındaki ilişki nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "İkisi de aynı dosyadır",
                "MainActivity.kt kodu, activity_main.xml arayüzünü kullanır",
                "activity_main.xml kodu, MainActivity.kt'yi çağırır",
                "Hiçbir ilişki yoktur"
              ],
              "correctAnswerIndex": 1,
              "explanation": "MainActivity.kt (kod), activity_main.xml (arayüz) dosyasını setContentView() ile bağlar ve kullanır.",
              "tags": ["android", "activity", "layout"]
            },
            {
              "questionId": 210009,
              "question": "Google Play Store'a uygulama yüklemek için hangi dosya formatı kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "EXE",
                "APK veya AAB",
                "IPA",
                "ZIP"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Google Play Store'a APK (Android Package) veya AAB (Android App Bundle) formatında uygulama yüklenir.",
              "tags": ["android", "play_store", "apk"]
            },
            {
              "questionId": 210010,
              "question": "Android projelerinde build.gradle ve AndroidManifest.xml'in ortak önemi nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "İkisi de sadece görsel tasarım içerir",
                "İkisi de proje yapılandırması için kritiktir",
                "İkisi de veritabanı yönetir",
                "İkisi de kod derlemesi yapar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "build.gradle derleme ayarlarını ve bağımlılıkları, AndroidManifest.xml ise uygulama bileşenlerini ve izinleri yapılandırır. İkisi de proje için kritik öneme sahiptir.",
              "tags": ["android", "configuration"]
            }
          ]
        },
        {
            "sectionId": 2200,
            "sectionTitle": "Layout & UI",
            "sectionDescription": "Android uygulamalarda kullanıcı arayüzü oluşturma ve layout yapıları",
            "order": 2,
            "topics": [
            {
              "topicId": 2201,
              "title": "XML Nedir",
              "summary": "XML, Android'de kullanıcı arayüzlerini tanımlamak için kullanılan işaretleme dilidir. Görünümlerin hiyerarşisi, boyutları ve özellikleri XML dosyaları içerisinde tanımlanır.",
              "content": "## XML Nedir\n\nAndroid'de UI genellikle XML dosyaları ile oluşturulur.\n\nBu yapı, tasarım ve iş mantığını ayırarak kodun daha okunabilir olmasını sağlar.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit XML Örneği",
                  "code": "<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Merhaba Android\" />",
                  "explanation": "Basit bir TextView tanımı."
                }
              ],
              "keyPoints": [
                "UI XML ile tanımlanır",
                "Koddan bağımsızdır",
                "Okunabilirliği artırır"
              ],
              "questions": [
                {
                  "questionId": 220101,
                  "question": "Android'de kullanıcı arayüzü hangi dil ile tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "JSON",
                    "HTML",
                    "XML",
                    "CSS"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Android'de UI genellikle XML (eXtensible Markup Language) ile tanımlanır.",
                  "tags": ["xml", "ui"]
                },
                {
                  "questionId": 220102,
                  "question": "XML ile UI tanımlamanın avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Daha hızlı çalışır",
                    "Tasarım ve iş mantığını ayırır",
                    "Daha az bellek kullanır",
                    "Otomatik güncelleme sağlar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "XML kullanımı, tasarım ve kod mantığını ayırarak kodun daha okunabilir ve yönetilebilir olmasını sağlar.",
                  "tags": ["xml", "separation"]
                },
                {
                  "questionId": 220103,
                  "question": "Aşağıdaki XML kodunda TextView'in genişliği ne kadardır?",
                  "questionType": "multiple_choice",
                  "code": "<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Merhaba\" />",
                  "difficulty": "medium",
                  "options": [
                    "Ekranın tamamı kadar",
                    "İçeriği kadar",
                    "Sabit 100dp",
                    "Parent kadar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "wrap_content, view'in genişliğini/yüksekliğini içeriği kadar yapar.",
                  "tags": ["xml", "wrap_content"]
                }
              ]
            },
            {
              "topicId": 2202,
              "title": "View Nedir",
              "summary": "View, Android'de ekranda görünen en temel UI bileşenidir. Button, TextView, EditText gibi tüm arayüz elemanları View sınıfından türetilir.",
              "content": "## View Nedir\n\nView, kullanıcı ile etkileşime giren temel bileşendir.\n\nTüm UI elemanları View veya ViewGroup'tan türetilir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "UI'nin temel yapı taşıdır",
                "Tıklama ve dokunma olaylarını alır",
                "ViewGroup içinde yer alır"
              ],
              "questions": [
                {
                  "questionId": 220201,
                  "question": "View nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı tablosu",
                    "Ekranda görünen temel UI bileşeni",
                    "Network isteği",
                    "Dosya sistemi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View, Android'de ekranda görünen en temel UI bileşenidir.",
                  "tags": ["view", "ui"]
                },
                {
                  "questionId": 220202,
                  "question": "Aşağıdakilerden hangisi View sınıfından türemez?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Button",
                    "TextView",
                    "Activity",
                    "EditText"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Activity bir UI bileşeni değildir. Button, TextView, EditText gibi tüm UI elemanları View sınıfından türer.",
                  "tags": ["view", "inheritance"]
                },
                {
                  "questionId": 220203,
                  "question": "ViewGroup nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece metin gösteren view",
                    "Diğer view'leri içeren özel bir View",
                    "Veritabanı grubu",
                    "Sadece resim gösteren view"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewGroup, diğer view'leri içerebilen özel bir View türüdür. LinearLayout, ConstraintLayout gibi layout'lar ViewGroup'tur.",
                  "tags": ["viewgroup", "layout"]
                }
              ]
            },
            {
              "topicId": 2203,
              "title": "LinearLayout",
              "summary": "LinearLayout, View'leri yatay veya dikey olarak sıralayan bir layout türüdür. orientation özelliği ile dizilim yönü belirlenir.",
              "content": "## LinearLayout\n\nBasit ve anlaşılır bir layout yapısıdır.\n\nİç içe kullanımı performans sorunlarına yol açabilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "LinearLayout Örneği",
                  "code": "<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView />\n    <Button />\n</LinearLayout>",
                  "explanation": "Dikey dizilimli LinearLayout."
                }
              ],
              "keyPoints": [
                "orientation: vertical / horizontal",
                "Basit dizilimler için idealdir",
                "Derin hiyerarşiden kaçınılmalı"
              ],
              "questions": [
                {
                  "questionId": 220301,
                  "question": "LinearLayout'ta orientation özelliği ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Renk belirler",
                    "Yatay veya dikey dizilim belirler",
                    "Boyut belirler",
                    "Arka plan belirler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "orientation özelliği ile view'lerin yatay (horizontal) veya dikey (vertical) dizilimi belirlenir.",
                  "tags": ["linearlayout", "orientation"]
                },
                {
                  "questionId": 220302,
                  "question": "Aşağıdaki LinearLayout'ta view'ler nasıl dizilir?",
                  "questionType": "multiple_choice",
                  "code": "<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView />\n    <Button />\n</LinearLayout>",
                  "difficulty": "easy",
                  "options": [
                    "Yan yana yatay",
                    "Alt alta dikey",
                    "Üst üste",
                    "Rastgele"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "orientation=\"vertical\" olduğu için view'ler alt alta dikey olarak dizilir.",
                  "tags": ["linearlayout", "vertical"]
                },
                {
                  "questionId": 220303,
                  "question": "LinearLayout'un performans açısından dezavantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Çok az view alır",
                    "İç içe kullanımda performans düşer",
                    "Sadece yatay çalışır",
                    "Renk desteklemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Derin hiyerarşi (nested layout) oluşturulduğunda performans sorunlarına yol açar.",
                  "tags": ["linearlayout", "performance"]
                },
                {
                  "questionId": 220304,
                  "question": "LinearLayout hangi basit UI'lar için idealdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Karmaşık form ekranları",
                    "Basit liste ve dikey/yatay dizilimler",
                    "3D grafikler",
                    "Video oynatıcı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LinearLayout basit, düz dizilimler için idealdir. Karmaşık UI'lar için ConstraintLayout önerilir.",
                  "tags": ["linearlayout", "use_case"]
                }
              ]
            },
            {
              "topicId": 2204,
              "title": "ConstraintLayout",
              "summary": "ConstraintLayout, View'leri birbirine ve parent'a göre konumlandırmaya olanak tanıyan güçlü bir layout türüdür. Performans açısından en çok önerilen layout yapısıdır.",
              "content": "## ConstraintLayout\n\nEsnek ve performanslıdır.\n\nTek layout içinde karmaşık arayüzler oluşturulabilir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Performans dostudur",
                "Karmaşık UI'lar için idealdir",
                "Constraint mantığı kullanır"
              ],
              "questions": [
                {
                  "questionId": 220401,
                  "question": "ConstraintLayout'un en büyük avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece basit UI'lar oluşturur",
                    "Performanslı ve esnek UI oluşturur",
                    "Sadece liste gösterir",
                    "XML kullanmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde performanslı şekilde oluşturmaya olanak tanır.",
                  "tags": ["constraintlayout", "performance"]
                },
                {
                  "questionId": 220402,
                  "question": "ConstraintLayout'ta view'ler nasıl konumlandırılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece parent'a göre",
                    "Sadece dikey dizilim",
                    "Birbirine ve parent'a göre constraint'lerle",
                    "Otomatik rastgele"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "ConstraintLayout'ta view'ler birbirine veya parent'a göre constraint (kısıtlama) ile konumlandırılır.",
                  "tags": ["constraintlayout", "constraint"]
                },
                {
                  "questionId": 220403,
                  "question": "ConstraintLayout hangi layout ihtiyacını azaltır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "RecyclerView",
                    "Nested (iç içe) layout",
                    "Fragment",
                    "Activity"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout sayesinde karmaşık UI'lar tek layout içinde oluşturulabildiği için nested layout ihtiyacı azalır.",
                  "tags": ["constraintlayout", "nested"]
                },
                {
                  "questionId": 220404,
                  "question": "Android Studio'da ConstraintLayout ile görsel tasarım yapan araç nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Emulator",
                    "Layout Editor",
                    "Logcat",
                    "Gradle"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android Studio'nun Layout Editor'ü ile ConstraintLayout'lar görsel olarak tasarlanabilir.",
                  "tags": ["constraintlayout", "layout_editor"]
                },
                {
                  "questionId": 220405,
                  "question": "ConstraintLayout hangi tür projeler için en çok önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece metin tabanlı uygulamalar",
                    "Karmaşık ve çok ekranlı modern uygulamalar",
                    "Sadece oyun uygulamaları",
                    "Sadece widget'lar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, performansı ve esnekliği sayesinde modern ve karmaşık Android uygulamaları için en çok önerilen layout türüdür.",
                  "tags": ["constraintlayout", "best_practice"]
                }
              ]
            },
            {
              "topicId": 2205,
              "title": "Nested Layout",
              "summary": "Nested Layout, layoutların iç içe kullanılmasıdır. Karmaşık arayüzlerde okunabilirliği artırabilir ancak aşırı kullanımı performans sorunlarına yol açar.",
              "content": "## Nested Layout\n\nİç içe layout kullanımı dikkatli yapılmalıdır.\n\nConstraintLayout bu ihtiyacı büyük ölçüde azaltır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "İç içe layout yapısıdır",
                "Performansı olumsuz etkileyebilir",
                "Alternatif olarak ConstraintLayout önerilir"
              ],
              "questions": [
                {
                  "questionId": 220501,
                  "question": "Nested Layout ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Tek layout kullanımı",
                    "Layout'ların iç içe kullanılması",
                    "View'sız layout",
                    "Sadece XML'siz layout"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Nested Layout, layout'ların iç içe kullanılması anlamına gelir.",
                  "tags": ["nested_layout"]
                },
                {
                  "questionId": 220502,
                  "question": "Aşırı nested layout kullanımının dezavantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha az bellek kullanır",
                    "Performansı olumsuz etkiler",
                    "Daha hızlı çalışır",
                    "Kod kısalır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Derin layout hiyerarşisi, view çizim süresini artırarak performansı olumsuz etkiler.",
                  "tags": ["nested_layout", "performance"]
                },
                {
                  "questionId": 220503,
                  "question": "Nested layout yerine hangi yapı önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Daha fazla nested layout",
                    "ConstraintLayout",
                    "Sadece kod ile UI",
                    "XML kullanmamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde oluşturabildiği için nested layout ihtiyacını azaltır.",
                  "tags": ["nested_layout", "alternative"]
                }
              ]
            },
            {
              "topicId": 2206,
              "title": "View Binding",
              "summary": "View Binding, XML'de tanımlanan view'lara güvenli ve kolay erişim sağlayan bir özelliktir. findViewById kullanımını ortadan kaldırır.",
              "content": "## View Binding\n\nDerleme zamanında binding sınıfları oluşturur.\n\nNull safety sağlar ve kodu sadeleştirir.",
              "difficulty": "easy",
              "order": 6,
              "codeExamples": [
                {
                  "title": "View Binding Kullanımı",
                  "code": "val binding = ActivityMainBinding.inflate(layoutInflater)\nsetContentView(binding.root)\n\nbinding.textView.text = \"Merhaba\"",
                  "explanation": "View Binding ile view erişimi."
                }
              ],
              "keyPoints": [
                "findViewById ihtiyacını kaldırır",
                "Null safety sağlar",
                "Kod okunabilirliğini artırır"
              ],
              "questions": [
                {
                  "questionId": 220601,
                  "question": "View Binding'in amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı bağlantısı",
                    "XML'deki view'lara güvenli erişim",
                    "Network isteği",
                    "Animasyon oluşturma"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding, XML'de tanımlanan view'lara güvenli ve kolay erişim sağlar.",
                  "tags": ["view_binding"]
                },
                {
                  "questionId": 220602,
                  "question": "View Binding hangi eski yöntemi ortadan kaldırır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "setContentView",
                    "findViewById",
                    "onCreate",
                    "inflate"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding, findViewById kullanımını ortadan kaldırarak daha güvenli kod yazmamızı sağlar.",
                  "tags": ["view_binding", "findviewbyid"]
                },
                {
                  "questionId": 220603,
                  "question": "View Binding ne zaman oluşturulur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Runtime'da",
                    "Derleme zamanında (compile-time)",
                    "Uygulama ilk açıldığında",
                    "Manuel olarak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding sınıfları derleme zamanında otomatik olarak oluşturulur.",
                  "tags": ["view_binding", "compile_time"]
                },
                {
                  "questionId": 220604,
                  "question": "Aşağıdaki View Binding kodunda binding.textView ne tür bir nesnedir?",
                  "questionType": "multiple_choice",
                  "code": "val binding = ActivityMainBinding.inflate(layoutInflater)\nbinding.textView.text = \"Merhaba\"",
                  "difficulty": "easy",
                  "options": [
                    "String",
                    "TextView",
                    "Button",
                    "Int"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding ile XML'deki textView ID'sine sahip TextView nesnesine doğrudan erişilir.",
                  "tags": ["view_binding", "textview"]
                },
                {
                  "questionId": 220605,
                  "question": "View Binding'in null safety sağlaması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "View'ler asla null olamaz",
                    "Derleme zamanında view varlığı garanti edilir",
                    "Sadece nullable view'ler kullanılır",
                    "Null kontrolü yapmaya gerek kalmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "View Binding, XML'de tanımlı view'lere tür güvenli erişim sağlar ve yanlış ID kullanımını derleme zamanında engeller.",
                  "tags": ["view_binding", "null_safety"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 220001,
              "question": "Android'de UI tanımlamak için XML kullanmanın kod yazımından farkı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hiçbir fark yok",
                "XML tasarım ve mantığı ayırır",
                "XML daha yavaştır",
                "XML kullanılamaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "XML ile UI tasarımı, Kotlin/Java kodundan ayrılarak daha okunabilir ve yönetilebilir olur.",
              "tags": ["xml", "separation"]
            },
            {
              "questionId": 220002,
              "question": "LinearLayout yerine ConstraintLayout kullanmanın performans avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "Nested layout ihtiyacını azaltır ve performansı artırır",
                "Sadece daha az kod yazılır",
                "Sadece görsel olarak daha güzeldir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde oluşturarak nested layout kullanımını ve dolayısıyla performans kaybını azaltır.",
              "tags": ["constraintlayout", "performance"]
            },
            {
              "questionId": 220003,
              "question": "findViewById yerine View Binding kullanmanın avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Daha hızlı çalışır",
                "Null safety ve tür güvenliği sağlar",
                "Daha az bellek kullanır",
                "XML'e ihtiyaç kalmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding, findViewById'a göre null safety ve tür güvenliği sağlar, böylece derleme zamanında hata yakalanır.",
              "tags": ["view_binding", "findviewbyid"]
            },
            {
              "questionId": 220004,
              "question": "wrap_content ve match_parent arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hiçbir fark yok",
                "wrap_content içeriği kadar, match_parent parent kadar",
                "wrap_content daha büyük",
                "match_parent sadece yükseklik içindir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "wrap_content view'i içeriği kadar yapar, match_parent ise parent'ın boyutu kadar yapar.",
              "tags": ["layout_params"]
            },
            {
              "questionId": 220005,
              "question": "ViewGroup ve View arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "ViewGroup diğer view'leri içerebilir, View içeremez",
                "ViewGroup sadece metin gösterir",
                "View daha büyüktür",
                "Hiçbir fark yok"
              ],
              "correctAnswerIndex": 0,
              "explanation": "ViewGroup, diğer view'leri (child view) içerebilen özel bir View türüdür. LinearLayout, ConstraintLayout gibi layout'lar ViewGroup'tur.",
              "tags": ["viewgroup", "view"]
            },
            {
              "questionId": 220006,
              "question": "Bir ekranda 5 seviye nested LinearLayout kullanmanın sonucu ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha hızlı çalışır",
                "Performans düşer, layout render süresi artar",
                "Hiçbir etkisi olmaz",
                "Daha az bellek kullanır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Derin nested layout hiyerarşisi, view ölçüm ve çizim süresini artırarak performans düşüşüne yol açar.",
              "tags": ["nested_layout", "performance"]
            },
            {
              "questionId": 220007,
              "question": "ConstraintLayout'ta bir view'i ekranın ortasına konumlandırmak için ne yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir şey yapılmaz, otomatik ortalanır",
                "Tüm kenarları parent'a constraint'lenir",
                "Sadece left constraint'i verilir",
                "LinearLayout kullanılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ConstraintLayout'ta bir view'i ortalamak için tüm kenarları (top, bottom, start, end) parent'a constraint'lenir.",
              "tags": ["constraintlayout", "centering"]
            },
            {
              "questionId": 220008,
              "question": "LinearLayout orientation=\"horizontal\" durumunda view'ler nasıl dizilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Alt alta dikey",
                "Yan yana yatay",
                "Üst üste",
                "Rastgele"
              ],
              "correctAnswerIndex": 1,
              "explanation": "orientation=\"horizontal\" olduğunda view'ler yan yana yatay olarak dizilir.",
              "tags": ["linearlayout", "horizontal"]
            },
            {
              "questionId": 220009,
              "question": "View Binding'i projeye dahil etmek için hangi dosyada ayar yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "AndroidManifest.xml",
                "build.gradle (Module: app)",
                "strings.xml",
                "MainActivity.kt"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding, build.gradle (Module: app) dosyasında viewBinding { enabled = true } şeklinde etkinleştirilir.",
              "tags": ["view_binding", "gradle"]
            },
            {
              "questionId": 220010,
              "question": "Modern Android uygulamalarında UI oluşturmak için en çok önerilen layout ve binding yöntemi hangisidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "LinearLayout + findViewById",
                "ConstraintLayout + View Binding",
                "FrameLayout + findViewById",
                "RelativeLayout + findViewById"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modern Android geliştirmede ConstraintLayout (performans için) ve View Binding (güvenli view erişimi için) birlikte kullanımı önerilir.",
              "tags": ["best_practice", "modern_android"]
            }
          ]
        },
        {
          "sectionId": 2300,
          "sectionTitle": "Activity & Lifecycle",
          "sectionDescription": "Android uygulamalarda Activity kavramı, yaşam döngüsü ve Context kullanımı",
          "order": 3,
          "topics": [
            {
              "topicId": 2301,
              "title": "Activity Nedir",
              "summary": "Activity, Android uygulamalarda kullanıcıya gösterilen tek bir ekranı temsil eder. Uygulama içerisindeki her ekran genellikle bir Activity veya Fragment tarafından yönetilir.",
              "content": "## Activity Nedir\n\nActivity, kullanıcı ile etkileşime girilen temel bileşendir.\n\nBir uygulama birden fazla Activity içerebilir ve Activity'ler arasında Intent kullanılarak geçiş yapılır.\n\nActivity, Android işletim sistemi tarafından belirli bir yaşam döngüsüne göre yönetilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Activity Tanımı",
                  "code": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}",
                  "explanation": "Bir Activity'nin temel yapısı ve onCreate metodu."
                }
              ],
              "keyPoints": [
                "Her Activity bir ekranı temsil eder",
                "AppCompatActivity'den türetilir",
                "Intent ile Activity geçişleri yapılır",
                "Yaşam döngüsü metotlarına sahiptir"
              ],
              "questions": [
                {
                  "questionId": 230101,
                  "question": "Activity nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı tablosu",
                    "Kullanıcıya gösterilen tek bir ekran",
                    "Sadece arka plan servisi",
                    "Network bağlantısı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Activity, Android uygulamalarda kullanıcıya gösterilen tek bir ekranı temsil eder.",
                  "tags": ["activity", "temel"]
                },
                {
                  "questionId": 230102,
                  "question": "Activity hangi sınıftan türetilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Fragment",
                    "View",
                    "AppCompatActivity",
                    "Context"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Modern Android uygulamalarında Activity'ler genellikle AppCompatActivity sınıfından türetilir.",
                  "tags": ["activity", "inheritance"]
                },
                {
                  "questionId": 230103,
                  "question": "Activity'ler arasında geçiş yapmak için ne kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Toast",
                    "Intent",
                    "Bundle",
                    "Context"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Activity'ler arasında geçiş yapmak için Intent kullanılır.",
                  "tags": ["activity", "intent"]
                },
                {
                  "questionId": 230104,
                  "question": "Aşağıdaki kodda onCreate metodunun amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "Activity'yi yok eder",
                    "Activity'yi başlatır ve ilk kurulumu yapar",
                    "Activity'yi arka plana alır",
                    "Sadece log basar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "onCreate metodu, Activity oluşturulduğunda çağrılır ve ilk kurulum işlemleri burada yapılır. setContentView ile layout bağlanır.",
                  "tags": ["activity", "oncreate"]
                },
                {
                  "questionId": 230105,
                  "question": "Bir uygulamada kaç tane Activity bulunabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece 1 tane",
                    "En fazla 3 tane",
                    "Birden fazla olabilir",
                    "Activity olmadan da uygulama çalışır"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Bir Android uygulaması birden fazla Activity içerebilir. Her Activity farklı bir ekranı temsil edebilir.",
                  "tags": ["activity", "multiple"]
                }
              ]
            },
            {
              "topicId": 2302,
              "title": "Lifecycle Metotları",
              "summary": "Lifecycle metotları, Activity'nin oluşturulmasından yok edilmesine kadar geçen sürede hangi aşamalardan geçtiğini belirler. Bu metotlar sayesinde kaynak yönetimi doğru şekilde yapılır.",
              "content": "## Lifecycle Metotları\n\nAndroid, Activity'nin durumuna göre belirli lifecycle metotlarını çağırır.\n\nBu metotlar, uygulamanın arka plana alınması, tekrar açılması veya kapatılması gibi durumlarda çalışır.\n\nDoğru lifecycle yönetimi performans ve stabilite açısından kritik öneme sahiptir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Lifecycle Metotları Örneği",
                  "code": "override fun onStart() {\n    super.onStart()\n}\n\noverride fun onResume() {\n    super.onResume()\n}\n\noverride fun onPause() {\n    super.onPause()\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n}",
                  "explanation": "Activity yaşam döngüsünde sık kullanılan metotlar."
                }
              ],
              "keyPoints": [
                "onCreate: Activity oluşturulur",
                "onStart / onResume: Activity görünür ve aktif",
                "onPause / onStop: Activity arka plana alınır",
                "onDestroy: Activity yok edilir",
                "Kaynaklar lifecycle'a göre yönetilmelidir"
              ],
              "questions": [
                {
                  "questionId": 230201,
                  "question": "Activity ilk oluşturulduğunda hangi lifecycle metodu çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onStart()",
                    "onResume()",
                    "onCreate()",
                    "onDestroy()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onCreate() metodu, Activity ilk oluşturulduğunda çağrılır ve temel kurulum işlemleri burada yapılır.",
                  "tags": ["lifecycle", "oncreate"]
                },
                {
                  "questionId": 230202,
                  "question": "Activity görünür hale geldiğinde hangi metot çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "onCreate()",
                    "onStart()",
                    "onPause()",
                    "onDestroy()"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "onStart() metodu, Activity görünür hale geldiğinde (kullanıcı ekranı görebildiğinde) çağrılır.",
                  "tags": ["lifecycle", "onstart"]
                },
                {
                  "questionId": 230203,
                  "question": "Activity tamamen aktif ve kullanıcı etkileşime geçebilir durumdayken hangi metot çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "onCreate()",
                    "onStart()",
                    "onResume()",
                    "onPause()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onResume() metodu, Activity tamamen aktif hale geldiğinde ve kullanıcı etkileşime geçebilir durumdayken çağrılır.",
                  "tags": ["lifecycle", "onresume"]
                },
                {
                  "questionId": 230204,
                  "question": "Activity arka plana alındığında hangi metot çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onResume()",
                    "onCreate()",
                    "onPause()",
                    "onRestart()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onPause() metodu, Activity arka plana alındığında veya başka bir Activity öne çıktığında çağrılır.",
                  "tags": ["lifecycle", "onpause"]
                },
                {
                  "questionId": 230205,
                  "question": "Activity tamamen yok edildiğinde hangi metot çağrılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onStop()",
                    "onPause()",
                    "onDestroy()",
                    "onCreate()"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "onDestroy() metodu, Activity tamamen yok edildiğinde çağrılır. Burada kaynaklar serbest bırakılmalıdır.",
                  "tags": ["lifecycle", "ondestroy"]
                }
              ]
            },
            {
              "topicId": 2303,
              "title": "Context",
              "summary": "Context, Android uygulamasının mevcut durumunu ve ortam bilgisini temsil eder. Kaynaklara erişim, Activity başlatma ve sistem servislerini kullanmak için gereklidir.",
              "content": "## Context\n\nContext, uygulama hakkında bilgi sağlar.\n\nActivity, Application ve Service gibi sınıflar Context türevleridir.\n\nYanlış Context kullanımı memory leak gibi sorunlara yol açabilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Context Kullanımı",
                  "code": "Toast.makeText(this, \"Merhaba\", Toast.LENGTH_SHORT).show()",
                  "explanation": "Activity context kullanılarak Toast gösterilmesi."
                }
              ],
              "keyPoints": [
                "Kaynaklara erişim sağlar",
                "Activity ve Application Context farkı vardır",
                "Yanlış kullanım memory leak oluşturabilir",
                "Toast, Intent ve Dialog işlemlerinde kullanılır"
              ],
              "questions": [
                {
                  "questionId": 230301,
                  "question": "Context nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece layout dosyası",
                    "Uygulamanın mevcut durumunu temsil eden ortam bilgisi",
                    "Sadece veritabanı",
                    "Sadece network bağlantısı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Context, Android uygulamasının mevcut durumunu ve ortam bilgisini temsil eder.",
                  "tags": ["context", "temel"]
                },
                {
                  "questionId": 230302,
                  "question": "Aşağıdaki kodda 'this' ne tür bir Context'tir?",
                  "questionType": "multiple_choice",
                  "code": "Toast.makeText(this, \"Merhaba\", Toast.LENGTH_SHORT).show()",
                  "difficulty": "medium",
                  "options": [
                    "Application Context",
                    "Activity Context",
                    "Service Context",
                    "Fragment Context"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Activity içinde 'this' kullanıldığında Activity Context'i temsil eder.",
                  "tags": ["context", "activity_context"]
                },
                {
                  "questionId": 230303,
                  "question": "Yanlış Context kullanımı hangi soruna yol açabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha hızlı çalışma",
                    "Memory leak (bellek sızıntısı)",
                    "Daha az bellek kullanımı",
                    "Hiçbir sorun oluşmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Yanlış Context kullanımı (örneğin Activity Context'i uzun ömürlü nesnelerde tutmak) memory leak'e yol açabilir.",
                  "tags": ["context", "memory_leak"]
                },
                {
                  "questionId": 230304,
                  "question": "Context hangi işlemler için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece veritabanı işlemleri",
                    "Kaynaklara erişim, Activity başlatma, sistem servisleri",
                    "Sadece network işlemleri",
                    "Sadece matematiksel hesaplamalar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Context; kaynaklara erişim (getString, getDrawable), Activity başlatma (Intent), sistem servislerini kullanma ve Toast/Dialog gösterme gibi işlemler için kullanılır.",
                  "tags": ["context", "usage"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 230001,
              "question": "Activity yaşam döngüsünde doğru sıralama hangisidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "onCreate → onResume → onStart",
                "onCreate → onStart → onResume",
                "onStart → onCreate → onResume",
                "onResume → onCreate → onStart"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity yaşam döngüsü: onCreate() → onStart() → onResume() sırasıyla çalışır.",
              "tags": ["lifecycle", "sequence"]
            },
            {
              "questionId": 230002,
              "question": "Kullanıcı Home tuşuna basarak uygulamayı arka plana aldığında hangi lifecycle metotları çağrılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece onPause()",
                "onPause() → onStop()",
                "onPause() → onDestroy()",
                "Hiçbiri çağrılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Uygulama arka plana alındığında önce onPause(), ardından onStop() çağrılır. Activity yok edilmez.",
              "tags": ["lifecycle", "background"]
            },
            {
              "questionId": 230003,
              "question": "Activity'de setContentView() metodu hangi lifecycle metodunda çağrılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "onStart()",
                "onResume()",
                "onCreate()",
                "onDestroy()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "setContentView() metodu, layout'u Activity'ye bağlamak için onCreate() metodunda çağrılır.",
              "tags": ["activity", "setcontentview"]
            },
            {
              "questionId": 230004,
              "question": "Activity Context ve Application Context arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "Activity Context Activity'ye bağlı, Application Context tüm uygulamaya bağlı",
                "Application Context daha yavaştır",
                "Activity Context sadece layout için kullanılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity Context, Activity'nin yaşam döngüsüne bağlıdır. Application Context ise uygulama çalıştığı sürece yaşar ve uzun ömürlü işlemler için tercih edilir.",
              "tags": ["context", "difference"]
            },
            {
              "questionId": 230005,
              "question": "onDestroy() metodunda ne tür işlemler yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Layout bağlama",
                "Kaynakları serbest bırakma (cleanup)",
                "Yeni Activity başlatma",
                "Toast gösterme"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onDestroy() metodunda listener'lar, broadcast receiver'lar gibi kaynaklar serbest bırakılmalı ve cleanup işlemleri yapılmalıdır.",
              "tags": ["lifecycle", "cleanup"]
            },
            {
              "questionId": 230006,
              "question": "Activity arka plandayken tekrar ön plana geldiğinde hangi lifecycle metotları çalışır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "onCreate() → onStart() → onResume()",
                "onRestart() → onStart() → onResume()",
                "Sadece onResume()",
                "onStart() → onResume()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Activity arka plandayken tekrar ön plana geldiğinde onRestart() → onStart() → onResume() sırası çalışır.",
              "tags": ["lifecycle", "restart"]
            },
            {
              "questionId": 230007,
              "question": "Intent kullanarak başka bir Activity'ye veri göndermek için hangi metot kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "intent.getData()",
                "intent.putExtra()",
                "intent.send()",
                "intent.setData()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent ile veri göndermek için putExtra() metodu kullanılır.",
              "tags": ["intent", "data_passing"]
            },
            {
              "questionId": 230008,
              "question": "onPause() ve onStop() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "onPause() Activity kısmen görünür, onStop() tamamen görünmez",
                "onStop() daha önce çağrılır",
                "onPause() sadece ilk açılışta çalışır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onPause()'da Activity hala kısmen görünür olabilir (örneğin dialog üstte), onStop()'ta ise Activity tamamen görünmez hale gelir.",
              "tags": ["lifecycle", "onpause_onstop"]
            },
            {
              "questionId": 230009,
              "question": "AndroidManifest.xml'de Activity tanımlanmazsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir şey olmaz",
                "Uygulama açılmaz",
                "Activity çalıştırılamaz",
                "Sadece uyarı verir"
              ],
              "correctAnswerIndex": 2,
              "explanation": "AndroidManifest.xml'de tanımlanmayan Activity'ler çalıştırılamaz ve runtime exception oluşur.",
              "tags": ["activity", "manifest"]
            },
            {
              "questionId": 230010,
              "question": "Configuration change (ekran döndürme) durumunda Activity varsayılan olarak ne yapar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey olmaz",
                "Sadece onPause() çağrılır",
                "Activity yok edilip yeniden oluşturulur",
                "Sadece layout değişir"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Configuration change (örneğin ekran döndürme) durumunda Activity varsayılan olarak yok edilir (onDestroy) ve yeniden oluşturulur (onCreate).",
              "tags": ["lifecycle", "configuration_change"]
            }
          ]
        },
        {
          "sectionId": 2400,
          "sectionTitle": "Kullanıcı Etkileşimi",
          "sectionDescription": "Kullanıcının uygulama ile etkileşime girmesini sağlayan temel UI bileşenleri",
          "order": 4,
          "topics": [
            {
              "topicId": 2401,
              "title": "Button",
              "summary": "Button, kullanıcının bir aksiyon başlatmasını sağlayan temel UI bileşenidir. Genellikle tıklama (click) olayları ile birlikte kullanılır.",
              "content": "## Button\n\nButton, kullanıcıdan aksiyon almak için kullanılır.\n\nTıklama olayları click listener aracılığıyla yakalanır.\n\nXML üzerinden veya kod ile özelleştirilebilir.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Button Tanımı",
                  "code": "<Button\n    android:id=\"@+id/btnSave\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Kaydet\" />",
                  "explanation": "XML ile Button tanımlama."
                }
              ],
              "keyPoints": [
                "Kullanıcı aksiyonu için kullanılır",
                "Click listener ile çalışır",
                "XML ve koddan kontrol edilebilir"
              ],
              "questions": [
                {
                  "questionId": 240101,
                  "question": "Button ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Metin göstermek",
                    "Kullanıcıdan aksiyon almak",
                    "Sadece görsel için",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Button, kullanıcının bir aksiyon başlatmasını sağlayan temel UI bileşenidir.",
                  "tags": ["button", "temel"]
                },
                {
                  "questionId": 240102,
                  "question": "Aşağıdaki XML'de Button'un ID'si nedir?",
                  "questionType": "multiple_choice",
                  "code": "<Button\n    android:id=\"@+id/btnSave\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Kaydet\" />",
                  "difficulty": "easy",
                  "options": [
                    "Kaydet",
                    "btnSave",
                    "Button",
                    "wrap_content"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "android:id=\"@+id/btnSave\" ifadesinde Button'un ID'si btnSave'dir.",
                  "tags": ["button", "xml"]
                },
                {
                  "questionId": 240103,
                  "question": "Button'a tıklama olayı nasıl eklenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "onClick listener",
                    "setText metodu",
                    "setId metodu",
                    "Otomatik eklenir"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Button'a tıklama olayı eklemek için setOnClickListener kullanılır.",
                  "tags": ["button", "click_listener"]
                }
              ]
            },
            {
              "topicId": 2402,
              "title": "EditText",
              "summary": "EditText, kullanıcıdan metin girişi almak için kullanılan bir UI bileşenidir. Formlar ve veri giriş ekranlarında yaygın olarak kullanılır.",
              "content": "## EditText\n\nEditText, kullanıcıdan veri almak için kullanılır.\n\ninputType ile klavye türü belirlenebilir.\n\nGirilen veri String olarak alınır.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [
                {
                  "title": "EditText Kullanımı",
                  "code": "<EditText\n    android:id=\"@+id/etName\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"İsim giriniz\" />",
                  "explanation": "Basit EditText tanımı."
                }
              ],
              "keyPoints": [
                "Kullanıcıdan metin alır",
                "inputType ile klavye ayarlanır",
                "Genellikle form ekranlarında kullanılır"
              ],
              "questions": [
                {
                  "questionId": 240201,
                  "question": "EditText ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece metin göstermek",
                    "Kullanıcıdan metin girişi almak",
                    "Resim göstermek",
                    "Video oynatmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "EditText, kullanıcıdan metin girişi almak için kullanılan bir UI bileşenidir.",
                  "tags": ["edittext", "input"]
                },
                {
                  "questionId": 240202,
                  "question": "EditText'te klavye türünü belirlemek için hangi özellik kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "android:text",
                    "android:hint",
                    "android:inputType",
                    "android:id"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "android:inputType ile klavye türü belirlenir (textPassword, number, email vb.).",
                  "tags": ["edittext", "inputtype"]
                },
                {
                  "questionId": 240203,
                  "question": "Aşağıdaki EditText'te hint metni ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": "<EditText\n    android:id=\"@+id/etName\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:hint=\"İsim giriniz\" />",
                  "difficulty": "easy",
                  "options": [
                    "Kullanıcıya yönlendirme gösterir",
                    "Edittext'in değeridir",
                    "ID'sidir",
                    "Hata mesajıdır"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "hint, EditText boşken kullanıcıya ne girmesi gerektiğini belirten açıklayıcı metindir.",
                  "tags": ["edittext", "hint"]
                }
              ]
            },
            {
              "topicId": 2403,
              "title": "Click Listener",
              "summary": "Click Listener, kullanıcı bir View'a tıkladığında çalışacak kod bloğunu tanımlamak için kullanılır. En yaygın kullanılan etkileşim yöntemidir.",
              "content": "## Click Listener\n\nClick listener sayesinde kullanıcı etkileşimleri yakalanır.\n\nKotlin'de lambda yapısı ile daha sade yazılabilir.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Click Listener Örneği",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "explanation": "Lambda kullanılarak click listener tanımı."
                }
              ],
              "keyPoints": [
                "Kullanıcı etkileşimini yakalar",
                "Lambda ile sade kullanım",
                "Tüm View'lar için geçerlidir"
              ],
              "questions": [
                {
                  "questionId": 240301,
                  "question": "Click listener ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "View oluşturur",
                    "Kullanıcı tıklama olaylarını yakalar",
                    "Layout tasarlar",
                    "Veritabanına veri yazar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Click listener, kullanıcı bir View'a tıkladığında çalışacak kod bloğunu tanımlamak için kullanılır.",
                  "tags": ["click_listener", "temel"]
                },
                {
                  "questionId": 240302,
                  "question": "Aşağıdaki kodda ne olur?",
                  "questionType": "multiple_choice",
                  "code": "button.setOnClickListener {\n    println(\"Butona tıklandı\")\n}",
                  "difficulty": "easy",
                  "options": [
                    "Button oluşturulur",
                    "Button tıklandığında konsola mesaj yazılır",
                    "Button silinir",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "setOnClickListener içindeki kod bloğu, button'a tıklandığında çalışır ve konsola mesaj yazar.",
                  "tags": ["click_listener", "kotlin"]
                },
                {
                  "questionId": 240303,
                  "question": "Click listener hangi View'lar için kullanılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Button",
                    "Sadece TextView",
                    "Tüm View'lar",
                    "Sadece EditText"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Click listener tüm View türleri için kullanılabilir (Button, TextView, ImageView, CardView vb.).",
                  "tags": ["click_listener", "view"]
                }
              ]
            },
            {
              "topicId": 2404,
              "title": "AlertDialog",
              "summary": "AlertDialog, kullanıcıya bilgi vermek veya onay almak için kullanılan açılır pencere yapısıdır. Kritik aksiyonlar öncesinde sıkça tercih edilir.",
              "content": "## AlertDialog\n\nAlertDialog, kullanıcıdan onay veya seçim almak için kullanılır.\n\nBaşlık, mesaj ve butonlar içerir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "AlertDialog Örneği",
                  "code": "AlertDialog.Builder(this)\n    .setTitle(\"Uyarı\")\n    .setMessage(\"Silmek istiyor musunuz?\")\n    .setPositiveButton(\"Evet\", null)\n    .setNegativeButton(\"Hayır\", null)\n    .show()",
                  "explanation": "Basit bir AlertDialog oluşturma."
                }
              ],
              "keyPoints": [
                "Kullanıcıdan onay almak için kullanılır",
                "Pozitif ve negatif butonlar içerir",
                "Context gerektirir"
              ],
              "questions": [
                {
                  "questionId": 240401,
                  "question": "AlertDialog ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece bilgi göstermek",
                    "Kullanıcıdan onay veya seçim almak",
                    "Layout oluşturmak",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "AlertDialog, kullanıcıya bilgi vermek veya onay almak için kullanılan açılır pencere yapısıdır.",
                  "tags": ["alertdialog", "temel"]
                },
                {
                  "questionId": 240402,
                  "question": "AlertDialog'da pozitif buton ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "İptal butonu",
                    "Onay/Evet butonu",
                    "Geri butonu",
                    "Kapat butonu"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "setPositiveButton, genellikle 'Evet', 'Tamam', 'Kaydet' gibi onay butonları için kullanılır.",
                  "tags": ["alertdialog", "positive_button"]
                },
                {
                  "questionId": 240403,
                  "question": "Aşağıdaki AlertDialog kodunda kaç buton vardır?",
                  "questionType": "multiple_choice",
                  "code": "AlertDialog.Builder(this)\n    .setTitle(\"Uyarı\")\n    .setMessage(\"Silmek istiyor musunuz?\")\n    .setPositiveButton(\"Evet\", null)\n    .setNegativeButton(\"Hayır\", null)\n    .show()",
                  "difficulty": "easy",
                  "options": [
                    "1 buton",
                    "2 buton",
                    "3 buton",
                    "Buton yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Positive (Evet) ve Negative (Hayır) olmak üzere 2 buton vardır.",
                  "tags": ["alertdialog", "buttons"]
                },
                {
                  "questionId": 240404,
                  "question": "AlertDialog oluşturmak için ne gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece String",
                    "Context",
                    "Sadece Layout",
                    "Fragment"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "AlertDialog oluşturmak için Context gereklidir. Builder'a this (Activity context) veya applicationContext verilebilir.",
                  "tags": ["alertdialog", "context"]
                }
              ]
            },
            {
              "topicId": 2405,
              "title": "Toast / Snackbar",
              "summary": "Toast ve Snackbar, kullanıcıya kısa süreli bilgilendirme mesajları göstermek için kullanılır. Snackbar, Toast'a göre daha etkileşimli ve modern bir çözümdür.",
              "content": "## Toast / Snackbar\n\nToast kısa süreli mesaj gösterir.\n\nSnackbar, aksiyon butonu eklemeye izin verir ve genellikle View ile ilişkilidir.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Toast ve Snackbar",
                  "code": "Toast.makeText(this, \"Kayıt başarılı\", Toast.LENGTH_SHORT).show()\n\nSnackbar.make(view, \"Silindi\", Snackbar.LENGTH_LONG)\n    .setAction(\"Geri Al\") { }\n    .show()",
                  "explanation": "Toast ve Snackbar kullanım örneği."
                }
              ],
              "keyPoints": [
                "Toast kısa bilgilendirme için kullanılır",
                "Snackbar daha etkileşimlidir",
                "Snackbar aksiyon alabilir"
              ],
              "questions": [
                {
                  "questionId": 240501,
                  "question": "Toast ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Kullanıcıdan veri almak",
                    "Kısa süreli bilgilendirme mesajı göstermek",
                    "Activity başlatmak",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Toast, kullanıcıya kısa süreli bilgilendirme mesajları göstermek için kullanılır.",
                  "tags": ["toast", "temel"]
                },
                {
                  "questionId": 240502,
                  "question": "Toast ve Snackbar arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Snackbar daha etkileşimli ve aksiyon butonu alabilir",
                    "Toast daha yavaştır",
                    "Snackbar sadece error için kullanılır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Snackbar, Toast'a göre daha etkileşimlidir ve aksiyon butonu eklenebilir (örneğin Geri Al).",
                  "tags": ["toast", "snackbar", "difference"]
                },
                {
                  "questionId": 240503,
                  "question": "Aşağıdaki kodda Toast ne kadar süre görünür?",
                  "questionType": "multiple_choice",
                  "code": "Toast.makeText(this, \"Kayıt başarılı\", Toast.LENGTH_SHORT).show()",
                  "difficulty": "easy",
                  "options": [
                    "1 saniye",
                    "Kısa süre (yaklaşık 2 saniye)",
                    "Uzun süre (yaklaşık 3.5 saniye)",
                    "Sonsuz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Toast.LENGTH_SHORT, Toast'un kısa süre (yaklaşık 2 saniye) görünmesini sağlar. LENGTH_LONG ise yaklaşık 3.5 saniyedir.",
                  "tags": ["toast", "duration"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 240001,
              "question": "Button, EditText ve TextView'in ortak özelliği nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hepsi View sınıfından türer",
                "Hepsi sadece metin gösterir",
                "Hepsi aynı şeydir",
                "Hepsi sadece tıklanabilir"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Button, EditText, TextView ve diğer tüm UI bileşenleri View sınıfından türer.",
              "tags": ["view", "inheritance"]
            },
            {
              "questionId": 240002,
              "question": "Kullanıcıdan şifre girişi almak için EditText'te hangi inputType kullanılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "textEmailAddress",
                "number",
                "textPassword",
                "phone"
              ],
              "correctAnswerIndex": 2,
              "explanation": "android:inputType=\"textPassword\" kullanıldığında girilen karakter gizlenir ve şifre girişi için uygun klavye gösterilir.",
              "tags": ["edittext", "inputtype", "password"]
            },
            {
              "questionId": 240003,
              "question": "Kritik bir silme işlemi öncesinde kullanıcıdan onay almak için hangi bileşen kullanılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Toast",
                "Button",
                "AlertDialog",
                "EditText"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Kritik aksiyonlar öncesinde kullanıcıdan onay almak için AlertDialog kullanılır.",
              "tags": ["alertdialog", "confirmation"]
            },
            {
              "questionId": 240004,
              "question": "Snackbar'ın Toast'a göre avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha hızlıdır",
                "Aksiyon butonu eklenebilir",
                "Daha az bellek kullanır",
                "Daha uzun süre görünür"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Snackbar'a setAction() ile aksiyon butonu eklenebilir (örneğin Geri Al), Toast'ta bu özellik yoktur.",
              "tags": ["snackbar", "advantage"]
            },
            {
              "questionId": 240005,
              "question": "View Binding ile Button'a nasıl erişilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "findViewById(R.id.button)",
                "binding.button",
                "getButton()",
                "button.get()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "View Binding kullanıldığında XML'deki view'lara binding.viewId şeklinde doğrudan erişilir.",
              "tags": ["view_binding", "button"]
            },
            {
              "questionId": 240006,
              "question": "EditText'ten girilen değer nasıl alınır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "editText.text",
                "editText.value",
                "editText.text.toString()",
                "editText.getValue()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "EditText'ten girilen değer editText.text.toString() ile String olarak alınır.",
              "tags": ["edittext", "get_text"]
            },
            {
              "questionId": 240007,
              "question": "AlertDialog gösterildiğinde hangi metot çağrılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "build()",
                "create()",
                "show()",
                "display()"
              ],
              "correctAnswerIndex": 2,
              "explanation": "AlertDialog'u ekranda göstermek için show() metodu çağrılır.",
              "tags": ["alertdialog", "show"]
            },
            {
              "questionId": 240008,
              "question": "Bir Button'u programatik olarak tıklanamaz hale getirmek için ne yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "button.visible = false",
                "button.isEnabled = false",
                "button.remove()",
                "button.delete()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "button.isEnabled = false yapıldığında button tıklanamaz (disabled) hale gelir ama görünür kalır.",
              "tags": ["button", "enabled"]
            },
            {
              "questionId": 240009,
              "question": "Toast gösterilirken uygulama kapanırsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hata verir",
                "Toast kaybolur",
                "Uygulama crash olur",
                "Toast sonsuza kadar kalır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Toast, Activity'ye bağlı olmadığı için uygulama kapansa bile belirlenen süre boyunca görünmeye devam edebilir, ancak Activity context kullanıldığında genellikle kaybolur.",
              "tags": ["toast", "lifecycle"]
            },
            {
              "questionId": 240010,
              "question": "Modern Android uygulamalarında bilgilendirme mesajı göstermek için hangisi önerilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "AlertDialog",
                "Toast",
                "Snackbar",
                "Notification"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Modern Android uygulamalarında Material Design'a uygun ve daha etkileşimli olduğu için Snackbar önerilir. Toast hala kullanılsa da Snackbar daha kullanıcı dostudur.",
              "tags": ["snackbar", "best_practice"]
            }
          ]
        },
        {
          "sectionId": 2500,
          "sectionTitle": "Intent & Veri Aktarımı",
          "sectionDescription": "Activity’ler arası geçiş ve veri aktarımı için kullanılan Intent yapıları",
          "order": 5,
          "topics": [
            {
              "topicId": 2501,
              "title": "Explicit Intent",
              "summary": "Explicit Intent, hangi Activity’nin açılacağını açıkça belirttiğimiz intent türüdür. Uygulama içindeki Activity geçişlerinde en sık kullanılan yöntemdir.",
              "content": "## Explicit Intent\n\nExplicit Intent, hedef Activity'nin doğrudan belirtildiği intent türüdür.\n\nGenellikle aynı uygulama içerisindeki ekranlar arasında geçiş yapmak için kullanılır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Explicit Intent Kullanımı",
                  "code": "val intent = Intent(this, DetailActivity::class.java)\nstartActivity(intent)",
                  "explanation": "MainActivity'den DetailActivity'e geçiş."
                }
              ],
              "keyPoints": [
                "Hedef Activity açıkça belirtilir",
                "Uygulama içi geçişlerde kullanılır",
                "En yaygın intent türüdür"
              ],
              "questions": [
                {
                  "questionId": 250101,
                  "question": "Explicit Intent ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Hedef Activity belirsizdir",
                    "Hedef Activity açıkça belirtilir",
                    "Sadece sistem uygulamaları için kullanılır",
                    "Veri aktarımı yapılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Explicit Intent, hedef Activity'nin doğrudan belirtildiği intent türüdür.",
                  "tags": ["intent", "explicit"]
                },
                {
                  "questionId": 250102,
                  "question": "Explicit Intent hangi durumlarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece dış uygulamalara geçiş",
                    "Uygulama içi Activity geçişleri",
                    "Sadece servis başlatma",
                    "Sadece broadcast gönderme"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Explicit Intent, genellikle aynı uygulama içerisindeki Activity'ler arasında geçiş yapmak için kullanılır.",
                  "tags": ["intent", "explicit", "usage"]
                },
                {
                  "questionId": 250103,
                  "question": "Aşağıdaki kodda hangi Activity açılır?",
                  "questionType": "multiple_choice",
                  "code": "val intent = Intent(this, DetailActivity::class.java)\nstartActivity(intent)",
                  "difficulty": "easy",
                  "options": [
                    "MainActivity",
                    "DetailActivity",
                    "Sistem seçer",
                    "Hiçbiri açılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kod, DetailActivity'yi açıkça belirttiği için DetailActivity açılır.",
                  "tags": ["intent", "explicit", "startactivity"]
                },
                {
                  "questionId": 250104,
                  "question": "Explicit Intent oluşturmak için hangi parametre gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece action",
                    "Context ve hedef Activity sınıfı",
                    "Sadece data",
                    "Sadece flag"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Explicit Intent oluşturmak için Context (this) ve hedef Activity'nin sınıfı (DetailActivity::class.java) gereklidir.",
                  "tags": ["intent", "explicit", "parameters"]
                }
              ]
            },
            {
              "topicId": 2502,
              "title": "Implicit Intent",
              "summary": "Implicit Intent, hangi uygulamanın açılacağını belirtmeden, yapılmak istenen işlemi tanımlar. Sistem, bu isteği karşılayabilecek uygulamayı kullanıcıya sunar.",
              "content": "## Implicit Intent\n\nImplicit Intent, belirli bir aksiyon ve veri ile çalışır.\n\nTelefon araması, tarayıcı açma veya paylaşım işlemlerinde sıkça kullanılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Implicit Intent Örneği",
                  "code": "val intent = Intent(Intent.ACTION_VIEW)\nintent.data = Uri.parse(\"https://www.google.com\")\nstartActivity(intent)",
                  "explanation": "Tarayıcı açmak için implicit intent kullanımı."
                }
              ],
              "keyPoints": [
                "Hedef uygulama belirtilmez",
                "Aksiyon ve data ile çalışır",
                "Sistem uygun uygulamayı seçer"
              ],
              "questions": [
                {
                  "questionId": 250201,
                  "question": "Implicit Intent ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Hedef Activity açıkça belirtilir",
                    "Yapılmak istenen işlem tanımlanır, sistem uygun uygulamayı seçer",
                    "Sadece aynı uygulama içinde kullanılır",
                    "Veri aktarımı yapılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Implicit Intent, hangi uygulamanın açılacağını belirtmeden, yapılmak istenen işlemi (action) tanımlar. Sistem uygun uygulamayı kullanıcıya sunar.",
                  "tags": ["intent", "implicit"]
                },
                {
                  "questionId": 250202,
                  "question": "Implicit Intent hangi durumlarda kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece kendi uygulamam içinde",
                    "Telefon araması, tarayıcı açma, paylaşım gibi sistem aksiyonlarında",
                    "Sadece veritabanı işlemlerinde",
                    "Sadece animasyon göstermede"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Implicit Intent, telefon araması, tarayıcı açma, e-posta gönderme veya paylaşım gibi sistem seviyesi aksiyonlar için kullanılır.",
                  "tags": ["intent", "implicit", "usage"]
                },
                {
                  "questionId": 250203,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val intent = Intent(Intent.ACTION_VIEW)\nintent.data = Uri.parse(\"https://www.google.com\")\nstartActivity(intent)",
                  "difficulty": "medium",
                  "options": [
                    "Google uygulamasını açar",
                    "Tarayıcıda Google'ı açar",
                    "E-posta gönderir",
                    "Telefon açar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ACTION_VIEW action'ı ve URL data'sı ile tarayıcı açılır ve Google web sitesi gösterilir.",
                  "tags": ["intent", "implicit", "action_view"]
                },
                {
                  "questionId": 250204,
                  "question": "Implicit Intent'te action ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hedef Activity'yi belirtir",
                    "Yapılacak işlemi tanımlar",
                    "Sadece veri taşır",
                    "Layout belirler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Action, yapılacak işlemi tanımlar (ACTION_VIEW, ACTION_DIAL, ACTION_SEND vb.). Sistem bu action'ı işleyebilecek uygulamaları bulur.",
                  "tags": ["intent", "implicit", "action"]
                },
                {
                  "questionId": 250205,
                  "question": "Bir URL'yi paylaşmak için hangi action kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "ACTION_VIEW",
                    "ACTION_DIAL",
                    "ACTION_SEND",
                    "ACTION_CALL"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "ACTION_SEND, metin, URL veya dosya paylaşmak için kullanılır. Kullanıcı paylaşım yapacağı uygulamayı seçebilir.",
                  "tags": ["intent", "implicit", "action_send"]
                }
              ]
            },
            {
              "topicId": 2503,
              "title": "Bundle",
              "summary": "Bundle, key-value mantığıyla çalışan ve Activity’ler arasında veri taşımak için kullanılan bir yapıdır. Intent ile birlikte kullanılır.",
              "content": "## Bundle\n\nBundle, küçük ve basit verilerin taşınması için idealdir.\n\nVeriler key-value şeklinde saklanır.",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Bundle ile Veri Gönderme",
                  "code": "val bundle = Bundle()\nbundle.putString(\"username\", \"Ahmet\")\nintent.putExtras(bundle)\nstartActivity(intent)",
                  "explanation": "Bundle kullanarak veri aktarımı."
                }
              ],
              "keyPoints": [
                "Key-value mantığı ile çalışır",
                "Intent ile birlikte kullanılır",
                "Küçük veriler için uygundur"
              ],
              "questions": [
                {
                  "questionId": 250301,
                  "question": "Bundle ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Layout oluşturmak",
                    "Activity'ler arasında veri taşımak",
                    "Veritabanı işlemleri",
                    "Network isteği"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bundle, key-value mantığıyla çalışan ve Activity'ler arasında veri taşımak için kullanılan bir yapıdır.",
                  "tags": ["bundle", "data_transfer"]
                },
                {
                  "questionId": 250302,
                  "question": "Bundle nasıl çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Array mantığıyla",
                    "Key-value mantığıyla",
                    "Stack mantığıyla",
                    "Queue mantığıyla"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bundle, key-value (anahtar-değer) çifti olarak veri saklar. putString(\"key\", \"value\") şeklinde kullanılır.",
                  "tags": ["bundle", "key_value"]
                },
                {
                  "questionId": 250303,
                  "question": "Aşağıdaki kodda \"username\" verisinin değeri nedir?",
                  "questionType": "multiple_choice",
                  "code": "val bundle = Bundle()\nbundle.putString(\"username\", \"Ahmet\")\nintent.putExtras(bundle)",
                  "difficulty": "easy",
                  "options": [
                    "bundle",
                    "Ahmet",
                    "username",
                    "intent"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "putString(\"username\", \"Ahmet\") ile \"username\" key'ine \"Ahmet\" değeri atanmıştır.",
                  "tags": ["bundle", "putstring"]
                }
              ]
            },
            {
              "topicId": 2504,
              "title": "Serializable / Parcelable",
              "summary": "Serializable ve Parcelable, karmaşık nesneleri Activity’ler arasında taşımak için kullanılan yöntemlerdir. Parcelable, Android için daha performanslı bir çözümdür.",
              "content": "## Serializable / Parcelable\n\nSerializable Java tabanlıdır ve kullanımı kolaydır.\n\nParcelable ise Android’e özeldir ve daha hızlıdır.\n\nBüyük veri transferlerinde Parcelable tercih edilmelidir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Parcelable Kullanımı",
                  "code": "@Parcelize\ndata class User(val name: String, val age: Int) : Parcelable",
                  "explanation": "Parcelable veri sınıfı tanımı."
                }
              ],
              "keyPoints": [
                "Serializable kullanımı kolaydır",
                "Parcelable daha performanslıdır",
                "Karmaşık nesneler için kullanılır",
                "Android projelerinde Parcelable önerilir"
              ],
              "questions": [
                {
                  "questionId": 250401,
                  "question": "Serializable ve Parcelable ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Layout oluşturmak",
                    "Karmaşık nesneleri Activity'ler arasında taşımak",
                    "Veritabanı işlemleri",
                    "Animasyon oluşturmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Serializable ve Parcelable, karmaşık nesneleri (data class, model) Activity'ler arasında taşımak için kullanılır.",
                  "tags": ["serializable", "parcelable", "data_transfer"]
                },
                {
                  "questionId": 250402,
                  "question": "Serializable ve Parcelable arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Serializable Java tabanlı, Parcelable Android'e özel ve daha hızlı",
                    "Parcelable daha yavaştır",
                    "Serializable sadece String taşır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Serializable Java tabanlıdır ve kullanımı kolaydır. Parcelable ise Android'e özeldir ve daha performanslıdır.",
                  "tags": ["serializable", "parcelable", "difference"]
                },
                {
                  "questionId": 250403,
                  "question": "Android projelerinde hangi yöntem önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Serializable",
                    "Parcelable",
                    "İkisi de aynı",
                    "Hiçbiri kullanılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android projelerinde performans avantajı nedeniyle Parcelable önerilir.",
                  "tags": ["parcelable", "best_practice"]
                },
                {
                  "questionId": 250404,
                  "question": "Aşağıdaki Parcelable kullanımında @Parcelize ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": "@Parcelize\ndata class User(val name: String, val age: Int) : Parcelable",
                  "difficulty": "hard",
                  "options": [
                    "Sadece görsel amaçlı",
                    "Parcelable implementasyonunu otomatik oluşturur",
                    "Veritabanı işlemleri için",
                    "Network isteği için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kotlin'de @Parcelize annotation'ı, Parcelable implementasyonunu otomatik olarak oluşturur, böylece manuel kod yazmaya gerek kalmaz.",
                  "tags": ["parcelable", "parcelize", "kotlin"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 250001,
              "question": "Explicit ve Implicit Intent arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "Explicit hedef Activity belirtir, Implicit action tanımlar",
                "Implicit daha hızlıdır",
                "Explicit sadece sistem uygulamaları için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Explicit Intent hedef Activity'yi açıkça belirtir, Implicit Intent ise yapılacak işlemi (action) tanımlar ve sistem uygun uygulamayı seçer.",
              "tags": ["intent", "explicit", "implicit"]
            },
            {
              "questionId": 250002,
              "question": "Intent ile basit bir String veri göndermek için hangi metot kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "intent.setData()",
                "intent.putExtra()",
                "intent.sendData()",
                "intent.addString()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent ile basit veri göndermek için intent.putExtra(\"key\", \"value\") metodu kullanılır.",
              "tags": ["intent", "putextra"]
            },
            {
              "questionId": 250003,
              "question": "Karşı Activity'de Intent'ten veri nasıl alınır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "intent.getData()",
                "intent.getStringExtra(\"key\")",
                "intent.receive()",
                "intent.fetch()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Karşı Activity'de Intent'ten veri almak için intent.getStringExtra(\"key\"), intent.getIntExtra() gibi metotlar kullanılır.",
              "tags": ["intent", "getextra"]
            },
            {
              "questionId": 250004,
              "question": "Telefon numarası çevirmek (arama ekranını açmak) için hangi action kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "ACTION_CALL",
                "ACTION_DIAL",
                "ACTION_PHONE",
                "ACTION_VIEW"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ACTION_DIAL, telefon arama ekranını açar ve numara gösterir ama izin gerektirmez. ACTION_CALL direkt arar ve izin gerektirir.",
              "tags": ["intent", "implicit", "action_dial"]
            },
            {
              "questionId": 250005,
              "question": "Bundle yerine doğrudan intent.putExtra() kullanmanın avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha hızlıdır",
                "Daha basit ve kısa kod yazılır",
                "Daha fazla veri taşır",
                "Daha güvenlidir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "intent.putExtra() doğrudan kullanıldığında Bundle oluşturmaya gerek kalmaz, kod daha basit ve kısa olur.",
              "tags": ["intent", "bundle", "putextra"]
            },
            {
              "questionId": 250006,
              "question": "Parcelable yerine Serializable kullanmanın dezavantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Kullanımı zordur",
                "Performans açısından daha yavaştır",
                "Sadece String taşır",
                "Android'de çalışmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Serializable, reflection kullandığı için Parcelable'a göre daha yavaştır. Android'de büyük veri transferlerinde Parcelable tercih edilmelidir.",
              "tags": ["serializable", "parcelable", "performance"]
            },
            {
              "questionId": 250007,
              "question": "Bir resim paylaşmak için hangi intent action ve type kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "ACTION_VIEW, text/plain",
                "ACTION_SEND, image/*",
                "ACTION_DIAL, image/png",
                "ACTION_CALL, text/html"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Resim paylaşmak için ACTION_SEND action'ı ve type olarak \"image/*\" veya \"image/png\" kullanılır.",
              "tags": ["intent", "implicit", "share_image"]
            },
            {
              "questionId": 250008,
              "question": "Intent flag'leri ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece veri taşır",
                "Activity'nin nasıl başlatılacağını kontrol eder",
                "Layout belirler",
                "Renk ayarlar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent flag'leri (FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_CLEAR_TOP vb.), Activity'nin nasıl başlatılacağını ve back stack'in nasıl yönetileceğini kontrol eder.",
              "tags": ["intent", "flags"]
            },
            {
              "questionId": 250009,
              "question": "MainActivity'den DetailActivity'e geçerken hem Intent hem de finish() çağrılırsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hata verir",
                "DetailActivity açılır ve MainActivity yok olur",
                "Hiçbir şey olmaz",
                "Uygulama kapanır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "startActivity(intent) ile DetailActivity açılır, finish() ile MainActivity yok edilir. Back tuşuna basıldığında MainActivity'e dönülemez.",
              "tags": ["intent", "finish"]
            },
            {
              "questionId": 250010,
              "question": "Intent.createChooser() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Activity oluşturur",
                "Kullanıcıya hangi uygulamayı kullanacağını seçme şansı verir",
                "Veritabanı oluşturur",
                "Layout oluşturur"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Intent.createChooser(), implicit intent için her seferinde kullanıcıya hangi uygulamayı kullanacağını seçme şansı verir (varsayılan uygulama ayarlanmış olsa bile).",
              "tags": ["intent", "chooser"]
            }
          ]
        },
        {
          "sectionId": 2600,
          "sectionTitle": "Veri Saklama",
          "sectionDescription": "Android uygulamalarda kullanıcı verilerinin yerel olarak saklanması yöntemleri",
          "order": 6,
          "topics": [
            {
              "topicId": 2601,
              "title": "SharedPreferences",
              "summary": "SharedPreferences, küçük ve basit verileri anahtar-değer (key-value) mantığıyla saklamak için kullanılan hafif bir veri saklama yöntemidir. Genellikle kullanıcı ayarları ve basit konfigürasyonlar için tercih edilir.",
              "content": "## SharedPreferences\n\nSharedPreferences, kalıcı veri saklama sağlar.\n\nUygulama kapatılsa bile veriler korunur.\n\nBoolean, Int, Float, Long ve String gibi basit veri tiplerini destekler.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "SharedPreferences Kullanımı",
                  "code": "val prefs = getSharedPreferences(\"MyPrefs\", Context.MODE_PRIVATE)\nprefs.edit().putString(\"username\", \"Ahmet\").apply()",
                  "explanation": "SharedPreferences ile veri kaydetme."
                }
              ],
              "keyPoints": [
                "Key-value yapısı kullanır",
                "Küçük veriler için uygundur",
                "Kalıcı veri saklar",
                "Basit ve hızlıdır"
              ],
              "questions": [
                {
                  "questionId": 260101,
                  "question": "SharedPreferences ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Büyük dosyaları saklamak",
                    "Küçük ve basit verileri key-value mantığıyla saklamak",
                    "Veritabanı oluşturmak",
                    "Network isteği yapmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SharedPreferences, küçük ve basit verileri anahtar-değer (key-value) mantığıyla saklamak için kullanılır.",
                  "tags": ["sharedpreferences", "temel"]
                },
                {
                  "questionId": 260102,
                  "question": "SharedPreferences hangi veri tiplerini destekler?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece String",
                    "Boolean, Int, Float, Long ve String",
                    "Sadece Int",
                    "Tüm nesne türleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SharedPreferences, Boolean, Int, Float, Long ve String gibi basit veri tiplerini destekler.",
                  "tags": ["sharedpreferences", "data_types"]
                },
                {
                  "questionId": 260103,
                  "question": "Aşağıdaki kodda \"username\" anahtarına hangi değer kaydedilir?",
                  "questionType": "multiple_choice",
                  "code": "val prefs = getSharedPreferences(\"MyPrefs\", Context.MODE_PRIVATE)\nprefs.edit().putString(\"username\", \"Ahmet\").apply()",
                  "difficulty": "easy",
                  "options": [
                    "MyPrefs",
                    "Ahmet",
                    "username",
                    "prefs"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "putString(\"username\", \"Ahmet\") ile \"username\" anahtarına \"Ahmet\" değeri kaydedilir.",
                  "tags": ["sharedpreferences", "putstring"]
                },
                {
                  "questionId": 260104,
                  "question": "SharedPreferences'ta kayıtlı veri uygulama kapatıldığında ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Silinir",
                    "Korunur, kalıcıdır",
                    "Sadece 1 gün saklanır",
                    "Rastgele olarak silinir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SharedPreferences kalıcı veri saklar. Uygulama kapatılsa bile veriler korunur.",
                  "tags": ["sharedpreferences", "persistence"]
                },
                {
                  "questionId": 260105,
                  "question": "SharedPreferences'tan veri okumak için hangi metot kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "prefs.getString(\"key\", defaultValue)",
                    "prefs.readString(\"key\")",
                    "prefs.fetch(\"key\")",
                    "prefs.load(\"key\")"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "SharedPreferences'tan veri okumak için getString(\"key\", defaultValue), getInt(), getBoolean() gibi metotlar kullanılır. İkinci parametre default değerdir.",
                  "tags": ["sharedpreferences", "getstring"]
                }
              ]
            },
            {
              "topicId": 2602,
              "title": "Internal Storage",
              "summary": "Internal Storage, uygulamaya özel dosyaların cihazın dahili hafızasında saklanmasını sağlar. Bu veriler yalnızca ilgili uygulama tarafından erişilebilir.",
              "content": "## Internal Storage\n\nInternal Storage güvenli bir veri saklama yöntemidir.\n\nDosyalar uygulamaya özeldir ve başka uygulamalar erişemez.\n\nUygulama silindiğinde veriler de silinir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Internal Storage Dosya Yazma",
                  "code": "openFileOutput(\"data.txt\", Context.MODE_PRIVATE).use {\n    it.write(\"Merhaba\".toByteArray())\n}",
                  "explanation": "Internal Storage'a dosya yazma örneği."
                }
              ],
              "keyPoints": [
                "Uygulamaya özeldir",
                "Güvenlidir",
                "Dosya bazlı veri saklar",
                "Uygulama silinince veriler silinir"
              ],
              "questions": [
                {
                  "questionId": 260201,
                  "question": "Internal Storage ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece resim saklamak",
                    "Uygulamaya özel dosyaları güvenli şekilde saklamak",
                    "Sadece network isteği",
                    "Sadece SharedPreferences"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Internal Storage, uygulamaya özel dosyaların cihazın dahili hafızasında güvenli şekilde saklanmasını sağlar.",
                  "tags": ["internal_storage", "temel"]
                },
                {
                  "questionId": 260202,
                  "question": "Internal Storage'da saklanan verilere başka uygulamalar erişebilir mi?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet, herkes erişebilir",
                    "Hayır, sadece ilgili uygulama erişebilir",
                    "Sadece sistem uygulamaları erişebilir",
                    "Kullanıcı izni ile erişilebilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Internal Storage'da saklanan dosyalar uygulamaya özeldir ve başka uygulamalar erişemez. Bu güvenli bir veri saklama yöntemidir.",
                  "tags": ["internal_storage", "security"]
                },
                {
                  "questionId": 260203,
                  "question": "Uygulama silindiğinde Internal Storage'daki veriler ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Korunur",
                    "Cihazda kalır",
                    "Otomatik olarak silinir",
                    "Cloud'a yüklenir"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Uygulama silindiğinde Internal Storage'daki tüm veriler de otomatik olarak silinir.",
                  "tags": ["internal_storage", "lifecycle"]
                },
                {
                  "questionId": 260204,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "openFileOutput(\"data.txt\", Context.MODE_PRIVATE).use {\n    it.write(\"Merhaba\".toByteArray())\n}",
                  "difficulty": "medium",
                  "options": [
                    "External Storage'a dosya yazar",
                    "Internal Storage'a data.txt dosyası oluşturur ve \"Merhaba\" yazar",
                    "Veritabanına veri ekler",
                    "Network'e veri gönderir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "openFileOutput ile Internal Storage'a data.txt dosyası oluşturulur ve \"Merhaba\" metni yazılır.",
                  "tags": ["internal_storage", "file_write"]
                }
              ]
            },
            {
              "topicId": 2603,
              "title": "External Storage (Kavramsal)",
              "summary": "External Storage, cihazın ortak depolama alanını kullanarak veri saklamayı ifade eder. Diğer uygulamalar ve kullanıcı tarafından erişilebilir olduğu için güvenlik açısından dikkatli kullanılmalıdır.",
              "content": "## External Storage\n\nExternal Storage genellikle medya dosyaları için kullanılır.\n\nAndroid 10 ve sonrası sürümlerde scoped storage kavramı ile erişim kısıtlanmıştır.\n\nİzin (permission) gerektirebilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [],
              "keyPoints": [
                "Ortak depolama alanıdır",
                "Diğer uygulamalar erişebilir",
                "Permission gerektirebilir",
                "Medya dosyaları için uygundur"
              ],
              "questions": [
                {
                  "questionId": 260301,
                  "question": "External Storage ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece uygulamaya özel alan",
                    "Cihazın ortak depolama alanı",
                    "Sadece cloud storage",
                    "Sadece SharedPreferences"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "External Storage, cihazın ortak depolama alanını kullanarak veri saklamayı ifade eder.",
                  "tags": ["external_storage", "temel"]
                },
                {
                  "questionId": 260302,
                  "question": "External Storage genellikle hangi tür dosyalar için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece şifreler",
                    "Medya dosyaları (resim, video, müzik)",
                    "Sadece kod dosyaları",
                    "Sadece veritabanı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "External Storage genellikle medya dosyaları (resim, video, müzik) için kullanılır çünkü bu dosyalara diğer uygulamalar da erişebilir.",
                  "tags": ["external_storage", "media"]
                },
                {
                  "questionId": 260303,
                  "question": "Android 10 ve sonrası sürümlerde External Storage erişimi nasıl değişti?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Tamamen kaldırıldı",
                    "Scoped storage kavramı ile erişim kısıtlandı",
                    "Hiçbir değişiklik olmadı",
                    "Sadece root cihazlar erişebilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android 10 ve sonrası sürümlerde scoped storage kavramı ile External Storage erişimi kısıtlanmış ve daha güvenli hale getirilmiştir.",
                  "tags": ["external_storage", "scoped_storage"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 260001,
              "question": "Kullanıcı ayarlarını (tema, dil tercihi) saklamak için hangi yöntem en uygundur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Internal Storage",
                "External Storage",
                "SharedPreferences",
                "Veritabanı"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Kullanıcı ayarları gibi küçük ve basit veriler için SharedPreferences en uygun yöntemdir.",
              "tags": ["sharedpreferences", "use_case"]
            },
            {
              "questionId": 260002,
              "question": "Internal Storage ve External Storage arasındaki temel fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "Internal uygulamaya özel, External ortak alan",
                "Internal daha yavaştır",
                "External daha güvenlidir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Internal Storage uygulamaya özeldir ve güvenlidir. External Storage ise ortak depolama alanıdır ve diğer uygulamalar tarafından erişilebilir.",
              "tags": ["internal_storage", "external_storage", "difference"]
            },
            {
              "questionId": 260003,
              "question": "SharedPreferences ile büyük bir liste veya karmaşık nesne saklamak uygun mudur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, en uygun yöntem",
                "Hayır, SharedPreferences küçük ve basit veriler içindir",
                "Sadece String liste için uygun",
                "Fark etmez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SharedPreferences küçük ve basit veriler için tasarlanmıştır. Büyük listeler veya karmaşık nesneler için veritabanı (Room) veya dosya sistemi kullanılmalıdır.",
              "tags": ["sharedpreferences", "limitation"]
            },
            {
              "questionId": 260004,
              "question": "SharedPreferences'a veri yazarken commit() ve apply() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "commit() senkron, apply() asenkron çalışır",
                "apply() daha yavaştır",
                "commit() kullanımdan kaldırıldı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "commit() senkron çalışır ve boolean döner, apply() asenkron çalışır ve daha hızlıdır. Genellikle apply() tercih edilir.",
              "tags": ["sharedpreferences", "commit_apply"]
            },
            {
              "questionId": 260005,
              "question": "Hassas verileri (şifre, token) saklamak için hangi yöntem en güvenlidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "SharedPreferences (düz metin)",
                "External Storage",
                "EncryptedSharedPreferences veya Keystore",
                "Sadece RAM'de tutmak"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Hassas veriler için EncryptedSharedPreferences veya Android Keystore kullanılmalıdır. Düz SharedPreferences güvenli değildir.",
              "tags": ["security", "encrypted"]
            },
            {
              "questionId": 260006,
              "question": "Internal Storage'da saklanan dosyaları kullanıcı manuel olarak görebilir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, dosya yöneticisinden kolayca",
                "Hayır, normal koşullarda erişemez",
                "Sadece root cihazlarda",
                "Sadece USB ile bağlanınca"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Internal Storage uygulamaya özeldir ve normal koşullarda kullanıcı manuel olarak erişemez. Root cihazlarda veya özel araçlarla erişilebilir.",
              "tags": ["internal_storage", "access"]
            },
            {
              "questionId": 260007,
              "question": "SharedPreferences dosyası cihazda nerede saklanır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "External Storage",
                "SD Kart",
                "Internal Storage (app data klasörü)",
                "Cloud"
              ],
              "correctAnswerIndex": 2,
              "explanation": "SharedPreferences dosyası, Internal Storage'da uygulamanın data klasöründe XML dosyası olarak saklanır (/data/data/paket_adi/shared_prefs/).",
              "tags": ["sharedpreferences", "location"]
            },
            {
              "questionId": 260008,
              "question": "Context.MODE_PRIVATE ne anlama gelir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Herkes erişebilir",
                "Sadece ilgili uygulama erişebilir",
                "Sadece sistem erişebilir",
                "Sadece internet üzerinden erişilebilir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Context.MODE_PRIVATE, dosyanın veya SharedPreferences'ın sadece ilgili uygulama tarafından erişilebilir olduğunu belirtir.",
              "tags": ["mode_private", "context"]
            },
            {
              "questionId": 260009,
              "question": "External Storage'a erişim için izin (permission) gerekli midir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hayır, hiçbir zaman",
                "Evet, genellikle READ/WRITE_EXTERNAL_STORAGE",
                "Sadece resim için",
                "Sadece video için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "External Storage'a erişim için genellikle READ_EXTERNAL_STORAGE ve WRITE_EXTERNAL_STORAGE izinleri gereklidir. Android 10+'da scoped storage ile bazı durumlarda izin gerekmez.",
              "tags": ["external_storage", "permission"]
            },
            {
              "questionId": 260010,
              "question": "Hangi veri saklama yöntemi en hızlıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Veritabanı",
                "External Storage",
                "SharedPreferences (küçük veriler için)",
                "Network isteği"
              ],
              "correctAnswerIndex": 2,
              "explanation": "Küçük ve basit veriler için SharedPreferences en hızlı yöntemdir çünkü hafiftir ve doğrudan bellekte çalışır.",
              "tags": ["performance", "comparison"]
            }
          ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 290001,
          "question": "Android uygulaması geliştirmek için hangi programlama dilleri kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Swift ve Objective-C",
            "Kotlin ve Java",
            "Python ve Ruby",
            "C# ve VB.NET"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Android uygulamaları Kotlin ve Java ile geliştirilir. Google, resmi olarak Kotlin'i tercih etmektedir.",
          "tags": ["android", "kotlin", "java"]
        },
        {
          "questionId": 290002,
          "question": "Activity yaşam döngüsünde doğru sıralama hangisidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "onCreate → onResume → onStart",
            "onCreate → onStart → onResume",
            "onStart → onCreate → onResume",
            "onResume → onStart → onCreate"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Activity yaşam döngüsü onCreate() → onStart() → onResume() sırasıyla çalışır.",
          "tags": ["lifecycle", "activity"]
        },
        {
          "questionId": 290003,
          "question": "findViewById yerine hangi modern yapı kullanılmalıdır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "View Binding",
            "Context",
            "Intent",
            "Bundle"
          ],
          "correctAnswerIndex": 0,
          "explanation": "View Binding, findViewById'a göre daha güvenli (null safety) ve derleme zamanında hata yakalar.",
          "tags": ["view_binding", "best_practice"]
        },
        {
          "questionId": 290004,
          "question": "LinearLayout ve ConstraintLayout arasındaki performans farkı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "LinearLayout daha hızlıdır",
            "ConstraintLayout nested layout ihtiyacını azaltarak daha performanslıdır",
            "Performans farkı yoktur",
            "LinearLayout her zaman önerilir"
          ],
          "correctAnswerIndex": 1,
          "explanation": "ConstraintLayout, karmaşık UI'ları tek layout içinde oluşturarak nested layout kullanımını ve performans kaybını azaltır.",
          "tags": ["layout", "performance", "constraintlayout"]
        },
        {
          "questionId": 290005,
          "question": "Context nedir ve ne için kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece layout dosyası",
            "Uygulamanın mevcut durumunu temsil eden ve kaynaklara erişim sağlayan ortam bilgisi",
            "Sadece veritabanı bağlantısı",
            "Sadece network yönetimi"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Context, uygulamanın mevcut durumunu temsil eder ve kaynaklara erişim, Activity başlatma, sistem servisleri kullanma gibi işlemler için gereklidir.",
          "tags": ["context", "temel"]
        },
        {
          "questionId": 290006,
          "question": "Explicit Intent ve Implicit Intent arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Hiçbir fark yok",
            "Explicit hedef Activity'yi belirtir, Implicit action tanımlar",
            "Implicit daha hızlıdır",
            "Explicit kullanımdan kalkmıştır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Explicit Intent hedef Activity'yi doğrudan belirtir (uygulama içi geçişler), Implicit Intent ise yapılacak işlemi tanımlar ve sistem uygun uygulamayı seçer (tarayıcı açma, paylaşım vb.).",
          "tags": ["intent", "explicit", "implicit"]
        },
        {
          "questionId": 290007,
          "question": "SharedPreferences hangi tür veriler için en uygun veri saklama yöntemidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Büyük dosyalar",
            "Karmaşık nesneler",
            "Kullanıcı ayarları gibi küçük key-value verileri",
            "Video ve resim dosyaları"
          ],
          "correctAnswerIndex": 2,
          "explanation": "SharedPreferences, kullanıcı ayarları, tercihler gibi küçük ve basit key-value verilerini saklamak için idealdir.",
          "tags": ["sharedpreferences", "storage"]
        },
        {
          "questionId": 290008,
          "question": "onPause() ve onStop() arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiçbir fark yok",
            "onPause()'da Activity kısmen görünür olabilir, onStop()'ta tamamen görünmez",
            "onStop() daha önce çağrılır",
            "onPause() sadece ilk açılışta çalışır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "onPause()'da Activity hala kısmen görünür olabilir (örneğin dialog üstte), onStop()'ta ise Activity tamamen görünmez hale gelir.",
          "tags": ["lifecycle", "onpause", "onstop"]
        },
        {
          "questionId": 290009,
          "question": "Activity'ler arası karmaşık nesne (model class) göndermek için hangi yöntem önerilir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece String olarak",
            "Parcelable veya Serializable",
            "SharedPreferences",
            "Doğrudan gönderilemez"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Karmaşık nesneleri Intent ile göndermek için Parcelable (Android'de önerilen, daha hızlı) veya Serializable (kullanımı kolay) kullanılır.",
          "tags": ["intent", "parcelable", "serializable"]
        },
        {
          "questionId": 290010,
          "question": "AlertDialog ne için kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Activity başlatmak",
            "Kullanıcıdan onay veya seçim almak",
            "Veritabanı işlemleri",
            "Network isteği"
          ],
          "correctAnswerIndex": 1,
          "explanation": "AlertDialog, kullanıcıya bilgi vermek veya kritik aksiyonlar öncesinde onay almak için kullanılan bir dialog penceresidir.",
          "tags": ["alertdialog", "ui"]
        },
        {
          "questionId": 290011,
          "question": "Android'de UI tanımlamak için hangi işaretleme dili kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "HTML",
            "JSON",
            "XML",
            "YAML"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Android'de kullanıcı arayüzü genellikle XML ile tanımlanır. Bu, tasarım ve iş mantığını ayırarak kodun daha okunabilir olmasını sağlar.",
          "tags": ["xml", "ui"]
        },
        {
          "questionId": 290012,
          "question": "Internal Storage ve External Storage arasındaki güvenlik farkı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "External Storage daha güvenlidir",
            "Internal Storage uygulamaya özeldir ve daha güvenlidir",
            "İkisi de aynı güvenlik seviyesindedir",
            "Hiçbiri güvenli değildir"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Internal Storage uygulamaya özeldir ve diğer uygulamalar erişemez, dolayısıyla daha güvenlidir. External Storage ortak alandır ve diğer uygulamalar erişebilir.",
          "tags": ["storage", "security"]
        },
        {
          "questionId": 290013,
          "question": "Configuration change (ekran döndürme) durumunda Activity varsayılan olarak ne yapar?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiçbir şey olmaz",
            "Sadece layout değişir",
            "Activity yok edilip yeniden oluşturulur (onCreate çağrılır)",
            "Sadece onPause() çağrılır"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Configuration change (ekran döndürme gibi) durumunda Activity varsayılan olarak yok edilir (onDestroy) ve yeniden oluşturulur (onCreate). Bu durum ViewModel ve savedInstanceState ile yönetilebilir.",
          "tags": ["lifecycle", "configuration_change"]
        },
        {
          "questionId": 290014,
          "question": "Toast ve Snackbar arasındaki temel fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Hiçbir fark yok",
            "Snackbar aksiyon butonu alabilir ve daha etkileşimlidir",
            "Toast daha modern bir yapıdır",
            "Snackbar daha yavaştır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Snackbar, Toast'a göre daha modern ve etkileşimlidir. Aksiyon butonu eklenebilir (örneğin Geri Al) ve Material Design'a daha uygundur.",
          "tags": ["toast", "snackbar", "ui"]
        },
        {
          "questionId": 290015,
          "question": "wrap_content ve match_parent arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Hiçbir fark yok",
            "wrap_content içeriği kadar, match_parent parent'ın boyutu kadar",
            "match_parent daha küçüktür",
            "wrap_content sadece TextView'de kullanılır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "wrap_content, view'in boyutunu içeriği kadar yapar. match_parent ise view'i parent'ın (üst container) boyutu kadar yapar.",
          "tags": ["layout", "layout_params"]
        },
        {
          "questionId": 290016,
          "question": "AndroidManifest.xml dosyasının amacı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece Activity'leri listeler",
            "Uygulama yapılandırması, bileşenler ve izinleri tanımlar",
            "Sadece layout dosyalarını saklar",
            "Sadece veritabanı şeması içerir"
          ],
          "correctAnswerIndex": 1,
          "explanation": "AndroidManifest.xml, uygulamanın temel yapılandırmasını içerir: Activity'ler, Service'ler, Broadcast Receiver'lar, izinler (permissions), uygulama adı ve icon gibi bilgiler burada tanımlanır.",
          "tags": ["manifest", "configuration"]
        },
        {
          "questionId": 290017,
          "question": "EditText'te klavye türünü belirlemek için hangi özellik kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "android:text",
            "android:hint",
            "android:inputType",
            "android:keyboard"
          ],
          "correctAnswerIndex": 2,
          "explanation": "android:inputType ile klavye türü belirlenir (textPassword, number, email, phone vb.).",
          "tags": ["edittext", "inputtype"]
        },
        {
          "questionId": 290018,
          "question": "Hassas verileri (token, şifre) güvenli şekilde saklamak için hangi yöntem önerilir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Düz SharedPreferences",
            "External Storage",
            "EncryptedSharedPreferences veya Android Keystore",
            "Hiçbiri, saklanmamalı"
          ],
          "correctAnswerIndex": 2,
          "explanation": "Hassas veriler için EncryptedSharedPreferences (şifrelenmiş) veya Android Keystore kullanılmalıdır. Düz SharedPreferences veya dosya sisteminde saklamak güvenli değildir.",
          "tags": ["security", "encrypted", "keystore"]
        },
        {
          "questionId": 290019,
          "question": "Intent ile basit bir String verisi göndermek için hangi metot kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "intent.setData()",
            "intent.putExtra(\"key\", \"value\")",
            "intent.sendString()",
            "intent.addData()"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Intent ile basit veri göndermek için intent.putExtra(\"key\", \"value\") kullanılır. Karşı Activity'de intent.getStringExtra(\"key\") ile alınır.",
          "tags": ["intent", "data_transfer"]
        },
        {
          "questionId": 290020,
          "question": "Modern Android uygulamalarında hangi layout ve veri bağlama (binding) kombinasyonu önerilir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "LinearLayout + findViewById",
            "ConstraintLayout + View Binding",
            "RelativeLayout + findViewById",
            "FrameLayout + View Binding"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Modern Android geliştirmede ConstraintLayout (performans ve esneklik için) ve View Binding (güvenli view erişimi için) kombinasyonu önerilir.",
          "tags": ["best_practice", "modern_android", "constraintlayout", "view_binding"]
        }
      ]
    },
    {
      "categoryId": 3,
      "categoryTitle": "Android Orta - İleri Seviye",
      "categoryDescription": "Modern Android geliştirme teknikleri",
      "order": 3,
      "sections": [
        {
        "sectionId": 3100,
        "sectionTitle": "RecyclerView",
        "sectionDescription": "Liste ve grid yapılarında performanslı veri gösterimi için kullanılan RecyclerView bileşeninin detaylı incelenmesi",
        "order": 1,
        "topics": [
          {
            "topicId": 3101,
            "title": "RecyclerView Mantığı",
            "summary": "RecyclerView, büyük veri listelerini performanslı şekilde göstermek için kullanılan modern bir listeleme bileşenidir. Görünmeyen item'ları yeniden kullanarak (recycle) bellek ve performans avantajı sağlar.",
            "content": "## RecyclerView Mantığı\n\nRecyclerView, View recycling mantığı ile çalışır.\n\nEkranda görünmeyen item'lar yok edilmez, yeniden kullanılır.\n\nBu yapı özellikle uzun listelerde yüksek performans sağlar.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "RecyclerView Tanımı",
                "code": "val recyclerView = findViewById<RecyclerView>(R.id.recyclerView)\nrecyclerView.layoutManager = LinearLayoutManager(this)",
                "explanation": "RecyclerView için LayoutManager tanımlaması."
              }
            ],
            "keyPoints": [
              "View recycling kullanır",
              "Performanslıdır",
              "Büyük listeler için uygundur",
              "LayoutManager ile çalışır"
            ],
            "questions": [
              {
                "questionId": 311001,
                "question": "RecyclerView hangi problemi çözmek için tasarlanmıştır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Tek View göstermek",
                  "Animasyon eklemek",
                  "Büyük veri listelerini verimli göstermek",
                  "Fragment geçişi yapmak"
                ],
                "correctAnswerIndex": 2,
                "explanation": "RecyclerView, büyük veri listelerini minimum bellek ve yüksek performansla göstermek için geliştirilmiştir.",
                "tags": ["recyclerview", "temel"]
              },
              {
                "questionId": 311002,
                "question": "RecyclerView’da View’lar nasıl yeniden kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Yeni View oluşturarak",
                  "ViewHolder cache mekanizmasıyla",
                  "Fragment yeniden başlatılarak",
                  "LayoutInflater ile sürekli inflate ederek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "RecyclerView, ViewHolder’ları yeniden kullanarak performansı artırır.",
                "tags": ["recyclerview", "performance"]
              },
              {
                "questionId": 311003,
                "question": "RecyclerView’da LayoutManager neden zorunludur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Veri kaynağı belirlemek için",
                  "Item click yönetimi için",
                  "Item’ların ekranda nasıl yerleşeceğini belirlemek için",
                  "Lifecycle kontrolü için"
                ],
                "correctAnswerIndex": 2,
                "explanation": "LayoutManager olmadan RecyclerView item’ların nasıl yerleşeceğini bilemez.",
                "tags": ["layoutmanager", "recyclerview"]
              }
            ]
          },
          {
            "topicId": 3102,
            "title": "Adapter",
            "summary": "Adapter, RecyclerView ile veri kaynağı arasındaki bağlantıyı sağlar. Her bir item için hangi layout'un kullanılacağını ve verinin nasıl bağlanacağını belirler.",
            "content": "## Adapter\n\nAdapter, RecyclerView'ın kalbidir.\n\nVeri setini ViewHolder ile bağlar.\n\nonCreateViewHolder, onBindViewHolder ve getItemCount metotlarını içerir.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Adapter Yapısı",
                "code": "class MyAdapter(private val list: List<String>) : RecyclerView.Adapter<MyViewHolder>() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)\n        return MyViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        holder.bind(list[position])\n    }\n\n    override fun getItemCount() = list.size\n}",
                "explanation": "RecyclerView Adapter temel yapısı."
              }
            ],
            "keyPoints": [
              "Veri ile UI arasındaki köprüdür",
              "ViewHolder kullanır",
              "Performans için gereklidir",
              "Liste güncellemelerini yönetir"
            ],
            "questions": [
              {
                "questionId": 312001,
                "question": "Adapter’ın temel görevi nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "UI tasarlamak",
                  "Veri ile View’ları bağlamak",
                  "Lifecycle yönetmek",
                  "Navigation yapmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Adapter, veri kaynağı ile RecyclerView item’ları arasında köprü görevi görür.",
                "tags": ["adapter", "recyclerview"]
              },
              {
                "questionId": 312002,
                "question": "RecyclerView.Adapter içinde zorunlu olan metot hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "onCreate",
                  "getItemCount",
                  "onPause",
                  "onDestroy"
                ],
                "correctAnswerIndex": 1,
                "explanation": "getItemCount(), RecyclerView’da kaç item olacağını belirtir ve zorunludur.",
                "tags": ["adapter", "method"]
              },
              {
                "questionId": 312003,
                "question": "onCreateViewHolder metodu ne zaman çağrılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Her scroll’da",
                  "Yeni ViewHolder oluşturulması gerektiğinde",
                  "Liste güncellendiğinde",
                  "Activity destroy edildiğinde"
                ],
                "correctAnswerIndex": 1,
                "explanation": "onCreateViewHolder, yeni bir ViewHolder oluşturulması gerektiğinde çağrılır.",
                "tags": ["adapter", "viewholder"]
              },
              {
                "questionId": 312004,
                "question": "ListAdapter neden normal Adapter’a göre tercih edilir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Daha az kod yazıldığı için",
                  "DiffUtil’u otomatik yönettiği için",
                  "XML gerektirmediği için",
                  "Fragment ile çalıştığı için"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ListAdapter, DiffUtil entegrasyonunu otomatik yaparak performanslı liste güncellemeleri sağlar.",
                "tags": ["listadapter", "diffutil"]
              }
            ]
          },
          {
            "topicId": 3103,
            "title": "ViewHolder",
            "summary": "ViewHolder, RecyclerView item'larının görünüm referanslarını tutarak findViewById çağrılarını minimize eder ve performansı artırır.",
            "content": "## ViewHolder\n\nHer item için ViewHolder oluşturulur.\n\nView referanslarını cache'ler.\n\nRecyclerView performansının temel parçalarındandır.",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "ViewHolder Tanımı",
                "code": "class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    fun bind(text: String) {\n        itemView.findViewById<TextView>(R.id.textView).text = text\n    }\n}",
                "explanation": "RecyclerView ViewHolder örneği."
              }
            ],
            "keyPoints": [
              "View referanslarını tutar",
              "Performansı artırır",
              "Adapter ile birlikte çalışır",
              "Her item için kullanılır"
            ],
            "questions": [
              {
                "questionId": 313001,
                "question": "ViewHolder’ın temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veri saklamak",
                  "View referanslarını tutmak",
                  "Navigation yönetmek",
                  "Fragment oluşturmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ViewHolder, View referanslarını tutarak tekrar tekrar findViewById çağrılmasını önler.",
                "tags": ["viewholder", "performance"]
              },
              {
                "questionId": 313002,
                "question": "ViewHolder performansa nasıl katkı sağlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Bellek kullanımını artırarak",
                  "UI thread’i bloke ederek",
                  "View aramalarını azaltarak",
                  "Veri kopyalayarak"
                ],
                "correctAnswerIndex": 2,
                "explanation": "ViewHolder, View aramalarını azaltarak RecyclerView performansını artırır.",
                "tags": ["viewholder", "optimization"]
              },
              {
                "questionId": 313003,
                "question": "RecyclerView’da ViewHolder kullanılmazsa ne olur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Uygulama crash olur",
                  "Performans düşer",
                  "Liste görünmez",
                  "Adapter çalışmaz"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ViewHolder kullanılmazsa sürekli View araması yapılır ve performans ciddi şekilde düşer.",
                "tags": ["viewholder", "performance"]
              }
            ]
          },
          {
            "topicId": 3104,
            "title": "DiffUtil (Opsiyonel)",
            "summary": "DiffUtil, RecyclerView listelerindeki değişiklikleri minimum maliyetle hesaplayarak sadece değişen item'ların güncellenmesini sağlar.",
            "content": "## DiffUtil\n\nListe güncellemelerinde performans sağlar.\n\nnotifyDataSetChanged yerine önerilir.\n\nÖzellikle büyük listelerde fark yaratır.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "DiffUtil Kullanımı",
                "code": "class MyDiffUtil : DiffUtil.ItemCallback<Item>() {\n    override fun areItemsTheSame(oldItem: Item, newItem: Item) = oldItem.id == newItem.id\n\n    override fun areContentsTheSame(oldItem: Item, newItem: Item) = oldItem == newItem\n}",
                "explanation": "DiffUtil ile liste karşılaştırma."
              }
            ],
            "keyPoints": [
              "Performanslı liste güncelleme sağlar",
              "Sadece değişen item'ları günceller",
              "notifyDataSetChanged yerine kullanılır",
              "Large listelerde önerilir"
            ],
            "questions": [
              {
                "questionId": 314001,
                "question": "DiffUtil’un temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Liste sıralamak",
                  "Veri saklamak",
                  "Liste farklarını hesaplamak",
                  "UI çizmek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "DiffUtil, eski ve yeni liste arasındaki farkları hesaplar.",
                "tags": ["diffutil", "recyclerview"]
              },
              {
                "questionId": 314002,
                "question": "DiffUtil hangi durumda performans avantajı sağlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Tüm liste değiştiğinde",
                  "Sadece birkaç item değiştiğinde",
                  "Liste boşken",
                  "Tek item varken"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Sadece değişen item’lar güncellendiği için performans artar.",
                "tags": ["diffutil", "performance"]
              },
              {
                "questionId": 314003,
                "question": "areItemsTheSame metodu neyi kontrol eder?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "İçerik eşitliğini",
                  "Referans eşitliğini",
                  "Item kimliğini",
                  "Liste boyutunu"
                ],
                "correctAnswerIndex": 2,
                "explanation": "areItemsTheSame, iki item’ın aynı kimliğe sahip olup olmadığını kontrol eder.",
                "tags": ["diffutil", "callback"]
              },
              {
                "questionId": 314004,
                "question": "areContentsTheSame ne zaman false döner?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Item ID değiştiğinde",
                  "Liste boşken",
                  "Item içeriği değiştiğinde",
                  "Adapter null olduğunda"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Item’ın içeriği değiştiğinde areContentsTheSame false döner.",
                "tags": ["diffutil", "update"]
              },
              {
                "questionId": 314005,
                "question": "DiffUtil yanlış kullanılırsa ne olur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Crash oluşur",
                  "Yanlış animasyonlar görülür",
                  "Uygulama açılmaz",
                  "Veri silinir"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Yanlış karşılaştırmalar UI’da hatalı animasyonlara neden olabilir.",
                "tags": ["diffutil", "bug"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 310001,
            "question": "RecyclerView’un temel amacı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Tek bir View göstermek",
              "Az sayıda veriyi statik göstermek",
              "Büyük veri listelerini performanslı göstermek",
              "Fragment geçişlerini yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "RecyclerView, büyük veri listelerini minimum bellek kullanımıyla performanslı şekilde göstermek için tasarlanmıştır.",
            "tags": ["recyclerview", "temel"]
          },
          {
            "questionId": 310002,
            "question": "RecyclerView’da liste düzenini belirleyen bileşen hangisidir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Adapter",
              "ViewHolder",
              "LayoutManager",
              "DiffUtil"
            ],
            "correctAnswerIndex": 2,
            "explanation": "LayoutManager, RecyclerView’daki item’ların dikey, yatay veya grid şeklinde nasıl yerleşeceğini belirler.",
            "tags": ["layoutmanager", "recyclerview"]
          },
          {
            "questionId": 310003,
            "question": "Adapter’ın temel görevi nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Veri saklamak",
              "View’ları çizmek",
              "Veri ile View’ları bağlamak",
              "Lifecycle yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Adapter, veri kaynağı ile RecyclerView item’ları arasındaki bağlantıyı sağlar.",
            "tags": ["adapter", "recyclerview"]
          },
          {
            "questionId": 310004,
            "question": "ViewHolder neden kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "UI tasarımı yapmak için",
              "Veritabanı bağlantısı için",
              "findViewById çağrılarını azaltmak için",
              "Fragment yönetimi için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewHolder, View referanslarını tutarak gereksiz findViewById çağrılarını azaltır ve performansı artırır.",
            "tags": ["viewholder", "performance"]
          },
          {
            "questionId": 310005,
            "question": "RecyclerView.Adapter içinde zorunlu olan metot hangisidir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "onClick",
              "getItemCount",
              "onResume",
              "notifyDataSetChanged"
            ],
            "correctAnswerIndex": 1,
            "explanation": "getItemCount(), RecyclerView’ın kaç item göstereceğini belirtir ve zorunludur.",
            "tags": ["adapter", "method"]
          },
          {
            "questionId": 310006,
            "question": "onBindViewHolder metodu ne zaman çağrılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "RecyclerView oluşturulurken",
              "Yeni ViewHolder oluşturulurken",
              "Item ekrana bağlanırken",
              "Liste temizlenirken"
            ],
            "correctAnswerIndex": 2,
            "explanation": "onBindViewHolder, item ekrana bağlanırken verinin ViewHolder’a aktarılması için çağrılır.",
            "tags": ["adapter", "binding"]
          },
          {
            "questionId": 310007,
            "question": "notifyDataSetChanged neden önerilmez?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Deprecated olduğu için",
              "Senkron çalıştığı için",
              "Tüm listeyi yeniden çizdiği için",
              "Sadece küçük listelerde çalıştığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "notifyDataSetChanged tüm listeyi yeniler, bu da performans kaybına yol açar.",
            "tags": ["performance", "recyclerview"]
          },
          {
            "questionId": 310008,
            "question": "DiffUtil’un temel amacı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Listeyi sıralamak",
              "Veri kaydetmek",
              "Liste farklarını hesaplamak",
              "View oluşturmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "DiffUtil, eski ve yeni liste arasındaki farkları hesaplayarak sadece değişen item’ların güncellenmesini sağlar.",
            "tags": ["diffutil", "performance"]
          },
          {
            "questionId": 310009,
            "question": "DiffUtil kullanmanın en büyük avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Kodun kısalması",
              "Bellek kullanımının artması",
              "Daha az UI güncellemesi",
              "Lifecycle yönetimi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "DiffUtil, sadece değişen item’ları güncelleyerek performansı ciddi şekilde artırır.",
            "tags": ["diffutil", "optimization"]
          },
          {
            "questionId": 310010,
            "question": "RecyclerView neden ListView’a göre daha performanslıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Daha az XML kullanır",
              "View recycling ve ViewHolder zorunlu olduğu için",
              "Sadece küçük listelerde çalıştığı için",
              "Fragment ile çalıştığı için"
            ],
            "correctAnswerIndex": 1,
            "explanation": "RecyclerView, zorunlu ViewHolder ve gelişmiş recycling mekanizması sayesinde ListView’dan daha performanslıdır.",
            "tags": ["recyclerview", "performance"]
          }
        ]
      },
      {
        "sectionId": 3200,
        "sectionTitle": "Fragment & Navigation",
        "sectionDescription": "Fragment yapısı ve Android Navigation Component kullanarak ekranlar arası geçişlerin yönetilmesi",
        "order": 2,
        "topics": [
          {
            "topicId": 3201,
            "title": "Fragment",
            "summary": "Fragment, bir Activity içerisinde yer alan, kendi yaşam döngüsüne sahip modüler UI bileşenleridir. Tek bir Activity içinde birden fazla Fragment kullanılabilir.",
            "content": "## Fragment\n\nFragment'ler yeniden kullanılabilir UI parçalarıdır.\n\nActivity'lere bağımlı olarak çalışırlar.\n\nModern Android mimarisinde tek Activity - çok Fragment yaklaşımı yaygındır.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Fragment Tanımı",
                "code": "class HomeFragment : Fragment(R.layout.fragment_home)",
                "explanation": "Basit bir Fragment tanımı."
              }
            ],
            "keyPoints": [
              "Activity içinde çalışır",
              "Modüler UI sağlar",
              "Kendi lifecycle'ına sahiptir",
              "Yeniden kullanılabilir"
            ],
            "questions": [
              {
                "questionId": 320101,
                "question": "Fragment nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Bağımsız çalışan bir Activity",
                  "Activity içinde çalışan modüler UI bileşeni",
                  "Sadece arka plan işlemleri için kullanılan sınıf",
                  "Veritabanı yönetim sınıfı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Fragment, Activity içerisinde çalışan ve kendi yaşam döngüsüne sahip modüler UI bileşenidir.",
                "tags": ["fragment", "ui", "temel"]
              },
              {
                "questionId": 320102,
                "question": "Modern Android mimarisinde önerilen yapı hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Çok Activity - az Fragment",
                  "Tek Activity - çok Fragment",
                  "Her ekran için ayrı Activity",
                  "Fragment kullanmamak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Google, modern mimaride tek Activity içinde birden fazla Fragment kullanılmasını önerir.",
                "tags": ["fragment", "architecture", "best_practice"]
              },
              {
                "questionId": 320103,
                "question": "Fragment’ler neden yeniden kullanılabilir kabul edilir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Statik oldukları için",
                  "Activity’den bağımsız çalıştıkları için",
                  "Farklı Activity’lerde kullanılabildikleri için",
                  "Sadece XML içerdiği için"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Fragment’ler farklı Activity’lerde veya farklı layout yapılarında yeniden kullanılabilir.",
                "tags": ["fragment", "reusability", "ui"]
              },
              {
                "questionId": 320104,
                "question": "Fragment doğrudan ekranda çalışabilir mi?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Evet",
                  "Hayır, Activity’ye ihtiyaç duyar",
                  "Sadece Navigation Component ile",
                  "Sadece XML içinde"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Fragment’ler tek başına çalışamaz, mutlaka bir Activity’ye bağlı olmalıdır.",
                "tags": ["fragment", "activity", "lifecycle"]
              }
            ]
          },
          {
            "topicId": 3202,
            "title": "Fragment Lifecycle",
            "summary": "Fragment Lifecycle, Fragment'in oluşturulmasından yok edilmesine kadar geçen yaşam döngüsünü ifade eder. Activity lifecycle'dan daha karmaşıktır.",
            "content": "## Fragment Lifecycle\n\nonCreate, onCreateView, onViewCreated, onDestroyView gibi metotlar içerir.\n\nUI ve veri işlemleri doğru lifecycle aşamasında yapılmalıdır.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Lifecycle Metodu",
                "code": "override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n    super.onViewCreated(view, savedInstanceState)\n}",
                "explanation": "UI işlemleri için önerilen lifecycle metodu."
              }
            ],
            "keyPoints": [
              "Activity lifecycle'dan farklıdır",
              "onDestroyView kritik öneme sahiptir",
              "Memory leak riskleri vardır",
              "Doğru kullanım performansı artırır"
            ],
            "questions": [
              {
                "questionId": 320201,
                "question": "Fragment lifecycle neden Activity lifecycle’dan daha karmaşıktır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Daha az metodu olduğu için",
                  "View lifecycle ve Fragment lifecycle ayrı olduğu için",
                  "Sadece XML ile çalıştığı için",
                  "Async çalıştığı için"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Fragment’lerde View lifecycle ve Fragment lifecycle ayrı yönetildiği için daha karmaşıktır.",
                "tags": ["fragment_lifecycle", "lifecycle", "temel"]
              },
              {
                "questionId": 320202,
                "question": "UI işlemleri için Fragment’te en uygun lifecycle metodu hangisidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "onCreate",
                  "onAttach",
                  "onViewCreated",
                  "onDestroy"
                ],
                "correctAnswerIndex": 2,
                "explanation": "onViewCreated, View tamamen hazır olduktan sonra çağrıldığı için UI işlemleri burada yapılmalıdır.",
                "tags": ["fragment_lifecycle", "ui", "best_practice"]
              },
              {
                "questionId": 320203,
                "question": "onDestroyView metodunun temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Fragment’i tamamen yok etmek",
                  "View referanslarını temizlemek",
                  "Activity’yi kapatmak",
                  "Navigation işlemini durdurmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "onDestroyView, View ile ilgili referansların temizlenmesi için kullanılır.",
                "tags": ["fragment_lifecycle", "memory", "view"]
              },
              {
                "questionId": 320204,
                "question": "Fragment lifecycle yanlış yönetilirse en büyük risk nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Crash",
                  "Memory leak",
                  "Navigation hatası",
                  "Veri kaybı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Yanlış lifecycle yönetimi memory leak oluşmasına neden olabilir.",
                "tags": ["fragment_lifecycle", "memory_leak", "advanced"]
              }
            ]
          },
          {
            "topicId": 3203,
            "title": "Navigation Component",
            "summary": "Navigation Component, Fragment'ler arası geçişleri güvenli, okunabilir ve merkezi bir şekilde yönetmeyi sağlar.",
            "content": "## Navigation Component\n\nNavigation Graph ile ekranlar tanımlanır.\n\nBackStack otomatik yönetilir.\n\nFragment geçişleri sadeleşir.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "Fragment Geçişi",
                "code": "findNavController().navigate(R.id.action_home_to_detail)",
                "explanation": "Navigation Component ile ekran geçişi."
              }
            ],
            "keyPoints": [
              "Merkezi navigasyon yönetimi",
              "BackStack otomatik yönetilir",
              "Fragment geçişleri kolaylaşır",
              "Best practice olarak önerilir"
            ],
            "questions": [
              {
                "questionId": 320301,
                "question": "Navigation Component’in temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veritabanı yönetmek",
                  "Fragment’ler arası geçişleri merkezi şekilde yönetmek",
                  "UI tasarlamak",
                  "Network isteklerini yönetmek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, Fragment’ler arası geçişleri merkezi, güvenli ve okunabilir şekilde yönetmek için kullanılır.",
                "tags": ["navigation_component", "navigation", "temel"]
              },
              {
                "questionId": 320302,
                "question": "Navigation Component hangi dosya ile ekran geçişlerini tanımlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "AndroidManifest.xml",
                  "navigation_graph.xml",
                  "styles.xml",
                  "build.gradle"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Graph XML dosyası, Fragment’ler ve aralarındaki geçişleri tanımlar.",
                "tags": ["navigation_component", "navigation_graph", "xml"]
              },
              {
                "questionId": 320303,
                "question": "Navigation Component kullanmanın en büyük avantajlarından biri nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Daha fazla kod yazmak",
                  "BackStack yönetimini otomatik yapması",
                  "Performansı düşürmesi",
                  "Sadece Activity ile çalışması"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, BackStack yönetimini otomatik yaparak hata riskini azaltır.",
                "tags": ["navigation_component", "backstack", "advantage"]
              },
              {
                "questionId": 320304,
                "question": "findNavController() fonksiyonu ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "View oluşturmak",
                  "Fragment silmek",
                  "Navigation işlemini başlatmak",
                  "Layout inflate etmek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "findNavController(), Navigation Component üzerinden ekran geçişlerini başlatmak için kullanılır.",
                "tags": ["navigation_component", "navcontroller", "advanced"]
              }
            ]
          },
          {
            "topicId": 3204,
            "title": "Safe Args",
            "summary": "Safe Args, Navigation Component ile Fragment'ler arasında tip güvenli veri aktarımı yapılmasını sağlar.",
            "content": "## Safe Args\n\nCompile-time güvenlik sağlar.\n\nYanlış key kullanımını engeller.\n\nParcelable ve Serializable destekler.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Safe Args Kullanımı",
                "code": "val action = HomeFragmentDirections.actionHomeToDetail(userId)\nfindNavController().navigate(action)",
                "explanation": "Safe Args ile veri gönderme."
              }
            ],
            "keyPoints": [
              "Tip güvenlidir",
              "Runtime hataları azaltır",
              "Navigation Component ile çalışır",
              "Önerilen veri aktarım yöntemidir"
            ],
            "questions": [
              {
                "questionId": 320301,
                "question": "Navigation Component’in temel amacı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veritabanı yönetmek",
                  "Fragment’ler arası geçişleri merkezi şekilde yönetmek",
                  "UI tasarlamak",
                  "Network isteklerini yönetmek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, Fragment’ler arası geçişleri merkezi, güvenli ve okunabilir şekilde yönetmek için kullanılır.",
                "tags": ["navigation_component", "navigation", "temel"]
              },
              {
                "questionId": 320302,
                "question": "Navigation Component hangi dosya ile ekran geçişlerini tanımlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "AndroidManifest.xml",
                  "navigation_graph.xml",
                  "styles.xml",
                  "build.gradle"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Graph XML dosyası, Fragment’ler ve aralarındaki geçişleri tanımlar.",
                "tags": ["navigation_component", "navigation_graph", "xml"]
              },
              {
                "questionId": 320303,
                "question": "Navigation Component kullanmanın en büyük avantajlarından biri nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Daha fazla kod yazmak",
                  "BackStack yönetimini otomatik yapması",
                  "Performansı düşürmesi",
                  "Sadece Activity ile çalışması"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Navigation Component, BackStack yönetimini otomatik yaparak hata riskini azaltır.",
                "tags": ["navigation_component", "backstack", "advantage"]
              },
              {
                "questionId": 320304,
                "question": "findNavController() fonksiyonu ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "View oluşturmak",
                  "Fragment silmek",
                  "Navigation işlemini başlatmak",
                  "Layout inflate etmek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "findNavController(), Navigation Component üzerinden ekran geçişlerini başlatmak için kullanılır.",
                "tags": ["navigation_component", "navcontroller", "advanced"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 320001,
            "question": "Fragment’lerin en büyük avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Daha fazla kod yazmak",
              "Modüler ve yeniden kullanılabilir UI sunması",
              "Sadece XML kullanması",
              "Activity ihtiyacını kaldırması"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Fragment’ler modüler yapıları sayesinde yeniden kullanılabilir UI sunar.",
            "tags": ["fragment", "ui", "modular"]
          },
          {
            "questionId": 320002,
            "question": "Navigation Component neden önerilir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "BackStack yönetimini otomatik yaptığı için",
              "Daha yavaş çalıştığı için",
              "Sadece XML kullandığı için",
              "Activity’leri kaldırdığı için"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Navigation Component, BackStack yönetimini otomatik yaparak hata riskini azaltır.",
            "tags": ["navigation_component", "best_practice"]
          },
          {
            "questionId": 320003,
            "question": "Fragment’te memory leak riski en çok hangi durumda oluşur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "onCreate içinde işlem yapmak",
              "View referanslarını onDestroyView’da temizlememek",
              "Navigation kullanmak",
              "Safe Args kullanmak"
            ],
            "correctAnswerIndex": 1,
            "explanation": "View referansları onDestroyView’da temizlenmezse memory leak oluşabilir.",
            "tags": ["fragment", "memory_leak", "lifecycle"]
          },
          {
            "questionId": 320004,
            "question": "Safe Args kullanmanın temel faydası nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Daha hızlı navigation",
              "Tip güvenli veri aktarımı",
              "Daha az XML",
              "Daha az Fragment"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Safe Args, Fragment’ler arası veri aktarımında tip güvenliği sağlar.",
            "tags": ["safe_args", "type_safety"]
          },
          {
            "questionId": 320005,
            "question": "Navigation Graph nerede tanımlanır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Java/Kotlin sınıfında",
              "res/navigation klasöründe",
              "AndroidManifest.xml içinde",
              "res/layout içinde"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Graph, res/navigation klasörü altında XML olarak tanımlanır.",
            "tags": ["navigation_graph", "xml", "navigation"]
          },
          {
            "questionId": 320006,
            "question": "Fragment’ler hangi bileşene bağımlıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Service",
              "BroadcastReceiver",
              "Activity",
              "ViewModel"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Fragment’ler çalışabilmek için bir Activity’ye ihtiyaç duyar.",
            "tags": ["fragment", "activity", "dependency"]
          },
          {
            "questionId": 320007,
            "question": "Navigation Component kullanmadan Fragment geçişi nasıl yapılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Intent ile",
              "FragmentTransaction ile",
              "Safe Args ile",
              "ViewBinding ile"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Component olmadan FragmentTransaction kullanılarak geçiş yapılır.",
            "tags": ["fragment", "fragment_transaction", "navigation"]
          },
          {
            "questionId": 320008,
            "question": "Safe Args olmadan veri aktarımı genellikle ne ile yapılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Intent extras",
              "Bundle",
              "ViewModel",
              "SharedPreferences"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Fragment’ler arasında veri aktarımı genellikle Bundle ile yapılır.",
            "tags": ["bundle", "fragment", "data_transfer"]
          },
          {
            "questionId": 320009,
            "question": "Navigation Component BackStack’i nasıl yönetir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Manuel",
              "Otomatik",
              "Service ile",
              "Broadcast ile"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Navigation Component BackStack’i otomatik olarak yönetir.",
            "tags": ["navigation_component", "backstack"]
          },
          {
            "questionId": 320010,
            "question": "Safe Args neden compile-time güvenlik sağlar?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Reflection kullandığı için",
              "Otomatik key oluşturduğu için",
              "Generated class’lar ile çalıştığı için",
              "Runtime kontrol yaptığı için"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Safe Args, compile-time’da oluşturulan sınıflar sayesinde tip güvenliği sağlar.",
            "tags": ["safe_args", "compile_time", "advanced"]
          }
        ]
      },
      {
        "sectionId": 3300,
        "sectionTitle": "Veritabanı (Room)",
        "sectionDescription": "Android uygulamalarda yerel veritabanı kullanımı ve Room kütüphanesinin temel bileşenleri",
        "order": 3,
        "topics": [
          {
            "topicId": 3301,
            "title": "SQLite Temelleri",
            "summary": "SQLite, Android cihazlarda yerleşik olarak bulunan hafif ve ilişkisel bir veritabanıdır. Tablolar, satırlar ve sütunlar üzerinden veri saklar. Android'de uzun süreli ve kalıcı veri saklamak için kullanılır.",
            "content": "## SQLite Temelleri\n\nSQLite ilişkisel bir veritabanıdır.\n\nSQL sorguları ile veri ekleme, silme, güncelleme ve okuma işlemleri yapılır.\n\nRoom, SQLite üzerinde çalışan bir soyutlama katmanıdır.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Android'e gömülü gelir",
              "İlişkisel veritabanıdır",
              "SQL tabanlıdır",
              "Room altyapı olarak SQLite kullanır"
            ],
            "questions": [
              {
                "questionId": 330101,
                "question": "SQLite nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Sunucu tabanlı bir veritabanı",
                  "Android’e gömülü hafif bir ilişkisel veritabanı",
                  "Sadece geçici veri tutan yapı",
                  "Sadece cloud üzerinde çalışan veritabanı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "SQLite, Android cihazlarda yerleşik olarak bulunan hafif ve ilişkisel bir veritabanıdır.",
                "tags": ["sqlite", "database", "temel"]
              },
              {
                "questionId": 330102,
                "question": "SQLite hangi veri modeli ile çalışır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "NoSQL",
                  "Key-Value",
                  "İlişkisel",
                  "Graph"
                ],
                "correctAnswerIndex": 2,
                "explanation": "SQLite, tablolar ve ilişkiler üzerinden çalışan ilişkisel bir veritabanıdır.",
                "tags": ["sqlite", "relational", "model"]
              },
              {
                "questionId": 330103,
                "question": "Room kütüphanesi neyin üzerine kuruludur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Firebase",
                  "SharedPreferences",
                  "SQLite",
                  "Realm"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Room, SQLite üzerinde çalışan bir soyutlama katmanıdır.",
                "tags": ["room", "sqlite", "architecture"]
              }
            ]
          },
          {
            "topicId": 3302,
            "title": "Entity",
            "summary": "Entity, Room veritabanında bir tabloyu temsil eden Kotlin sınıfıdır. Her Entity sınıfı bir tabloya, her property ise bir sütuna karşılık gelir.",
            "content": "## Entity\n\n@Entity anotasyonu ile tanımlanır.\n\nPrimary key zorunludur.\n\nVeritabanı şemasını temsil eder.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Entity Örneği",
                "code": "@Entity\ndata class User(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    val name: String,\n    val age: Int\n)",
                "explanation": "User tablosunu temsil eden bir Entity sınıfı."
              }
            ],
            "keyPoints": [
              "Tabloyu temsil eder",
              "PrimaryKey zorunludur",
              "data class olarak tanımlanır",
              "@Entity anotasyonu kullanılır"
            ],
            "questions": [
              {
                "questionId": 330201,
                "question": "Room’da Entity neyi temsil eder?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Veritabanını",
                  "DAO’yu",
                  "Bir tabloyu",
                  "Bir sorguyu"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Entity, Room veritabanında bir tabloyu temsil eder.",
                "tags": ["entity", "room", "table"]
              },
              {
                "questionId": 330202,
                "question": "Bir Entity sınıfında hangi anotasyon zorunludur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "@Dao",
                  "@Database",
                  "@PrimaryKey",
                  "@Query"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Her Entity sınıfında en az bir PrimaryKey tanımlanmalıdır.",
                "tags": ["entity", "primary_key", "room"]
              },
              {
                "questionId": 330203,
                "question": "@PrimaryKey(autoGenerate = true) ne işe yarar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Tabloyu siler",
                  "ID değerini otomatik artırır",
                  "Veriyi şifreler",
                  "Sütunu gizler"
                ],
                "correctAnswerIndex": 1,
                "explanation": "autoGenerate = true, PrimaryKey değerinin otomatik olarak artırılmasını sağlar.",
                "tags": ["entity", "primary_key", "auto_generate"]
              }
            ]
          },
          {
            "topicId": 3303,
            "title": "DAO",
            "summary": "DAO (Data Access Object), veritabanı işlemlerinin tanımlandığı arayüzdür. SQL sorguları bu katmanda yazılır ve veriye erişim buradan sağlanır.",
            "content": "## DAO\n\n@Dao anotasyonu ile tanımlanır.\n\nInsert, Delete, Update ve Query metotları içerir.\n\nVeri erişim katmanıdır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "DAO Örneği",
                "code": "@Dao\ninterface UserDao {\n    @Insert\n    suspend fun insert(user: User)\n\n    @Query(\"SELECT * FROM User\")\n    suspend fun getAllUsers(): List<User>\n}",
                "explanation": "User tablosu için DAO tanımı."
              }
            ],
            "keyPoints": [
              "Veri erişim katmanıdır",
              "SQL sorguları burada yazılır",
              "Interface olarak tanımlanır",
              "Suspend fonksiyonlarla çalışabilir"
            ],
            "questions": [
              {
                "questionId": 330301,
                "question": "DAO’nun temel görevi nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "UI çizmek",
                  "Veri erişimini yönetmek",
                  "Navigation yapmak",
                  "Lifecycle yönetmek"
                ],
                "correctAnswerIndex": 1,
                "explanation": "DAO, veritabanına erişim sağlayan katmandır.",
                "tags": ["dao", "data_access", "room"]
              },
              {
                "questionId": 330302,
                "question": "DAO genellikle nasıl tanımlanır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "class",
                  "object",
                  "interface",
                  "enum"
                ],
                "correctAnswerIndex": 2,
                "explanation": "DAO genellikle interface olarak tanımlanır.",
                "tags": ["dao", "interface", "room"]
              },
              {
                "questionId": 330303,
                "question": "Room’da SQL sorguları hangi anotasyon ile yazılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "@Insert",
                  "@Query",
                  "@Entity",
                  "@Database"
                ],
                "correctAnswerIndex": 1,
                "explanation": "SELECT gibi SQL sorguları @Query anotasyonu ile yazılır.",
                "tags": ["dao", "query", "sql"]
              }
            ]
          },
          {
            "topicId": 3304,
            "title": "Database",
            "summary": "Database sınıfı, Room veritabanının ana erişim noktasıdır. Entity ve DAO'ları bir araya getirir ve singleton olarak kullanılır.",
            "content": "## Database\n\n@Database anotasyonu ile tanımlanır.\n\nAbstract class olmalıdır.\n\nVeritabanı versiyonlamasını yönetir.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Database Tanımı",
                "code": "@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}",
                "explanation": "Room Database tanımı."
              }
            ],
            "keyPoints": [
              "RoomDatabase'den türetilir",
              "Singleton olarak kullanılır",
              "DAO'lara erişim sağlar",
              "Version yönetimi içerir"
            ],
            "questions": [
              {
                "questionId": 330401,
                "question": "Room Database sınıfı nasıl tanımlanmalıdır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "interface",
                  "data class",
                  "abstract class",
                  "sealed class"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Room Database sınıfı abstract class olarak tanımlanmalıdır.",
                "tags": ["room_database", "abstract", "room"]
              },
              {
                "questionId": 330402,
                "question": "@Database anotasyonu neyi belirtir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "DAO’yu",
                  "Entity listesini ve versiyonu",
                  "SQL sorgularını",
                  "Tablo adını"
                ],
                "correctAnswerIndex": 1,
                "explanation": "@Database anotasyonu Entity’leri ve veritabanı versiyonunu tanımlar.",
                "tags": ["database", "annotation", "room"]
              }
            ]
          },
          {
            "topicId": 3305,
            "title": "CRUD İşlemleri",
            "summary": "CRUD işlemleri, Create (Ekle), Read (Oku), Update (Güncelle) ve Delete (Sil) işlemlerini ifade eder. Room ile bu işlemler anotasyonlar sayesinde kolayca yapılır.",
            "content": "## CRUD İşlemleri\n\nInsert, Query, Update ve Delete anotasyonları kullanılır.\n\nSuspend fonksiyonlarla arka planda çalıştırılmalıdır.",
            "difficulty": "medium",
            "order": 5,
            "codeExamples": [
              {
                "title": "CRUD Örneği",
                "code": "@Update\nsuspend fun updateUser(user: User)\n\n@Delete\nsuspend fun deleteUser(user: User)",
                "explanation": "Room ile güncelleme ve silme işlemleri."
              }
            ],
            "keyPoints": [
              "CRUD = Create, Read, Update, Delete",
              "Room anotasyonları ile yapılır",
              "Suspend fonksiyon önerilir",
              "Ana thread bloklanmamalıdır"
            ],
            "questions": [
              {
                "questionId": 330501,
                "question": "CRUD açılımı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Create, Read, Update, Delete",
                  "Copy, Remove, Update, Drop",
                  "Create, Replace, Upload, Download",
                  "Connect, Read, Use, Delete"
                ],
                "correctAnswerIndex": 0,
                "explanation": "CRUD, Create, Read, Update ve Delete işlemlerini ifade eder.",
                "tags": ["crud", "database", "temel"]
              },
              {
                "questionId": 330502,
                "question": "Room’da veri eklemek için hangi anotasyon kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "@Query",
                  "@Insert",
                  "@Update",
                  "@Delete"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Veri eklemek için @Insert anotasyonu kullanılır.",
                "tags": ["crud", "insert", "room"]
              },
              {
                "questionId": 330503,
                "question": "Room işlemleri neden suspend fonksiyon olarak yazılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Zorunlu olduğu için",
                  "UI thread’i bloklamamak için",
                  "Daha hızlı çalışması için",
                  "Compile-time hatası almamak için"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Veritabanı işlemleri uzun sürebileceği için ana thread’i bloklamamak adına suspend kullanılır.",
                "tags": ["crud", "coroutines", "performance"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 330001,
            "question": "Room neden doğrudan SQLite kullanımına göre avantaj sağlar?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Daha fazla kod gerektirir",
              "Compile-time kontrol sağlar",
              "Sadece UI için çalışır",
              "Network bağımlıdır"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Room, compile-time kontroller ile SQL hatalarını erkenden yakalar.",
            "tags": ["room", "advantage", "architecture"]
          },
          {
            "questionId": 330002,
            "question": "DAO katmanı hangi prensibi destekler?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Single Responsibility",
              "UI Separation",
              "Navigation",
              "Dependency Injection"
            ],
            "correctAnswerIndex": 0,
            "explanation": "DAO yalnızca veri erişiminden sorumludur.",
            "tags": ["dao", "solid", "architecture"]
          },
          {
            "questionId": 330003,
            "question": "Room’da migration neden gereklidir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "UI güncellemek için",
              "Veritabanı şeması değiştiğinde veri kaybını önlemek için",
              "DAO eklemek için",
              "Performansı artırmak için"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Migration, veritabanı versiyonu değiştiğinde mevcut verilerin korunmasını sağlar.",
            "tags": ["room", "migration", "database"]
          },
          {
            "questionId": 330004,
            "question": "Room Database neden genellikle Singleton olarak kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Daha fazla instance üretmek için",
              "Bellek ve performans için",
              "UI kolaylığı için",
              "Zorunlu olduğu için"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Tek instance kullanımı bellek ve performans açısından daha verimlidir.",
            "tags": ["room", "singleton", "performance"]
          },
          {
            "questionId": 330005,
            "question": "Room hangi mimariyle en uyumlu çalışır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "MVC",
              "MVVM",
              "MVP",
              "Monolith"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Room genellikle MVVM mimarisi ile birlikte kullanılır.",
            "tags": ["room", "mvvm", "architecture"]
          },
          {
            "questionId": 33006,
            "question": "Room kütüphanesinin temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["room", "database", "sqlite"],
            "options": [
              "UI tasarımı yapmak",
              "Network istekleri atmak",
              "SQLite işlemlerini daha güvenli ve kolay hale getirmek",
              "Fragment geçişlerini yönetmek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Room, SQLite üzerinde çalışan bir soyutlama katmanıdır ve veritabanı işlemlerini daha güvenli hale getirir."
          },
          {
            "questionId": 33007,
            "question": "Room Entity sınıfında aşağıdakilerden hangisi zorunludur?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "tags": ["room", "entity"],
            "options": [
              "ForeignKey",
              "PrimaryKey",
              "Index",
              "ColumnInfo"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Her Room Entity sınıfında en az bir adet PrimaryKey bulunmak zorundadır."
          },
          {
            "questionId": 33008,
            "question": "DAO interface’lerinde SQL sorguları hangi anotasyon ile yazılır?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "tags": ["room", "dao", "sql"],
            "options": [
              "@Insert",
              "@Database",
              "@Query",
              "@Entity"
            ],
            "correctAnswerIndex": 2,
            "explanation": "@Query anotasyonu ile SELECT, DELETE gibi SQL sorguları yazılır."
          },
          {
            "questionId": 33009,
            "question": "Room Database sınıfı nasıl tanımlanmalıdır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["room", "database"],
            "options": [
              "Interface olarak",
              "Normal class olarak",
              "Abstract class olarak",
              "Singleton olmadan"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Room Database sınıfı abstract class olmalı ve RoomDatabase’den türemelidir."
          },
          {
            "questionId": 33010,
            "question": "Room ile veritabanı işlemlerinin ana thread üzerinde çalıştırılması neden önerilmez?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["room", "performance", "coroutines"],
            "options": [
              "Kod okunabilirliği azalır",
              "Uygulama boyutu artar",
              "UI donmalarına ve ANR hatalarına yol açar",
              "Compile süresi uzar"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Veritabanı işlemleri uzun sürebileceği için ana thread üzerinde çalıştırılması UI donmasına ve ANR hatalarına neden olabilir."
          }
        ]
      },
      {
        "sectionId": 3400,
        "sectionTitle": "MVVM Mimarisi",
        "sectionDescription": "Android uygulamalarda sürdürülebilir, test edilebilir ve okunabilir mimari yapı kurmak için kullanılan MVVM yaklaşımı",
        "order": 4,
        "topics": [
          {
            "topicId": 3401,
            "title": "MVVM Nedir",
            "summary": "MVVM (Model-View-ViewModel), kullanıcı arayüzü ile iş mantığını birbirinden ayırmayı amaçlayan bir mimari tasarım desenidir. Kodun daha okunabilir, test edilebilir ve sürdürülebilir olmasını sağlar.",
            "content": "## MVVM Nedir\n\nMVVM üç ana bileşenden oluşur:\n\n- Model: Veri katmanı\n- View: UI katmanı\n- ViewModel: İş mantığı ve state yönetimi\n\nAndroid'de Google tarafından önerilen mimaridir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Katmanlı mimari sağlar",
              "UI ve iş mantığını ayırır",
              "Test edilebilirliği artırır",
              "Modern Android için önerilir"
            ],
            "questions": [
              {
                "questionId": 340101,
                "question": "MVVM mimarisinin temel amacı aşağıdakilerden hangisidir?",
                "questionType": "multiple_choice",
                "difficulty": "easy",
                "tags": ["mvvm", "architecture"],
                "options": [
                  "UI tasarımını hızlandırmak",
                  "UI ile iş mantığını ayırmak",
                  "Veritabanı işlemlerini yönetmek",
                  "Network performansını artırmak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "MVVM, View ile iş mantığını ayırarak daha sürdürülebilir bir yapı sunar."
              },
              {
                "questionId": 340102,
                "question": "MVVM mimarisinde iş mantığı hangi katmanda yer alır?",
                "questionType": "multiple_choice",
                "difficulty": "easy",
                "tags": ["mvvm", "layers"],
                "options": [
                  "Model",
                  "View",
                  "ViewModel",
                  "Repository"
                ],
                "correctAnswerIndex": 2,
                "explanation": "ViewModel, UI state ve iş mantığını yönetir."
              }
            ]
          },
          {
            "topicId": 3402,
            "title": "ViewModel",
            "summary": "ViewModel, UI ile ilişkili verileri saklayan ve yöneten bileşendir. Configuration change (ekran döndürme gibi) durumlarında verinin kaybolmasını engeller.",
            "content": "## ViewModel\n\nViewModel, lifecycle-aware bir bileşendir.\n\nUI logic burada tutulur.\n\nActivity ve Fragment'tan bağımsızdır.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "ViewModel Tanımı",
                "code": "class MainViewModel : ViewModel() {\n    val counter = MutableLiveData<Int>()\n}",
                "explanation": "Basit bir ViewModel örneği."
              }
            ],
            "keyPoints": [
              "Lifecycle-aware çalışır",
              "UI verisini tutar",
              "Configuration change'lerde silinmez",
              "Business logic içerir"
            ],
            "questions": [
              {
                "questionId": 340201,
                "question": "ViewModel’in Android’de tercih edilmesinin ana sebebi nedir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["viewmodel", "lifecycle"],
                "options": [
                  "UI çizimini yapması",
                  "Configuration change sırasında veriyi koruması",
                  "Context tutabilmesi",
                  "Navigation işlemlerini yönetmesi"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ViewModel ekran döndürme gibi durumlarda veriyi korur."
              },
              {
                "questionId": 340202,
                "question": "ViewModel aşağıdakilerden hangisine doğrudan bağımlı olmamalıdır?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["viewmodel", "architecture"],
                "options": [
                  "Repository",
                  "LiveData",
                  "Activity veya Fragment",
                  "UseCase"
                ],
                "correctAnswerIndex": 2,
                "explanation": "ViewModel, View katmanından bağımsız olmalıdır."
              }
            ]
          },
          {
            "topicId": 3403,
            "title": "LiveData",
            "summary": "LiveData, lifecycle-aware ve gözlemlenebilir bir veri tutucudur. UI katmanı, veri değişikliklerini otomatik olarak takip eder.",
            "content": "## LiveData\n\nObserver pattern kullanır.\n\nLifecycle'a duyarlıdır.\n\nMemory leak riskini azaltır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "LiveData Kullanımı",
                "code": "viewModel.counter.observe(viewLifecycleOwner) {\n    textView.text = it.toString()\n}",
                "explanation": "LiveData gözlemlenmesi."
              }
            ],
            "keyPoints": [
              "Observer pattern kullanır",
              "Lifecycle-aware'dır",
              "UI otomatik güncellenir",
              "Thread-safe veri akışı sağlar"
            ],
            "questions": [
              {
                "questionId": 340301,
                "question": "LiveData’nın en önemli özelliği aşağıdakilerden hangisidir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["livedata", "lifecycle"],
                "options": [
                  "Statik veri tutması",
                  "Lifecycle-aware olması",
                  "Sadece background thread’de çalışması",
                  "Context gerektirmesi"
                ],
                "correctAnswerIndex": 1,
                "explanation": "LiveData lifecycle-aware olduğu için memory leak riskini azaltır."
              },
              {
                "questionId": 340302,
                "question": "LiveData hangi tasarım desenine dayanır?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["livedata", "observer"],
                "options": [
                  "Singleton",
                  "Factory",
                  "Observer",
                  "Builder"
                ],
                "correctAnswerIndex": 2,
                "explanation": "LiveData, Observer pattern kullanır."
              }
            ]
          },
          {
            "topicId": 3404,
            "title": "Repository",
            "summary": "Repository, veri kaynaklarını (API, Room, Cache) tek bir noktadan yöneten katmandır. ViewModel'in veri kaynağına doğrudan erişmesini engeller.",
            "content": "## Repository\n\nTek sorumluluk prensibini destekler.\n\nVeri kaynaklarını soyutlar.\n\nViewModel ile data source arasında köprü görevi görür.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Repository Örneği",
                "code": "class UserRepository(private val dao: UserDao) {\n    suspend fun getUsers() = dao.getAllUsers()\n}",
                "explanation": "Room kullanan basit bir Repository örneği."
              }
            ],
            "keyPoints": [
              "Veri kaynaklarını soyutlar",
              "ViewModel bağımlılığını azaltır",
              "Test yazımını kolaylaştırır",
              "Clean Architecture'a uygundur"
            ],
            "questions": [
              {
                "questionId": 340401,
                "question": "Repository katmanının temel görevi nedir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["repository", "mvvm"],
                "options": [
                  "UI çizmek",
                  "Lifecycle yönetmek",
                  "Veri kaynaklarını tek noktadan yönetmek",
                  "Navigation işlemlerini yapmak"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Repository, API ve Room gibi veri kaynaklarını soyutlar."
              },
              {
                "questionId": 340402,
                "question": "Repository kullanmanın en büyük avantajlarından biri hangisidir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["repository", "testability"],
                "options": [
                  "APK boyutunu küçültmesi",
                  "UI performansını artırması",
                  "Test yazımını kolaylaştırması",
                  "Navigation yönetmesi"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Repository sayesinde veri kaynakları kolayca mocklanabilir."
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 34001,
            "question": "MVVM mimarisinin temel amacı nedir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "tags": ["mvvm", "architecture"],
            "options": [
              "UI tasarımını hızlandırmak",
              "UI ile iş mantığını birbirinden ayırmak",
              "Veritabanı işlemlerini yönetmek",
              "Network isteklerini optimize etmek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "MVVM, UI (View) ile iş mantığını ayırarak daha okunabilir ve sürdürülebilir kod yazılmasını amaçlar."
          },
          {
            "questionId": 34002,
            "question": "MVVM mimarisinde kullanıcı arayüzünü temsil eden katman hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "easy",
            "tags": ["mvvm", "view"],
            "options": [
              "Model",
              "Repository",
              "View",
              "ViewModel"
            ],
            "correctAnswerIndex": 2,
            "explanation": "View katmanı Activity veya Fragment gibi UI bileşenlerinden oluşur."
          },
          {
            "questionId": 34003,
            "question": "ViewModel’in Android’de tercih edilmesinin temel sebeplerinden biri nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["viewmodel", "lifecycle"],
            "options": [
              "UI çizimini yapması",
              "Context tutabilmesi",
              "Configuration change sırasında veriyi koruması",
              "Veritabanı oluşturması"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewModel, ekran döndürme gibi configuration change durumlarında verinin kaybolmasını engeller."
          },
          {
            "questionId": 34004,
            "question": "ViewModel sınıfı aşağıdakilerden hangisine doğrudan bağlı olmamalıdır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["viewmodel", "architecture"],
            "options": [
              "Repository",
              "LiveData",
              "Activity veya Fragment",
              "UseCase"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewModel, View katmanından bağımsız olmalıdır."
          },
          {
            "questionId": 34005,
            "question": "LiveData’nın en önemli özelliklerinden biri hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["livedata", "lifecycle"],
            "options": [
              "Statik veri tutması",
              "Lifecycle-aware olması",
              "Sadece background thread’de çalışması",
              "Context gerektirmesi"
            ],
            "correctAnswerIndex": 1,
            "explanation": "LiveData lifecycle-aware olduğu için memory leak riskini azaltır."
          },
          {
            "questionId": 34006,
            "question": "LiveData hangi tasarım desenine dayanır?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["livedata", "observer"],
            "options": [
              "Singleton",
              "Factory",
              "Observer",
              "Builder"
            ],
            "correctAnswerIndex": 2,
            "explanation": "LiveData, Observer pattern kullanarak veri değişikliklerini UI’a bildirir."
          },
          {
            "questionId": 34007,
            "question": "Repository katmanının temel görevi nedir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["repository", "mvvm"],
            "options": [
              "UI çizmek",
              "Lifecycle yönetmek",
              "Veri kaynaklarını tek noktadan yönetmek",
              "Navigation işlemlerini yapmak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Repository, API, Room veya cache gibi veri kaynaklarını soyutlar."
          },
          {
            "questionId": 34008,
            "question": "Repository kullanmanın en büyük avantajlarından biri hangisidir?",
            "questionType": "multiple_choice",
            "difficulty": "medium",
            "tags": ["repository", "testability"],
            "options": [
              "Kod satırını azaltması",
              "UI performansını artırması",
              "Test yazımını kolaylaştırması",
              "APK boyutunu küçültmesi"
            ],
            "correctAnswerIndex": 2,
            "explanation": "Repository sayesinde veri kaynakları mocklanabilir ve testler kolaylaşır."
          },
          {
            "questionId": 34009,
            "question": "MVVM mimarisi hangi prensibi doğrudan destekler?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "tags": ["mvvm", "solid"],
            "options": [
              "DRY",
              "KISS",
              "Single Responsibility",
              "YAGNI"
            ],
            "correctAnswerIndex": 2,
            "explanation": "MVVM, her katmanın tek bir sorumluluğu olmasını teşvik eder."
          },
          {
            "questionId": 34010,
            "question": "Aşağıdakilerden hangisi MVVM mimarisinin yanlış kullanımına örnektir?",
            "questionType": "multiple_choice",
            "difficulty": "hard",
            "tags": ["mvvm", "anti-pattern"],
            "options": [
              "ViewModel içinde LiveData kullanmak",
              "ViewModel içinde Repository çağırmak",
              "ViewModel içinde Context tutmak",
              "Repository üzerinden veri almak"
            ],
            "correctAnswerIndex": 2,
            "explanation": "ViewModel içinde Context tutulması memory leak ve mimari ihlale yol açar."
          }
        ]
      },
      {
        "sectionId": 3500,
        "sectionTitle": "Networking",
        "sectionDescription": "Android uygulamalarda internet üzerinden veri alışverişi yapmak için kullanılan temel networking kavramları ve araçlar",
        "order": 5,
        "topics": [
          {
            "topicId": 3501,
            "title": "REST API",
            "summary": "REST API, istemci ve sunucu arasında HTTP protokolü üzerinden veri alışverişi yapılmasını sağlayan mimari bir yaklaşımdır. Genellikle JSON formatında veri iletimi kullanılır.",
            "content": "## REST API\n\nREST, stateless bir mimaridir.\n\nKaynaklar URL üzerinden erişilir.\n\nMobil uygulamalar backend servislerle genellikle REST API üzerinden haberleşir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [],
            "keyPoints": [
              "Stateless mimari kullanır",
              "HTTP protokolü üzerinden çalışır",
              "JSON en yaygın veri formatıdır",
              "Mobil-backend iletişimin temelidir"
            ],
            "questions": [
              {
                "questionId": 350101,
                "question": "REST mimarisinin en temel özelliklerinden biri aşağıdakilerden hangisidir?",
                "questionType": "multiple_choice",
                "difficulty": "easy",
                "tags": ["rest", "api", "networking"],
                "options": [
                  "Stateful olması",
                  "Stateless olması",
                  "Sadece XML kullanması",
                  "Socket tabanlı çalışması"
                ],
                "correctAnswerIndex": 1,
                "explanation": "REST mimarisi stateless çalışır, her istek bağımsızdır."
              },
              {
                "questionId": 350102,
                "question": "REST API’lerde kaynaklara erişim genellikle ne ile sağlanır?",
                "questionType": "multiple_choice",
                "difficulty": "easy",
                "tags": ["rest", "url"],
                "options": [
                  "IP adresi",
                  "Dosya yolu",
                  "URL",
                  "Database tablo adı"
                ],
                "correctAnswerIndex": 2,
                "explanation": "REST API’de her kaynak bir URL ile temsil edilir."
              }
            ]
          },
          {
            "topicId": 3502,
            "title": "Retrofit",
            "summary": "Retrofit, Android ve Java/Kotlin projelerinde REST API çağrılarını kolay ve güvenli şekilde yapmayı sağlayan popüler bir networking kütüphanesidir.",
            "content": "## Retrofit\n\nInterface tabanlı çalışır.\n\nHTTP isteklerini annotation'lar ile tanımlar.\n\nOkHttp üzerine kuruludur.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Retrofit Interface",
                "code": "interface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List<User>\n}",
                "explanation": "Basit bir Retrofit API tanımı."
              }
            ],
            "keyPoints": [
              "Interface tabanlıdır",
              "Coroutine ve RxJava desteği vardır",
              "OkHttp ile birlikte çalışır",
              "API çağrılarını sadeleştirir"
            ],
            "questions": [
              {
                "questionId": 350201,
                "question": "Retrofit’in Android’de kullanılmasının temel sebebi nedir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["retrofit", "networking"],
                "options": [
                  "UI çizimini kolaylaştırması",
                  "REST API çağrılarını sadeleştirmesi",
                  "Veritabanı yönetmesi",
                  "Navigation işlemlerini yapması"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Retrofit, REST API çağrılarını annotation tabanlı ve okunabilir hale getirir."
              },
              {
                "questionId": 350202,
                "question": "Retrofit hangi kütüphane üzerine inşa edilmiştir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["retrofit", "okhttp"],
                "options": [
                  "Volley",
                  "Glide",
                  "OkHttp",
                  "Ktor"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Retrofit, HTTP işlemleri için OkHttp kullanır."
              }
            ]
          },
          {
            "topicId": 3503,
            "title": "HTTP İstek Türleri",
            "summary": "HTTP istek türleri, istemcinin sunucuya ne tür bir işlem yapmak istediğini belirtir. En yaygın olanları GET, POST, PUT ve DELETE'tir.",
            "content": "## HTTP İstek Türleri\n\nGET: Veri almak\nPOST: Veri göndermek\nPUT: Veri güncellemek\nDELETE: Veri silmek",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "POST İsteği",
                "code": "@POST(\"users\")\nsuspend fun createUser(@Body user: User): Response<User>",
                "explanation": "Retrofit ile POST isteği örneği."
              }
            ],
            "keyPoints": [
              "GET veri almak için kullanılır",
              "POST veri ekler",
              "PUT veri günceller",
              "DELETE veri siler"
            ],
            "questions": [
              {
                "questionId": 350301,
                "question": "Sunucudan veri almak için kullanılan HTTP metodu hangisidir?",
                "questionType": "multiple_choice",
                "difficulty": "easy",
                "tags": ["http", "get"],
                "options": [
                  "POST",
                  "PUT",
                  "GET",
                  "DELETE"
                ],
                "correctAnswerIndex": 2,
                "explanation": "GET isteği sunucudan veri almak için kullanılır."
              },
              {
                "questionId": 350302,
                "question": "Bir kaydı güncellemek için en uygun HTTP metodu hangisidir?",
                "questionType": "multiple_choice",
                "difficulty": "easy",
                "tags": ["http", "put"],
                "options": [
                  "GET",
                  "POST",
                  "PUT",
                  "DELETE"
                ],
                "correctAnswerIndex": 2,
                "explanation": "PUT isteği mevcut veriyi güncellemek için kullanılır."
              }
            ]
          },
          {
            "topicId": 3504,
            "title": "JSON Parsing",
            "summary": "JSON Parsing, sunucudan gelen JSON formatındaki verinin Kotlin nesnelerine dönüştürülmesi işlemidir. Retrofit genellikle Gson veya Moshi ile birlikte kullanılır.",
            "content": "## JSON Parsing\n\nJSON, anahtar-değer yapısına sahiptir.\n\nModel class'lar ile parse edilir.\n\nOtomatik dönüşüm sağlar.",
            "difficulty": "medium",
            "order": 4,
            "codeExamples": [
              {
                "title": "Data Class",
                "code": "data class User(\n    val id: Int,\n    val name: String\n)",
                "explanation": "JSON verisini temsil eden data class."
              }
            ],
            "keyPoints": [
              "JSON en yaygın veri formatıdır",
              "Data class ile eşleştirilir",
              "Gson / Moshi kullanılır",
              "Retrofit ile otomatik parse edilir"
            ],
            "questions": [
              {
                "questionId": 350401,
                "question": "JSON Parsing işleminin amacı nedir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["json", "parsing"],
                "options": [
                  "JSON verisini şifrelemek",
                  "JSON verisini UI’da göstermek",
                  "JSON verisini Kotlin nesnelerine dönüştürmek",
                  "JSON verisini sunucuya göndermek"
                ],
                "correctAnswerIndex": 2,
                "explanation": "JSON Parsing, JSON verisini model class’lara dönüştürme işlemidir."
              },
              {
                "questionId": 350402,
                "question": "Retrofit ile JSON parsing için en yaygın kullanılan kütüphaneler hangileridir?",
                "questionType": "multiple_choice",
                "difficulty": "medium",
                "tags": ["json", "gson", "moshi"],
                "options": [
                  "Room ve SQLite",
                  "Gson ve Moshi",
                  "LiveData ve Flow",
                  "Hilt ve Dagger"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Retrofit, JSON dönüşümü için genellikle Gson veya Moshi kullanır."
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 350001,
            "question": "REST API'lerde en yaygın kullanılan veri formatı hangisidir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "XML",
              "JSON",
              "CSV",
              "Binary"
            ],
            "correctAnswerIndex": 1,
            "explanation": "REST API'lerde en yaygın veri formatı JSON'dur. Hafif, okunabilir ve kolay parse edilebilir bir formattır.",
            "tags": ["rest", "json"]
          },
          {
            "questionId": 350002,
            "question": "Retrofit interface'inde @GET annotation'ı ne işe yarar?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Veri silmek",
              "Veri güncellemek",
              "Sunucudan veri almak (HTTP GET isteği)",
              "Veri eklemek"
            ],
            "correctAnswerIndex": 2,
            "explanation": "@GET annotation'ı, HTTP GET isteği yaparak sunucudan veri almak için kullanılır.",
            "tags": ["retrofit", "get"]
          },
          {
            "questionId": 350003,
            "question": "Yeni bir kullanıcı oluşturmak için hangi HTTP metodu kullanılmalıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "GET",
              "POST",
              "PUT",
              "DELETE"
            ],
            "correctAnswerIndex": 1,
            "explanation": "POST metodu, sunucuya yeni veri göndermek (kayıt oluşturmak) için kullanılır.",
            "tags": ["http", "post"]
          },
          {
            "questionId": 350004,
            "question": "Retrofit ile JSON verisini otomatik olarak Kotlin nesnesine dönüştürmek için hangi converter kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "StringConverter",
              "GsonConverterFactory veya MoshiConverterFactory",
              "JsonConverter",
              "XmlConverter"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Retrofit'te JSON parsing için GsonConverterFactory veya MoshiConverterFactory kullanılır. Builder'a addConverterFactory ile eklenir.",
            "tags": ["retrofit", "gson", "moshi"]
          },
          {
            "questionId": 350005,
            "question": "Aşağıdaki Retrofit fonksiyonunda @Body annotation'ı ne işe yarar?",
            "questionType": "multiple_choice",
            "code": "@POST(\"users\")\nsuspend fun createUser(@Body user: User): Response<User>",
            "difficulty": "medium",
            "options": [
              "URL'e parametre ekler",
              "Request body'sine nesneyi JSON olarak ekler",
              "Header ekler",
              "Query parametresi ekler"
            ],
            "correctAnswerIndex": 1,
            "explanation": "@Body annotation'ı, fonksiyona verilen nesneyi JSON'a çevirip HTTP request body'sine ekler. POST ve PUT isteklerinde sıkça kullanılır.",
            "tags": ["retrofit", "body", "post"]
          },
          {
            "questionId": 350006,
            "question": "REST mimarisinde stateless olması ne anlama gelir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Sunucu her istekte yeniden başlar",
              "Her istek bağımsızdır, sunucu önceki istekleri hatırlamaz",
              "Veri saklanamaz",
              "Sadece GET istekleri yapılabilir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Stateless, her HTTP isteğinin bağımsız olduğu ve sunucunun istemci hakkında durum bilgisi tutmadığı anlamına gelir. Her istekte gerekli bilgiler (token vb.) gönderilmelidir.",
            "tags": ["rest", "stateless"]
          },
          {
            "questionId": 350007,
            "question": "Bir kaydı silmek için hangi HTTP metodu ve Retrofit annotation'ı kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "GET ve @GET",
              "POST ve @POST",
              "DELETE ve @DELETE",
              "PUT ve @PUT"
            ],
            "correctAnswerIndex": 2,
            "explanation": "DELETE metodu ve @DELETE annotation'ı, sunucudan bir kaydı silmek için kullanılır.",
            "tags": ["http", "delete", "retrofit"]
          },
          {
            "questionId": 350008,
            "question": "JSON parsing sırasında data class'taki field adları ile JSON key'leri farklıysa ne yapılmalıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "JSON değiştirilmeli",
              "@SerializedName annotation'ı kullanılır",
              "Manuel parsing yapılmalı",
              "Hiçbir şey yapılamaz"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Gson'da @SerializedName (veya Moshi'de @Json) annotation'ı ile JSON key'i ile Kotlin property adı eşleştirilebilir. Örnek: @SerializedName(\"user_name\") val userName: String",
            "tags": ["json", "gson", "serializedname"]
          },
          {
            "questionId": 350009,
            "question": "Retrofit'in OkHttp üzerine kurulu olmasının avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Sadece daha hızlıdır",
              "HTTP/2, connection pooling, interceptor gibi gelişmiş özellikler sağlar",
              "Sadece JSON parse eder",
              "Veritabanı işlemleri yapar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "OkHttp, HTTP/2 desteği, connection pooling, interceptor (logging, authentication) gibi gelişmiş networking özellikleri sağlar. Retrofit bu altyapıyı kullanır.",
            "tags": ["retrofit", "okhttp"]
          },
          {
            "questionId": 350010,
            "question": "REST API çağrısı sırasında network hatası oluşursa hangi yaklaşım doğrudur?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Uygulamayı kapat",
              "Hatayı yakala (try-catch) ve kullanıcıya bilgi ver",
              "Hiçbir şey yapma",
              "Otomatik olarak düzelir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Network çağrıları try-catch bloğu ile sarmalanmalı veya Result/Resource pattern kullanılmalıdır. Hata durumunda kullanıcıya anlamlı mesaj gösterilmeli (Snackbar, Toast vb.).",
            "tags": ["networking", "error_handling"]
          }
        ]
      },
      {
        "sectionId": 3600,
        "sectionTitle": "Firebase",
        "sectionDescription": "Google Firebase kullanarak backend ihtiyacı olmadan kimlik doğrulama, veritabanı, dosya depolama ve güvenlik yönetimi",
        "order": 6,
        "topics": [
          {
            "topicId": 3601,
            "title": "Authentication",
            "summary": "Firebase Authentication, kullanıcıların e-posta/şifre, Google, Facebook gibi yöntemlerle güvenli bir şekilde giriş yapmasını sağlayan kimlik doğrulama servisidir.",
            "content": "## Authentication\n\nKullanıcı yönetimini kolaylaştırır.\n\nHazır giriş yöntemleri sunar.\n\nBackend yazmaya gerek kalmaz.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Email ile Giriş",
                "code": "FirebaseAuth.getInstance()\n    .signInWithEmailAndPassword(email, password)",
                "explanation": "Firebase ile e-posta ve şifre kullanarak giriş işlemi."
              }
            ],
            "keyPoints": [
              "Hazır authentication altyapısı sunar",
              "Email, Google, Facebook desteği vardır",
              "Güvenli kullanıcı yönetimi sağlar",
              "Kolay entegrasyon sunar"
            ],
            "questions": [
              {
                "questionId": 360101,
                "question": "Firebase Authentication ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Dosya depolama",
                  "Kullanıcı kimlik doğrulama ve giriş yönetimi",
                  "Veritabanı işlemleri",
                  "Push notification"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firebase Authentication, kullanıcıların güvenli bir şekilde giriş yapmasını sağlayan kimlik doğrulama servisidir.",
                "tags": ["firebase", "authentication"]
              },
              {
                "questionId": 360102,
                "question": "Firebase Authentication hangi giriş yöntemlerini destekler?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Sadece email/şifre",
                  "Email/şifre, Google, Facebook, Twitter vb.",
                  "Sadece Google",
                  "Sadece telefon numarası"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firebase Authentication, email/şifre, Google, Facebook, Twitter, telefon numarası gibi birçok giriş yöntemini destekler.",
                "tags": ["firebase", "authentication", "providers"]
              },
              {
                "questionId": 360103,
                "question": "Aşağıdaki kod ne yapar?",
                "questionType": "multiple_choice",
                "code": "FirebaseAuth.getInstance()\n    .signInWithEmailAndPassword(email, password)",
                "difficulty": "easy",
                "options": [
                  "Yeni kullanıcı oluşturur",
                  "Email ve şifre ile giriş yapar",
                  "Şifre sıfırlar",
                  "Kullanıcı çıkışı yapar"
                ],
                "correctAnswerIndex": 1,
                "explanation": "signInWithEmailAndPassword metodu, mevcut bir kullanıcının email ve şifre ile giriş yapmasını sağlar.",
                "tags": ["firebase", "authentication", "signin"]
              },
              {
                "questionId": 360104,
                "question": "Firebase Authentication kullanmanın avantajı nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Sadece ücretsizdir",
                  "Backend yazmaya gerek kalmaz, hazır authentication altyapısı sunar",
                  "Sadece Android için çalışır",
                  "Veritabanı yönetir"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firebase Authentication, backend yazmaya gerek kalmadan hazır ve güvenli bir kullanıcı yönetimi altyapısı sağlar.",
                "tags": ["firebase", "authentication", "advantage"]
              }
            ]
          },
          {
            "topicId": 3602,
            "title": "Firestore",
            "summary": "Firestore, NoSQL tabanlı, gerçek zamanlı veri senkronizasyonu sağlayan bulut veritabanıdır. Koleksiyon ve doküman yapısı ile çalışır.",
            "content": "## Firestore\n\nNoSQL mimarisi kullanır.\n\nGerçek zamanlı veri güncellemeleri sunar.\n\nOffline desteklidir.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Veri Ekleme",
                "code": "FirebaseFirestore.getInstance()\n    .collection(\"users\")\n    .add(user)",
                "explanation": "Firestore'a veri ekleme örneği."
              }
            ],
            "keyPoints": [
              "NoSQL tabanlıdır",
              "Gerçek zamanlı çalışır",
              "Offline desteği vardır",
              "Koleksiyon-doküman yapısı kullanır"
            ],
            "questions": [
              {
                "questionId": 360201,
                "question": "Firestore ne tür bir veritabanıdır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "SQL tabanlı",
                  "NoSQL tabanlı",
                  "Graph veritabanı",
                  "In-memory veritabanı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firestore, NoSQL tabanlı bir bulut veritabanıdır ve koleksiyon-doküman yapısı kullanır.",
                "tags": ["firebase", "firestore", "nosql"]
              },
              {
                "questionId": 360202,
                "question": "Firestore'un en önemli özelliği nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Sadece offline çalışır",
                  "Gerçek zamanlı veri senkronizasyonu sağlar",
                  "Sadece dosya saklar",
                  "Authentication yapar"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firestore'un en önemli özelliklerinden biri gerçek zamanlı (real-time) veri güncellemeleri sağlamasıdır. Veri değiştiğinde tüm dinleyen client'lara anında iletilir.",
                "tags": ["firebase", "firestore", "realtime"]
              },
              {
                "questionId": 360203,
                "question": "Firestore'da veriler nasıl organize edilir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Tablo ve satır",
                  "Koleksiyon ve doküman",
                  "Key-value",
                  "Graf yapısı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firestore, koleksiyon (collection) ve doküman (document) yapısı kullanır. Her koleksiyon dokümanlar içerir, her doküman field'lar içerir.",
                "tags": ["firebase", "firestore", "structure"]
              },
              {
                "questionId": 360204,
                "question": "Aşağıdaki kod ne yapar?",
                "questionType": "multiple_choice",
                "code": "FirebaseFirestore.getInstance()\n    .collection(\"users\")\n    .add(user)",
                "difficulty": "easy",
                "options": [
                  "Kullanıcıyı siler",
                  "users koleksiyonuna yeni doküman ekler",
                  "Kullanıcı günceller",
                  "Veritabanını siler"
                ],
                "correctAnswerIndex": 1,
                "explanation": "add() metodu, belirtilen koleksiyona otomatik ID ile yeni bir doküman ekler.",
                "tags": ["firebase", "firestore", "add"]
              }
            ]
          },
          {
            "topicId": 3603,
            "title": "Storage",
            "summary": "Firebase Storage, kullanıcıların yüklediği görsel, video ve dosyaları güvenli bir şekilde saklamak için kullanılan bulut depolama servisidir.",
            "content": "## Storage\n\nDosya depolama için kullanılır.\n\nBüyük dosyalar için uygundur.\n\nAuthentication ile entegre çalışır.",
            "difficulty": "medium",
            "order": 3,
            "codeExamples": [
              {
                "title": "Dosya Yükleme",
                "code": "FirebaseStorage.getInstance()\n    .reference\n    .child(\"images/photo.jpg\")\n    .putFile(uri)",
                "explanation": "Firebase Storage'a dosya yükleme."
              }
            ],
            "keyPoints": [
              "Dosya ve medya depolama sağlar",
              "Güvenli erişim sunar",
              "Authentication ile birlikte çalışır",
              "Yüksek ölçeklenebilirlik sunar"
            ],
            "questions": [
              {
                "questionId": 360301,
                "question": "Firebase Storage ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Sadece metin verisi",
                  "Görsel, video ve dosya depolama",
                  "Kullanıcı giriş bilgileri",
                  "Sadece veritabanı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Firebase Storage, kullanıcıların yüklediği görsel, video ve dosyaları güvenli bir şekilde saklamak için kullanılır.",
                "tags": ["firebase", "storage"]
              },
              {
                "questionId": 360302,
                "question": "Firebase Storage hangi servis ile entegre çalışarak güvenli erişim sağlar?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Firestore",
                  "Realtime Database",
                  "Firebase Authentication",
                  "Cloud Functions"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Firebase Storage, Authentication ile entegre çalışarak sadece yetkili kullanıcıların dosyalara erişmesini sağlar.",
                "tags": ["firebase", "storage", "authentication"]
              },
              {
                "questionId": 360303,
                "question": "Aşağıdaki kod ne yapar?",
                "questionType": "multiple_choice",
                "code": "FirebaseStorage.getInstance()\n    .reference\n    .child(\"images/photo.jpg\")\n    .putFile(uri)",
                "difficulty": "easy",
                "options": [
                  "Dosyayı indirir",
                  "Dosyayı siler",
                  "Dosyayı Firebase Storage'a yükler",
                  "Dosya adını değiştirir"
                ],
                "correctAnswerIndex": 2,
                "explanation": "putFile() metodu, belirtilen URI'deki dosyayı Firebase Storage'a yükler.",
                "tags": ["firebase", "storage", "upload"]
              }
            ]
          },
          {
            "topicId": 3604,
            "title": "Security Rules",
            "summary": "Firebase Security Rules, Firestore ve Storage üzerinde kimlerin hangi verilere erişebileceğini tanımlamak için kullanılan güvenlik kurallarıdır.",
            "content": "## Security Rules\n\nYetkilendirme ve doğrulama sağlar.\n\nAuthentication bilgileri ile çalışır.\n\nVeri güvenliği için kritiktir.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Basit Firestore Kuralı",
                "code": "allow read, write: if request.auth != null;",
                "explanation": "Sadece giriş yapmış kullanıcıların erişmesine izin veren kural."
              }
            ],
            "keyPoints": [
              "Veri güvenliğini sağlar",
              "Authentication ile entegredir",
              "Yetkisiz erişimi engeller",
              "Prod ortamda mutlaka tanımlanmalıdır"
            ],
            "questions": [
              {
                "questionId": 360401,
                "question": "Firebase Security Rules ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "UI tasarımı",
                  "Kimlerin hangi verilere erişebileceğini tanımlamak",
                  "Dosya yükleme",
                  "Kullanıcı giriş ekranı"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Security Rules, Firestore ve Storage üzerinde kimlerin hangi verilere erişebileceğini tanımlamak için kullanılır.",
                "tags": ["firebase", "security", "rules"]
              },
              {
                "questionId": 360402,
                "question": "Aşağıdaki Security Rule ne anlama gelir?",
                "questionType": "multiple_choice",
                "code": "allow read, write: if request.auth != null;",
                "difficulty": "medium",
                "options": [
                  "Herkes okuyup yazabilir",
                  "Kimse okuyamaz yazamaz",
                  "Sadece giriş yapmış kullanıcılar okuyup yazabilir",
                  "Sadece admin okuyup yazabilir"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Bu kural, sadece authenticate olmuş (giriş yapmış) kullanıcıların okuma ve yazma yapabileceğini belirtir.",
                "tags": ["firebase", "security", "auth"]
              },
              {
                "questionId": 360403,
                "question": "Production ortamında Security Rules nasıl olmalıdır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Herkes için açık olmalı",
                  "Mutlaka tanımlanmalı ve kısıtlayıcı olmalı",
                  "Hiç kural olmamalı",
                  "Sadece development'ta gerekli"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Production ortamında mutlaka güvenli Security Rules tanımlanmalıdır. Yetkisiz erişimi engellemek ve veri güvenliğini sağlamak kritiktir.",
                "tags": ["firebase", "security", "production"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 360001,
            "question": "Firebase kullanmanın en büyük avantajı nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Sadece ücretsiz olması",
              "Backend yazmaya gerek kalmadan hazır servisler sunması",
              "Sadece Android için çalışması",
              "Offline çalışmaması"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firebase'in en büyük avantajı, authentication, database, storage gibi backend servislerini hazır olarak sunması ve backend geliştirme ihtiyacını ortadan kaldırmasıdır.",
            "tags": ["firebase", "advantage"]
          },
          {
            "questionId": 360002,
            "question": "Firebase Authentication ve Firestore birlikte kullanıldığında ne sağlanır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Sadece hız artışı",
              "Güvenli kullanıcı yönetimi ve kullanıcıya özel veri saklama",
              "Sadece UI iyileştirmesi",
              "Sadece offline destek"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Authentication ile kullanıcı kimliği doğrulanır, Firestore'da her kullanıcının verisi güvenli şekilde saklanabilir ve Security Rules ile kontrol edilebilir.",
            "tags": ["firebase", "authentication", "firestore"]
          },
          {
            "questionId": 360003,
            "question": "Firestore ve Firebase Storage arasındaki fark nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "İkisi de aynı şeydir",
              "Firestore yapılandırılmış veri, Storage dosya/medya saklar",
              "Storage daha yavaştır",
              "Firestore sadece resim saklar"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firestore, JSON benzeri yapılandırılmış verileri saklar (user bilgileri, post'lar vb.). Storage ise büyük dosyaları ve medyayı (resim, video, PDF) saklar.",
            "tags": ["firebase", "firestore", "storage"]
          },
          {
            "questionId": 360004,
            "question": "Firestore offline desteği ne anlama gelir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Internet olmadan hiçbir şey yapılamaz",
              "Veriler yerel cache'de saklanır, offline'ken erişilebilir ve sync olur",
              "Sadece okuma yapılabilir",
              "Manuel sync gereklidir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Firestore, verileri yerel cache'de saklar. Offline'ken veriler okunabilir ve yazılabilir, internet bağlantısı geldiğinde otomatik senkronize olur.",
            "tags": ["firebase", "firestore", "offline"]
          },
          {
            "questionId": 360005,
            "question": "Yeni bir kullanıcı kaydı oluşturmak için hangi Firebase metodu kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "signInWithEmailAndPassword()",
              "createUserWithEmailAndPassword()",
              "registerUser()",
              "addUser()"
            ],
            "correctAnswerIndex": 1,
            "explanation": "createUserWithEmailAndPassword() metodu, yeni bir kullanıcı kaydı oluşturmak için kullanılır.",
            "tags": ["firebase", "authentication", "signup"]
          },
          {
            "questionId": 360006,
            "question": "Firestore'da gerçek zamanlı veri dinlemek için hangi metot kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "get()",
              "addSnapshotListener()",
              "read()",
              "observe()"
            ],
            "correctAnswerIndex": 1,
            "explanation": "addSnapshotListener() metodu, Firestore'da gerçek zamanlı veri değişikliklerini dinlemek için kullanılır. Veri her değiştiğinde callback tetiklenir.",
            "tags": ["firebase", "firestore", "realtime"]
          },
          {
            "questionId": 360007,
            "question": "Firebase Storage'dan bir dosyayı indirmek için hangi metot kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "putFile()",
              "getFile() veya getDownloadUrl()",
              "uploadFile()",
              "fetchFile()"
            ],
            "correctAnswerIndex": 1,
            "explanation": "getFile() ile dosya doğrudan indirilir veya getDownloadUrl() ile dosyanın URL'i alınıp Glide/Picasso gibi kütüphanelerle yüklenebilir.",
            "tags": ["firebase", "storage", "download"]
          },
          {
            "questionId": 360008,
            "question": "Firebase Security Rules'da request.auth.uid ne anlama gelir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Dosya ID'si",
              "Giriş yapmış kullanıcının ID'si",
              "Veritabanı ID'si",
              "Server ID'si"
            ],
            "correctAnswerIndex": 1,
            "explanation": "request.auth.uid, giriş yapmış kullanıcının benzersiz ID'sini temsil eder. Kullanıcı bazlı erişim kontrolü yapmak için kullanılır (örn: sadece kendi verilerine erişebilir).",
            "tags": ["firebase", "security", "uid"]
          },
          {
            "questionId": 360009,
            "question": "Firebase'de kullanıcı çıkış yapmak için hangi metot kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "FirebaseAuth.getInstance().logout()",
              "FirebaseAuth.getInstance().signOut()",
              "FirebaseAuth.getInstance().exit()",
              "FirebaseAuth.getInstance().close()"
            ],
            "correctAnswerIndex": 1,
            "explanation": "FirebaseAuth.getInstance().signOut() metodu, mevcut kullanıcının oturumunu sonlandırır (logout).",
            "tags": ["firebase", "authentication", "signout"]
          },
          {
            "questionId": 360010,
            "question": "Firestore'da bir dokümanı güncellemek için hangi metot kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "add()",
              "set()",
              "update()",
              "modify()"
            ],
            "correctAnswerIndex": 2,
            "explanation": "update() metodu, mevcut dokümanın belirli field'larını günceller. set() ise tüm dokümanı değiştirir. update() sadece belirtilen field'ları değiştirir.",
            "tags": ["firebase", "firestore", "update"]
          }
        ]
      },
      {
        "sectionId": 3700,
        "sectionTitle": "Konum & Harita",
        "sectionDescription": "Android uygulamalarda kullanıcı konumunu almak, harita üzerinde göstermek ve rota işlemleri yapmak",
        "order": 7,
        "topics": [
          {
            "topicId": 3701,
            "title": "Google Maps",
            "summary": "Google Maps SDK, Android uygulamalarında harita gösterimi ve harita üzerinde etkileşimli işlemler yapılmasını sağlayan resmi Google servisidir.",
            "content": "## Google Maps\n\nGoogle Maps SDK kullanılarak harita uygulamaya entegre edilir.\n\nAPI Key gerektirir.\n\nMarker, kamera hareketleri ve rota çizimi desteklenir.",
            "difficulty": "medium",
            "order": 1,
            "codeExamples": [
              {
                "title": "Harita Hazırlama",
                "code": "override fun onMapReady(googleMap: GoogleMap) {\n    map = googleMap\n}",
                "explanation": "Google Maps hazır olduğunda çağrılan metot."
              }
            ],
            "keyPoints": [
              "Google Maps SDK kullanılır",
              "API Key zorunludur",
              "Harita etkileşimleri desteklenir",
              "Modern uygulamalarda yaygındır"
            ],
            "questions": [
              {
                "questionId": 370101,
                "question": "Android uygulamasında Google Maps kullanmak için ne gereklidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Sadece internet bağlantısı",
                  "Google Maps SDK ve API Key",
                  "Sadece GPS",
                  "Firebase entegrasyonu"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Google Maps SDK'sı projeye eklenmeli ve Google Cloud Console'dan alınan API Key kullanılmalıdır.",
                "tags": ["google_maps", "api_key"]
              },
              {
                "questionId": 370102,
                "question": "onMapReady() metodu ne zaman çağrılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Uygulama ilk açıldığında",
                  "Google Maps hazır olduğunda",
                  "Kullanıcı haritaya tıkladığında",
                  "GPS açıldığında"
                ],
                "correctAnswerIndex": 1,
                "explanation": "onMapReady() callback metodu, Google Maps tamamen yüklenip kullanıma hazır olduğunda çağrılır.",
                "tags": ["google_maps", "onmapready"]
              },
              {
                "questionId": 370103,
                "question": "Google Maps'te hangi işlemler yapılabilir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Sadece konum gösterme",
                  "Marker ekleme, kamera hareketi, rota çizimi",
                  "Sadece zoom yapma",
                  "Sadece stil değiştirme"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Google Maps SDK ile marker ekleme, kamera hareketleri (zoom, pan), rota çizimi (polyline), stil değiştirme gibi birçok etkileşimli işlem yapılabilir.",
                "tags": ["google_maps", "features"]
              },
              {
                "questionId": 370104,
                "question": "Google Maps API Key nereden alınır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Firebase Console",
                  "Play Console",
                  "Google Cloud Console",
                  "Android Studio"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Google Maps API Key, Google Cloud Console'dan (Google Cloud Platform) Maps SDK for Android aktifleştirilerek alınır.",
                "tags": ["google_maps", "api_key", "cloud_console"]
              }
            ]
          },
          {
            "topicId": 3702,
            "title": "Location Permission",
            "summary": "Android'de kullanıcı konumuna erişmek için runtime permission mekanizması kullanılır. Kullanıcının açık izni olmadan konum bilgisi alınamaz.",
            "content": "## Location Permission\n\nACCESS_FINE_LOCATION ve ACCESS_COARSE_LOCATION izinleri kullanılır.\n\nAndroid 6.0 sonrası runtime permission zorunludur.",
            "difficulty": "medium",
            "order": 2,
            "codeExamples": [
              {
                "title": "Permission Kontrolü",
                "code": "if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)\n    != PackageManager.PERMISSION_GRANTED) {\n    requestPermissions(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), 100)\n}",
                "explanation": "Konum izni kontrolü ve isteme."
              }
            ],
            "keyPoints": [
              "Runtime permission zorunludur",
              "Kullanıcı onayı gerekir",
              "Fine ve Coarse location farkı vardır",
              "Yanlış kullanım crash'e yol açabilir"
            ],
            "questions": [
              {
                "questionId": 370201,
                "question": "Android'de kullanıcı konumuna erişmek için ne gereklidir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Hiçbir şey gerekmez",
                  "Kullanıcıdan runtime permission alınmalıdır",
                  "Sadece AndroidManifest'e yazılmalıdır",
                  "Otomatik olarak verilir"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Android 6.0 (API 23) ve sonrasında konum izni runtime'da kullanıcıdan açıkça alınmalıdır.",
                "tags": ["location", "permission"]
              },
              {
                "questionId": 370202,
                "question": "ACCESS_FINE_LOCATION ve ACCESS_COARSE_LOCATION arasındaki fark nedir?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Hiçbir fark yok",
                  "FINE_LOCATION daha hassas (GPS), COARSE_LOCATION daha genel konum verir",
                  "COARSE_LOCATION daha hassastır",
                  "İkisi de aynı konumu verir"
                ],
                "correctAnswerIndex": 1,
                "explanation": "ACCESS_FINE_LOCATION GPS kullanarak çok hassas konum verir. ACCESS_COARSE_LOCATION ise network tabanlı (WiFi, cell tower) daha genel konum verir.",
                "tags": ["location", "permission", "fine_coarse"]
              },
              {
                "questionId": 370203,
                "question": "Konum izni olmadan konum bilgisi alınmaya çalışılırsa ne olur?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Null değer döner",
                  "SecurityException fırlatılır (crash)",
                  "Varsayılan konum verilir",
                  "Hiçbir şey olmaz"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Runtime permission alınmadan konum API'leri kullanılırsa SecurityException fırlatılır ve uygulama crash olur.",
                "tags": ["location", "permission", "exception"]
              },
              {
                "questionId": 370204,
                "question": "Aşağıdaki kodda ne yapılmaktadır?",
                "questionType": "multiple_choice",
                "code": "if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)\n    != PackageManager.PERMISSION_GRANTED) {\n    requestPermissions(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), 100)\n}",
                "difficulty": "easy",
                "options": [
                  "Konum bilgisi alınıyor",
                  "Konum izni kontrol ediliyor ve yoksa isteniyor",
                  "GPS açılıyor",
                  "Harita gösteriliyor"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Kod, önce konum izninin verilip verilmediğini kontrol ediyor. Verilmemişse kullanıcıdan izin istiyor.",
                "tags": ["location", "permission", "request"]
              }
            ]
          },
          {
            "topicId": 3703,
            "title": "Marker",
            "summary": "Marker, Google Maps üzerinde belirli bir konumu işaretlemek için kullanılan görsel işaretleyicilerdir.",
            "content": "## Marker\n\nHarita üzerinde konum göstermek için kullanılır.\n\nBaşlık ve açıklama eklenebilir.",
            "difficulty": "easy",
            "order": 3,
            "codeExamples": [
              {
                "title": "Marker Ekleme",
                "code": "val location = LatLng(41.0082, 28.9784)\nmap.addMarker(MarkerOptions().position(location).title(\"İstanbul\"))",
                "explanation": "Harita üzerine marker ekleme."
              }
            ],
            "keyPoints": [
              "Konum işaretlemek için kullanılır",
              "Başlık ve açıklama eklenebilir",
              "Kullanıcı etkileşimine açıktır",
              "Birden fazla marker eklenebilir"
            ],
            "questions": [
              {
                "questionId": 370301,
                "question": "Google Maps'te Marker ne için kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Rota çizmek",
                  "Belirli bir konumu işaretlemek",
                  "Haritayı zoom yapmak",
                  "Konum izni almak"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Marker, Google Maps üzerinde belirli bir konumu görsel olarak işaretlemek için kullanılır.",
                "tags": ["google_maps", "marker"]
              },
              {
                "questionId": 370302,
                "question": "Marker'a başlık ve açıklama eklenebilir mi?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Hayır, sadece konum gösterir",
                  "Evet, title ve snippet ile eklenebilir",
                  "Sadece başlık eklenebilir",
                  "Sadece açıklama eklenebilir"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Marker'a title() ve snippet() metotları ile başlık ve açıklama eklenebilir. Kullanıcı marker'a tıkladığında bu bilgiler gösterilir.",
                "tags": ["google_maps", "marker", "title"]
              },
              {
                "questionId": 370303,
                "question": "Aşağıdaki kod ne yapar?",
                "questionType": "multiple_choice",
                "code": "val location = LatLng(41.0082, 28.9784)\nmap.addMarker(MarkerOptions().position(location).title(\"İstanbul\"))",
                "difficulty": "easy",
                "options": [
                  "Haritayı zoom yapar",
                  "İstanbul koordinatlarına \"İstanbul\" başlıklı marker ekler",
                  "Rota çizer",
                  "Konum izni ister"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Kod, LatLng(41.0082, 28.9784) koordinatlarına (İstanbul) \"İstanbul\" başlıklı bir marker ekler.",
                "tags": ["google_maps", "marker", "latlng"]
              }
            ]
          },
          {
            "topicId": 3704,
            "title": "Route",
            "summary": "Route (rota), iki veya daha fazla nokta arasındaki yolun harita üzerinde çizilmesini ifade eder. Genellikle Directions API ile birlikte kullanılır.",
            "content": "## Route\n\nPolyline kullanılarak çizilir.\n\nDirections API ile rota bilgisi alınır.\n\nNavigasyon uygulamalarında yaygındır.",
            "difficulty": "hard",
            "order": 4,
            "codeExamples": [
              {
                "title": "Polyline Çizimi",
                "code": "map.addPolyline(\n    PolylineOptions().add(startLatLng, endLatLng)\n)",
                "explanation": "İki nokta arasında rota çizimi."
              }
            ],
            "keyPoints": [
              "Polyline ile çizilir",
              "Directions API gerektirir",
              "Navigasyon uygulamalarında kullanılır",
              "Performans dikkat edilmelidir"
            ],
            "questions": [
              {
                "questionId": 370401,
                "question": "Google Maps'te iki nokta arasında rota çizmek için ne kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "medium",
                "options": [
                  "Marker",
                  "Circle",
                  "Polyline",
                  "Polygon"
                ],
                "correctAnswerIndex": 2,
                "explanation": "Polyline, harita üzerinde iki veya daha fazla nokta arasında çizgi (rota) çizmek için kullanılır.",
                "tags": ["google_maps", "route", "polyline"]
              },
              {
                "questionId": 370402,
                "question": "Gerçek yol bilgisi (sokak takip eden rota) almak için hangi API kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "hard",
                "options": [
                  "Maps SDK",
                  "Directions API",
                  "Places API",
                  "Geocoding API"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Directions API, iki nokta arasında gerçek yol bilgisini (turn-by-turn directions) sağlar. Bu bilgi Polyline ile harita üzerinde çizilir.",
                "tags": ["google_maps", "directions_api", "route"]
              },
              {
                "questionId": 370403,
                "question": "Aşağıdaki kod ne yapar?",
                "questionType": "multiple_choice",
                "code": "map.addPolyline(\n    PolylineOptions().add(startLatLng, endLatLng)\n)",
                "difficulty": "easy",
                "options": [
                  "Marker ekler",
                  "İki nokta arasında çizgi çizer",
                  "Haritayı zoom yapar",
                  "Konum izni ister"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Kod, startLatLng ve endLatLng koordinatları arasında bir Polyline (çizgi) çizer.",
                "tags": ["google_maps", "polyline", "route"]
              },
              {
                "questionId": 370404,
                "question": "Rota çizimi hangi tür uygulamalarda yaygın kullanılır?",
                "questionType": "multiple_choice",
                "code": null,
                "difficulty": "easy",
                "options": [
                  "Sadece oyun uygulamaları",
                  "Navigasyon ve sürüş uygulamaları",
                  "Sadece hava durumu uygulamaları",
                  "Sadece sosyal medya uygulamaları"
                ],
                "correctAnswerIndex": 1,
                "explanation": "Rota çizimi, navigasyon, taksi, teslimat ve sürüş uygulamalarında yaygın olarak kullanılır.",
                "tags": ["google_maps", "route", "navigation"]
              }
            ]
          }
        ],
        "sectionMixedQuestions": [
          {
            "questionId": 370001,
            "question": "Google Maps kullanabilmek için hangi dosyaya API Key eklenir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "MainActivity.kt",
              "AndroidManifest.xml",
              "build.gradle",
              "strings.xml"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Google Maps API Key, AndroidManifest.xml dosyasına <meta-data> tag'i içinde eklenir.",
            "tags": ["google_maps", "api_key", "manifest"]
          },
          {
            "questionId": 370002,
            "question": "LatLng nedir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Marker türü",
              "Enlem (Latitude) ve Boylam (Longitude) çifti",
              "Rota çizimi",
              "İzin türü"
            ],
            "correctAnswerIndex": 1,
            "explanation": "LatLng, enlem (Latitude) ve boylam (Longitude) değerlerini tutan ve harita üzerinde bir konumu temsil eden sınıftır.",
            "tags": ["google_maps", "latlng"]
          },
          {
            "questionId": 370003,
            "question": "Kullanıcının mevcut konumunu almak için hangi servis kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Firebase",
              "FusedLocationProviderClient",
              "GoogleMap",
              "SharedPreferences"
            ],
            "correctAnswerIndex": 1,
            "explanation": "FusedLocationProviderClient, Google Play Services'in bir parçasıdır ve kullanıcının mevcut konumunu almak için önerilen API'dir.",
            "tags": ["location", "fused_location"]
          },
          {
            "questionId": 370004,
            "question": "Harita kamerasını belirli bir konuma taşımak için hangi metot kullanılır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "map.setLocation()",
              "map.moveCamera() veya map.animateCamera()",
              "map.goTo()",
              "map.navigate()"
            ],
            "correctAnswerIndex": 1,
            "explanation": "moveCamera() anında, animateCamera() ise animasyonlu şekilde harita kamerasını belirtilen konuma taşır.",
            "tags": ["google_maps", "camera"]
          },
          {
            "questionId": 370005,
            "question": "Konum izni kullanıcı tarafından reddedilirse ne yapılmalıdır?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Uygulama crash olmalı",
              "Kullanıcıya alternatif sunulmalı veya özellik kısıtlanmalı",
              "Hiçbir şey yapılmaz",
              "Otomatik tekrar istenmeli"
            ],
            "correctAnswerIndex": 1,
            "explanation": "İzin reddedilirse kullanıcıya alternatif sunulmalı (manuel konum girişi) veya konum gerektirmeyen özellikler kullanılmalıdır. Sürekli izin istemek kötü kullanıcı deneyimine yol açar.",
            "tags": ["location", "permission", "ux"]
          },
          {
            "questionId": 370006,
            "question": "Harita üzerinde birden fazla marker eklenebilir mi?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "easy",
            "options": [
              "Hayır, sadece 1 marker",
              "Evet, istediğiniz kadar marker eklenebilir",
              "En fazla 10 marker",
              "Sadece 2 marker"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Google Maps'e istediğiniz kadar marker ekleyebilirsiniz. Çok sayıda marker için clustering kullanılması önerilir.",
            "tags": ["google_maps", "marker"]
          },
          {
            "questionId": 370007,
            "question": "Polyline'a renk ve kalınlık eklenebilir mi?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "medium",
            "options": [
              "Hayır, sadece varsayılan görünüm",
              "Evet, color() ve width() ile özelleştirilebilir",
              "Sadece renk değiştirilebilir",
              "Sadece kalınlık değiştirilebilir"
            ],
            "correctAnswerIndex": 1,
            "explanation": "PolylineOptions'a color() ve width() metotları ile renk ve kalınlık eklenebilir. Örnek: PolylineOptions().color(Color.BLUE).width(10f)",
            "tags": ["google_maps", "polyline", "customization"]
          },
          {
            "questionId": 370008,
            "question": "Google Maps'te harita türleri (map types) nelerdir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Sadece normal",
              "Normal, Satellite, Terrain, Hybrid",
              "Sadece satellite",
              "Normal ve dark mode"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Google Maps 4 temel harita türünü destekler: Normal (yol haritası), Satellite (uydu görüntüsü), Terrain (arazi), Hybrid (uydu + yollar).",
            "tags": ["google_maps", "map_types"]
          },
          {
            "questionId": 370009,
            "question": "Background'da sürekli konum takibi yapmak için ne gerekir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "Sadece ACCESS_FINE_LOCATION",
              "ACCESS_BACKGROUND_LOCATION izni ve Foreground Service",
              "Hiçbir şey gerekmez",
              "Sadece GPS açık olmalı"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Android 10+ için background'da konum takibi yapmak için ACCESS_BACKGROUND_LOCATION izni ve kullanıcıya bildirim gösteren Foreground Service gereklidir.",
            "tags": ["location", "background", "permission"]
          },
          {
            "questionId": 370010,
            "question": "Directions API'den alınan rota bilgisi hangi formatta gelir?",
            "questionType": "multiple_choice",
            "code": null,
            "difficulty": "hard",
            "options": [
              "XML",
              "JSON",
              "Binary",
              "CSV"
            ],
            "correctAnswerIndex": 1,
            "explanation": "Directions API, rota bilgisini JSON formatında döner. Bu JSON içinde encoded polyline, distance, duration gibi bilgiler bulunur.",
            "tags": ["directions_api", "json", "route"]
          }
        ]
      }
      ],
      "interviewQuestions": [
      {
        "questionId": 390001,
        "question": "RecyclerView'in ListView'a göre avantajları nelerdir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Sadece daha hızlıdır",
          "ViewHolder pattern zorunludur, daha performanslı ve esnek layout manager desteği",
          "Sadece daha kolay kullanılır",
          "Hiçbir fark yok"
        ],
        "correctAnswerIndex": 1,
        "explanation": "RecyclerView, ViewHolder pattern'i zorunlu kılar, daha performanslı çalışır ve LinearLayoutManager, GridLayoutManager, StaggeredGridLayoutManager gibi esnek layout seçenekleri sunar.",
        "tags": ["recyclerview", "performance", "viewholder"]
      },
      {
        "questionId": 390002,
        "question": "Fragment yaşam döngüsünde onCreateView() metodunun amacı nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "easy",
        "options": [
          "Fragment'i yok eder",
          "Fragment'in UI'ını oluşturur ve View döner",
          "Activity'yi başlatır",
          "Veritabanı bağlantısı açar"
        ],
        "correctAnswerIndex": 1,
        "explanation": "onCreateView(), Fragment'in layout'unu inflate ederek View oluşturur ve döner. UI başlatma işlemleri burada yapılır.",
        "tags": ["fragment", "lifecycle", "oncreateview"]
      },
      {
        "questionId": 390003,
        "question": "Room veritabanında @Entity annotation'ı ne işe yarar?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "easy",
        "options": [
          "DAO tanımlar",
          "Veritabanı tablosunu temsil eden sınıfı işaretler",
          "Query yazar",
          "TypeConverter tanımlar"
        ],
        "correctAnswerIndex": 1,
        "explanation": "@Entity annotation'ı, bir sınıfın Room veritabanında tablo olarak kullanılacağını belirtir.",
        "tags": ["room", "entity", "database"]
      },
      {
        "questionId": 390004,
        "question": "MVVM mimarisinde ViewModel'in temel sorumluluğu nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "UI çizmek",
          "İş mantığını yönetmek ve UI state'ini tutmak",
          "Veritabanı oluşturmak",
          "Navigation yapmak"
        ],
        "correctAnswerIndex": 1,
        "explanation": "ViewModel, iş mantığını (business logic) yönetir, UI state'ini tutar ve configuration change'lerde hayatta kalır. UI ile iş mantığını ayırır.",
        "tags": ["mvvm", "viewmodel", "architecture"]
      },
      {
        "questionId": 390005,
        "question": "Retrofit ile API çağrısı yaparken hangi yöntem önerilir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Main thread'de çağrı",
          "Coroutines veya RxJava ile asenkron çağrı",
          "Senkron çağrı",
          "Timer ile çağrı"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Network işlemleri main thread'de yapılamaz (NetworkOnMainThreadException). Coroutines (suspend fun) veya RxJava ile asenkron yapılmalıdır.",
        "tags": ["retrofit", "coroutines", "async"]
      },
      {
        "questionId": 390006,
        "question": "Firebase Firestore'un gerçek zamanlı (real-time) olması ne anlama gelir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "easy",
        "options": [
          "Sadece hızlı çalışır",
          "Veri değiştiğinde tüm dinleyen client'lara anında bildirim gider",
          "Offline çalışır",
          "Sadece bulut tabanlıdır"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Firestore'da addSnapshotListener ile veri dinlendiğinde, veri değiştiğinde tüm client'lar anında güncellenir (real-time sync).",
        "tags": ["firebase", "firestore", "realtime"]
      },
      {
        "questionId": 390007,
        "question": "Google Maps'te kullanıcının mevcut konumunu almak için hangi API önerilir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "LocationManager",
          "FusedLocationProviderClient",
          "GPS",
          "SharedPreferences"
        ],
        "correctAnswerIndex": 1,
        "explanation": "FusedLocationProviderClient, Google Play Services'in bir parçasıdır ve battery-efficient konum almak için önerilen modern API'dir.",
        "tags": ["location", "google_maps", "fused_location"]
      },
      {
        "questionId": 390008,
        "question": "RecyclerView.Adapter'da DiffUtil kullanmanın avantajı nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "hard",
        "options": [
          "Sadece kod kısalır",
          "Liste değişikliklerini hesaplar ve sadece değişen item'ları günceller (performans artışı)",
          "Sadece animasyon ekler",
          "Hiçbir fark yok"
        ],
        "correctAnswerIndex": 1,
        "explanation": "DiffUtil, eski ve yeni liste arasındaki farkları hesaplar ve sadece değişen item'ları günceller. notifyDataSetChanged() yerine kullanılarak performans artışı sağlar.",
        "tags": ["recyclerview", "diffutil", "performance"]
      },
      {
        "questionId": 390009,
        "question": "Fragment'ler arasında veri paylaşmanın modern yöntemi nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Static değişkenler",
          "SharedViewModel veya Navigation Safe Args",
          "Singleton pattern",
          "Bundle ile her seferinde geçiş"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Modern yöntem, SharedViewModel (Activity scope'lu ViewModel) veya Navigation Component'in Safe Args özelliği kullanmaktır. Type-safe ve lifecycle-aware çözümlerdir.",
        "tags": ["fragment", "viewmodel", "navigation"]
      },
      {
        "questionId": 390010,
        "question": "Room veritabanında @Dao nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "easy",
        "options": [
          "Veritabanı tablosu",
          "Veritabanı sorgu metodlarını içeren interface",
          "Entity sınıfı",
          "TypeConverter"
        ],
        "correctAnswerIndex": 1,
        "explanation": "@Dao (Data Access Object), veritabanı sorgu metodlarını (@Query, @Insert, @Update, @Delete) içeren interface veya abstract class'tır.",
        "tags": ["room", "dao", "database"]
      },
      {
        "questionId": 390011,
        "question": "MVVM'de LiveData'nın avantajı nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Sadece veri tutar",
          "Lifecycle-aware'dir, memory leak önler ve UI otomatik günceller",
          "Sadece veritabanı için kullanılır",
          "Sadece Fragment'lerde çalışır"
        ],
        "correctAnswerIndex": 1,
        "explanation": "LiveData lifecycle-aware'dir (Activity/Fragment yaşam döngüsünü bilir), memory leak önler ve veri değiştiğinde UI'ı otomatik günceller.",
        "tags": ["mvvm", "livedata", "lifecycle"]
      },
      {
        "questionId": 390012,
        "question": "Retrofit'te @Body annotation'ı hangi HTTP metodlarında kullanılır?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Sadece GET",
          "POST, PUT, PATCH gibi request body gerektiren metodlarda",
          "Sadece DELETE",
          "Tüm HTTP metodlarında"
        ],
        "correctAnswerIndex": 1,
        "explanation": "@Body, POST, PUT, PATCH gibi request body gerektiren HTTP metodlarında kullanılır. GET ve DELETE'de body yoktur.",
        "tags": ["retrofit", "body", "http"]
      },
      {
        "questionId": 390013,
        "question": "Firebase Authentication ile Firestore Security Rules'ı birlikte kullanmanın amacı nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "hard",
        "options": [
          "Sadece hız artışı",
          "Kullanıcı kimlik doğrulama ve veri erişim kontrolü sağlamak",
          "Sadece offline destek",
          "Sadece UI iyileştirmesi"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Authentication ile kullanıcı kimliği doğrulanır, Security Rules ile her kullanıcının sadece kendi verilerine erişmesi sağlanır (request.auth.uid kontrolü).",
        "tags": ["firebase", "authentication", "security"]
      },
      {
        "questionId": 390014,
        "question": "Navigation Component'in avantajları nelerdir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Sadece animasyon ekler",
          "Fragment geçişlerini yönetir, Safe Args ile type-safe veri aktarımı, deep link desteği",
          "Sadece Activity geçişleri içindir",
          "Veritabanı yönetir"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Navigation Component, Fragment geçişlerini kolaylaştırır, Safe Args ile type-safe veri aktarımı, deep link, back stack yönetimi ve görsel navigation graph sağlar.",
        "tags": ["navigation", "fragment", "safe_args"]
      },
      {
        "questionId": 390015,
        "question": "Room'da TypeConverter ne için kullanılır?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "hard",
        "options": [
          "SQL sorguları yazmak",
          "Room'un desteklemediği veri tiplerini (Date, List vb.) dönüştürmek",
          "Entity oluşturmak",
          "Veritabanı versiyonu yükseltmek"
        ],
        "correctAnswerIndex": 1,
        "explanation": "TypeConverter, Room'un natively desteklemediği veri tiplerini (Date, List, custom object) primitive tiplere (Long, String) dönüştürmek için kullanılır.",
        "tags": ["room", "typeconverter", "database"]
      },
      {
        "questionId": 390016,
        "question": "Repository pattern'in MVVM'deki rolü nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "hard",
        "options": [
          "UI çizer",
          "Veri kaynaklarını (API, Database) yönetir ve ViewModel'e tek bir veri akışı sunar",
          "Sadece network işlemleri yapar",
          "Kullanıcı giriş kontrolü yapar"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Repository, veri kaynaklarını (Retrofit, Room, SharedPreferences) soyutlar ve ViewModel'e tek bir clean data interface sunar. Single source of truth sağlar.",
        "tags": ["mvvm", "repository", "architecture"]
      },
      {
        "questionId": 390017,
        "question": "RecyclerView'da ViewHolder pattern'in amacı nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "easy",
        "options": [
          "Sadece görsel iyileştirme",
          "findViewById çağrılarını önbelleğe alarak performansı artırmak",
          "Animasyon eklemek",
          "Veritabanı yönetimi"
        ],
        "correctAnswerIndex": 1,
        "explanation": "ViewHolder pattern, findViewById çağrılarını önbelleğe alır. Her scroll'da aynı view'lar yeniden kullanılır (recycling), performans büyük ölçüde artar.",
        "tags": ["recyclerview", "viewholder", "performance"]
      },
      {
        "questionId": 390018,
        "question": "Kotlin Coroutines'de suspend function ne demektir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "medium",
        "options": [
          "Fonksiyon çalışmaz",
          "Fonksiyon askıya alınabilir (pausable) ve main thread'i bloklamadan çalışır",
          "Sadece arka planda çalışır",
          "Fonksiyon silinemez"
        ],
        "correctAnswerIndex": 1,
        "explanation": "suspend function, coroutine içinde askıya alınabilir (suspend edilebilir). Main thread'i bloklamadan asenkron işlemler yapar. Retrofit ve Room ile uyumludur.",
        "tags": ["coroutines", "suspend", "async"]
      },
      {
        "questionId": 390019,
        "question": "Firebase Storage ve Firestore arasındaki fark nedir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "easy",
        "options": [
          "İkisi de aynıdır",
          "Storage dosya/medya saklar, Firestore yapılandırılmış veri saklar",
          "Storage daha yavaştır",
          "Firestore sadece resim saklar"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Firebase Storage, büyük dosyaları ve medyayı (resim, video, PDF) saklar. Firestore ise NoSQL database olarak yapılandırılmış verileri (user info, posts) saklar.",
        "tags": ["firebase", "storage", "firestore"]
      },
      {
        "questionId": 390020,
        "question": "Android'de background'da konum takibi için ne gereklidir?",
        "questionType": "multiple_choice",
        "code": null,
        "difficulty": "hard",
        "options": [
          "Sadece ACCESS_FINE_LOCATION",
          "ACCESS_BACKGROUND_LOCATION izni ve Foreground Service",
          "Hiçbir şey gerekmez",
          "Sadece GPS açık olmalı"
        ],
        "correctAnswerIndex": 1,
        "explanation": "Android 10+ için background konum takibi yapmak için ACCESS_BACKGROUND_LOCATION izni ve kullanıcıya notification gösteren Foreground Service gereklidir.",
        "tags": ["location", "background", "foreground_service"]
      }
    ]
    },
    {
      "categoryId": 4,
      "categoryTitle": "Android İleri Seviye & Profesyonel",
      "categoryDescription": "Modern Android uygulamalarında performans, ölçeklenebilirlik ve profesyonel mimari kurmak için ileri seviye konular",
      "order": 4,
      "sections": [
        {
          "sectionId": 4100,
          "sectionTitle": "Coroutines & Asenkron Programlama",
          "sectionDescription": "Android uygulamalarda asenkron işlemleri güvenli, okunabilir ve performanslı şekilde yönetmek için Kotlin Coroutines kullanımı",
          "order": 1,
          "topics": [
            {
              "topicId": 4101,
              "title": "Asenkron Programlama Nedir",
              "summary": "Asenkron programlama, uzun süren işlemlerin (network, veritabanı vb.) ana thread'i bloklamadan arka planda çalıştırılmasını sağlar. Android'de UI performansı için kritik öneme sahiptir.",
              "content": "## Asenkron Programlama\n\nAndroid'de ana thread UI işlemlerini yürütür.\n\nUzun süren işlemler ANR hatasına yol açabilir.\n\nAsenkron yapı performans ve kullanıcı deneyimi sağlar.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "UI thread bloklanmamalıdır",
                "Network ve DB işlemleri arka planda çalışmalıdır",
                "Yanlış kullanım ANR hatasına sebep olur",
                "Asenkron yapı UX'i iyileştirir"
              ],
              "questions": [
                {
                  "questionId": 410101,
                  "question": "Asenkron programlama nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece UI işlemleri",
                    "Uzun süren işlemlerin ana thread'i bloklamadan arka planda çalıştırılması",
                    "Sadece veritabanı işlemleri",
                    "Senkron programlamanın tersi değildir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Asenkron programlama, uzun süren işlemlerin (network, veritabanı) ana thread'i bloklamadan arka planda çalıştırılmasını sağlar.",
                  "tags": ["async", "temel"]
                },
                {
                  "questionId": 410102,
                  "question": "Android'de UI thread neden bloklanmamalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece performans düşer",
                    "ANR (Application Not Responding) hatasına ve donma yaşanmasına yol açar",
                    "Veritabanı silinir",
                    "Hiçbir şey olmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UI thread bloklanırsa uygulama donar ve 5 saniyeden fazla yanıt vermezse ANR hatası oluşur, bu da kötü kullanıcı deneyimine yol açar.",
                  "tags": ["ui_thread", "anr"]
                },
                {
                  "questionId": 410103,
                  "question": "Hangi işlemler asenkron olarak yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece UI çizimi",
                    "Network istekleri, veritabanı işlemleri, dosya okuma/yazma",
                    "Sadece Toast gösterme",
                    "Sadece Button tıklama"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Network istekleri, veritabanı işlemleri, dosya okuma/yazma gibi uzun süren işlemler asenkron yapılmalıdır. UI işlemleri ise main thread'de yapılır.",
                  "tags": ["async", "operations"]
                }
              ]
            },
            {
              "topicId": 4102,
              "title": "Coroutine Nedir",
              "summary": "Coroutine, Kotlin tarafından sunulan hafif ve güçlü bir asenkron programlama çözümüdür. Callback ve Thread karmaşasını ortadan kaldırır.",
              "content": "## Coroutine\n\nCoroutine'ler lightweight yapılardır.\n\nThread yönetimini geliştiriciden alır.\n\nOkunabilir ve güvenli kod yazmayı sağlar.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Basit Coroutine",
                  "code": "GlobalScope.launch {\n    delay(1000)\n    println(\"Coroutine çalıştı\")\n}",
                  "explanation": "Basit bir coroutine başlatma örneği."
                }
              ],
              "keyPoints": [
                "Thread'e göre daha hafiftir",
                "Callback hell'i ortadan kaldırır",
                "Suspend fonksiyonlar kullanılır",
                "Modern Android'in temelidir"
              ],
              "questions": [
                {
                  "questionId": 410201,
                  "question": "Coroutine nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece thread yönetimi",
                    "Kotlin'in sunduğu hafif ve güçlü asenkron programlama çözümü",
                    "Sadece network kütüphanesi",
                    "Veritabanı aracı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutine, Kotlin tarafından sunulan hafif (lightweight) ve güçlü bir asenkron programlama çözümüdür.",
                  "tags": ["coroutine", "temel"]
                },
                {
                  "questionId": 410202,
                  "question": "Coroutine'in Thread'e göre avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha yavaştır",
                    "Daha hafiftir (lightweight), callback hell'i ortadan kaldırır",
                    "Sadece daha karmaşıktır",
                    "Hiçbir fark yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutine'ler Thread'lere göre çok daha hafiftir, binlerce coroutine aynı anda çalışabilir. Ayrıca callback yapısını ortadan kaldırarak okunabilir kod sağlar.",
                  "tags": ["coroutine", "thread", "advantage"]
                },
                {
                  "questionId": 410203,
                  "question": "Coroutine'de callback hell problemi nasıl çözülür?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Çözülmez",
                    "Suspend fonksiyonlar ile sıralı (sequential) kod yazılır",
                    "Daha fazla callback kullanılır",
                    "Sadece Thread kullanılır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutine'lerde suspend fonksiyonlar sayesinde asenkron kod sıralı (sequential) şekilde yazılır, callback zincirleri ortadan kalkar.",
                  "tags": ["coroutine", "callback_hell"]
                },
                {
                  "questionId": 410204,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "GlobalScope.launch {\n    delay(1000)\n    println(\"Coroutine çalıştı\")\n}",
                  "difficulty": "easy",
                  "options": [
                    "1 saniye thread'i bloklar",
                    "1 saniye bekler (askıya alır) sonra mesaj yazdırır",
                    "Hata verir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "launch bir coroutine başlatır, delay(1000) 1 saniye askıya alır (thread bloklamadan), sonra mesaj yazdırır.",
                  "tags": ["coroutine", "launch", "delay"]
                }
              ]
            },
            {
              "topicId": 4103,
              "title": "Suspend Fonksiyonlar",
              "summary": "Suspend fonksiyonlar, coroutine içerisinde çalışabilen ve execution'ı askıya alabilen özel fonksiyonlardır.",
              "content": "## Suspend Fonksiyonlar\n\nSuspend fonksiyonlar coroutine context içinde çağrılır.\n\nThread bloklamaz.\n\nAsenkron işlemler için kullanılır.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Suspend Fonksiyon",
                  "code": "suspend fun fetchData() {\n    delay(1000)\n}",
                  "explanation": "Suspend fonksiyon örneği."
                }
              ],
              "keyPoints": [
                "Sadece coroutine içinde çağrılır",
                "Thread'i bloklamaz",
                "delay() gibi suspend fonksiyonlar içerir",
                "Asenkron yapının temelidir"
              ],
              "questions": [
                {
                  "questionId": 410301,
                  "question": "Suspend fonksiyon nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Normal bir fonksiyon",
                    "Coroutine içinde çalışabilen ve execution'ı askıya alabilen fonksiyon",
                    "Sadece UI fonksiyonu",
                    "Veritabanı fonksiyonu"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Suspend fonksiyonlar, coroutine içinde çalışabilen ve execution'ı askıya alabilen (pausable) özel fonksiyonlardır.",
                  "tags": ["suspend", "coroutine"]
                },
                {
                  "questionId": 410302,
                  "question": "Suspend fonksiyon nerede çağrılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her yerde",
                    "Sadece coroutine içinde veya başka bir suspend fonksiyon içinde",
                    "Sadece main thread'de",
                    "Sadece Activity'de"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Suspend fonksiyonlar sadece coroutine scope içinde veya başka bir suspend fonksiyon içinde çağrılabilir.",
                  "tags": ["suspend", "scope"]
                },
                {
                  "questionId": 410303,
                  "question": "Suspend fonksiyon thread'i bloklar mı?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Evet, her zaman bloklar",
                    "Hayır, thread'i bloklamadan askıya alır",
                    "Bazen bloklar",
                    "Sadece main thread'i bloklar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Suspend fonksiyonlar thread'i bloklamaz, sadece coroutine'i askıya alır. Thread başka işler yapabilir.",
                  "tags": ["suspend", "thread"]
                },
                {
                  "questionId": 410304,
                  "question": "Aşağıdaki kodda suspend anahtar kelimesinin önemi nedir?",
                  "questionType": "multiple_choice",
                  "code": "suspend fun fetchData() {\n    delay(1000)\n}",
                  "difficulty": "medium",
                  "options": [
                    "Sadece görsel amaçlı",
                    "Fonksiyonun coroutine içinde çağrılabileceğini ve askıya alınabileceğini belirtir",
                    "Fonksiyonu durdurur",
                    "Hata önler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "suspend keyword, fonksiyonun coroutine context içinde çağrılabileceğini ve execution'ı askıya alabileceğini belirtir. delay() gibi suspend fonksiyonlar içerebilir.",
                  "tags": ["suspend", "keyword"]
                }
              ]
            },
            {
              "topicId": 4104,
              "title": "Coroutine Scope & Dispatcher",
              "summary": "Coroutine Scope, coroutine'in yaşam döngüsünü; Dispatcher ise hangi thread üzerinde çalışacağını belirler.",
              "content": "## Scope & Dispatcher\n\nScope lifecycle ile ilişkilidir.\n\nDispatcher thread yönetimini sağlar.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Dispatcher Kullanımı",
                  "code": "viewModelScope.launch(Dispatchers.IO) {\n    repository.getData()\n}",
                  "explanation": "IO dispatcher ile coroutine çalıştırma."
                }
              ],
              "keyPoints": [
                "viewModelScope lifecycle-aware'dır",
                "Dispatchers.IO: network & DB",
                "Dispatchers.Main: UI",
                "Yanlış dispatcher crash'e yol açabilir"
              ],
              "questions": [
                {
                  "questionId": 410401,
                  "question": "Coroutine Scope nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Thread türü",
                    "Coroutine'in yaşam döngüsünü belirleyen yapı",
                    "Veritabanı bağlantısı",
                    "UI bileşeni"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutine Scope, coroutine'lerin yaşam döngüsünü belirler. Scope iptal edildiğinde içindeki tüm coroutine'ler de iptal olur.",
                  "tags": ["scope", "lifecycle"]
                },
                {
                  "questionId": 410402,
                  "question": "Dispatcher ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece hız artırır",
                    "Coroutine'in hangi thread üzerinde çalışacağını belirler",
                    "Sadece network işlemleri yapar",
                    "UI çizer"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dispatcher, coroutine'in hangi thread veya thread pool üzerinde çalışacağını belirler.",
                  "tags": ["dispatcher", "thread"]
                },
                {
                  "questionId": 410403,
                  "question": "Dispatchers.IO ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI işlemleri",
                    "Network istekleri ve veritabanı işlemleri",
                    "Matematiksel hesaplamalar",
                    "Sadece animasyon"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dispatchers.IO, network istekleri, veritabanı okuma/yazma, dosya işlemleri gibi I/O operasyonları için optimize edilmiş dispatcher'dır.",
                  "tags": ["dispatcher", "io"]
                },
                {
                  "questionId": 410404,
                  "question": "Dispatchers.Main ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı işlemleri",
                    "UI güncellemeleri ve kullanıcı etkileşimleri",
                    "Network istekleri",
                    "Dosya okuma"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dispatchers.Main, Android'de UI thread üzerinde çalışır. UI güncellemeleri ve kullanıcı etkileşimleri için kullanılır.",
                  "tags": ["dispatcher", "main", "ui"]
                },
                {
                  "questionId": 410405,
                  "question": "viewModelScope'un avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece hızlıdır",
                    "ViewModel temizlendiğinde coroutine'leri otomatik iptal eder (lifecycle-aware)",
                    "Sadece network için kullanılır",
                    "Manuel iptal gerektirir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "viewModelScope, ViewModel'in lifecycle'ına bağlıdır. ViewModel temizlendiğinde (onCleared) içindeki tüm coroutine'ler otomatik iptal edilir, memory leak önlenir.",
                  "tags": ["viewmodelscope", "lifecycle"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 410001,
              "question": "Android'de network işlemi main thread'de yapılırsa ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Hiçbir şey olmaz",
                "NetworkOnMainThreadException fırlatılır",
                "Sadece yavaş çalışır",
                "Otomatik düzelir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Android'de main thread'de network işlemi yapılmaya çalışılırsa NetworkOnMainThreadException fırlatılır ve uygulama crash olur.",
              "tags": ["network", "main_thread", "exception"]
            },
            {
              "questionId": 410002,
              "question": "Coroutine'de async ve launch arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "launch sonuç döndürmez, async Deferred<T> döner ve await() ile sonuç alınır",
                "async daha yavaştır",
                "launch kullanımdan kalkmıştır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "launch sadece coroutine başlatır ve Job döner. async ise Deferred<T> döner ve await() ile sonuç alınabilir. Paralel işlemler ve sonuç almak için async kullanılır.",
              "tags": ["async", "launch", "difference"]
            },
            {
              "questionId": 410003,
              "question": "withContext ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Yeni scope oluşturur",
                "Mevcut coroutine'in dispatcher'ını geçici olarak değiştirir",
                "Coroutine'i iptal eder",
                "Sadece hız artırır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "withContext, mevcut coroutine içinde dispatcher'ı geçici olarak değiştirmek için kullanılır. Örneğin IO'da çalışıp sonucu Main'de döndürmek için.",
              "tags": ["withcontext", "dispatcher"]
            },
            {
              "questionId": 410004,
              "question": "Coroutine'de exception handling nasıl yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Exception handle edilemez",
                "try-catch bloğu veya CoroutineExceptionHandler kullanılır",
                "Otomatik handle edilir",
                "Sadece log yazılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Coroutine'lerde exception handling için try-catch bloğu veya CoroutineExceptionHandler kullanılır. Launch ile başlatılan coroutine'lerde CoroutineExceptionHandler tercih edilir.",
              "tags": ["exception", "error_handling"]
            },
            {
              "questionId": 410005,
              "question": "GlobalScope kullanmanın dezavantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir dezavantajı yok",
                "Lifecycle'a bağlı değildir, memory leak riski vardır",
                "Daha yavaştır",
                "Sadece test için kullanılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "GlobalScope, uygulama yaşam döngüsü boyunca yaşar ve lifecycle'a bağlı değildir. Activity/Fragment kapansa bile çalışmaya devam eder, memory leak riski yaratır. viewModelScope veya lifecycleScope tercih edilmelidir.",
              "tags": ["globalscope", "memory_leak"]
            },
            {
              "questionId": 410006,
              "question": "delay() ve Thread.sleep() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir fark yok",
                "delay() thread'i bloklamaz (suspend), Thread.sleep() bloklar",
                "delay() daha yavaştır",
                "Thread.sleep() daha güvenlidir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "delay() suspend fonksiyondur ve thread'i bloklamaz, sadece coroutine'i askıya alır. Thread.sleep() ise thread'i tamamen bloklar.",
              "tags": ["delay", "thread_sleep"]
            },
            {
              "questionId": 410007,
              "question": "Dispatchers.Default ne için kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "UI işlemleri",
                "CPU-intensive işlemler (sıralama, parsing, hesaplama)",
                "Network istekleri",
                "Veritabanı işlemleri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Dispatchers.Default, CPU-intensive işlemler (büyük veri sıralama, JSON parsing, karmaşık hesaplamalar) için optimize edilmiş dispatcher'dır.",
              "tags": ["dispatcher", "default", "cpu"]
            },
            {
              "questionId": 410008,
              "question": "lifecycleScope nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece ViewModel için",
                "Activity/Fragment lifecycle'ına bağlı coroutine scope",
                "Global scope",
                "Sadece Service için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "lifecycleScope, Activity veya Fragment'in lifecycle'ına bağlı bir coroutine scope'tur. Activity/Fragment yok olduğunda coroutine'ler otomatik iptal edilir.",
              "tags": ["lifecyclescope", "lifecycle"]
            },
            {
              "questionId": 410009,
              "question": "Retrofit ile suspend fonksiyon kullanmanın avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece hızlıdır",
                "Callback ihtiyacını ortadan kaldırır, sequential kod yazılır",
                "Sadece daha az kod",
                "Hiçbir fark yok"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Retrofit suspend fonksiyon destekler. Callback yerine direkt sonuç döner ve try-catch ile hata yönetimi yapılır. Kod daha okunabilir ve yönetilebilir olur.",
              "tags": ["retrofit", "suspend", "callback"]
            },
            {
              "questionId": 410010,
              "question": "Coroutine iptal edildiğinde (cancel) ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey olmaz",
                "CancellationException fırlatılır ve coroutine temizlenir",
                "Uygulama crash olur",
                "Coroutine devam eder"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Coroutine iptal edildiğinde CancellationException fırlatılır. finally bloğunda cleanup işlemleri yapılabilir. İptal edilen coroutine yeni suspend fonksiyon çağıramaz.",
              "tags": ["cancel", "cancellation"]
            }
          ]
        },
        {
          "sectionId": 4200,
          "sectionTitle": "Flow & StateFlow",
          "sectionDescription": "Kotlin Flow ile reaktif veri akışı yönetimi ve StateFlow kullanarak UI state yönetimi",
          "order": 2,
          "topics": [
            {
              "topicId": 4201,
              "title": "Flow Nedir",
              "summary": "Flow, Kotlin Coroutines tabanlı soğuk (cold) veri akışı sağlayan reaktif bir yapıdır. Zaman içerisinde birden fazla veri yayını yapabilir.",
              "content": "## Flow Nedir\n\nFlow, async data stream sağlar.\n\nCold stream'dir (collect edilmeden çalışmaz).\n\nCoroutine ile uyumludur.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Flow",
                  "code": "fun numbersFlow(): Flow<Int> = flow {\n    emit(1)\n    emit(2)\n    emit(3)\n}",
                  "explanation": "Basit bir Flow örneği."
                }
              ],
              "keyPoints": [
                "Cold stream'dir",
                "Coroutine tabanlıdır",
                "Birden fazla değer yayabilir",
                "Asenkron veri akışı sağlar"
              ],
              "questions": [
                {
                  "questionId": 420101,
                  "question": "Flow nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece veritabanı aracı",
                    "Kotlin Coroutines tabanlı reaktif veri akışı sağlayan yapı",
                    "Sadece UI bileşeni",
                    "Network kütüphanesi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Flow, Kotlin Coroutines tabanlı soğuk (cold) veri akışı sağlayan reaktif bir yapıdır. Zaman içerisinde birden fazla veri yayabilir.",
                  "tags": ["flow", "temel"]
                },
                {
                  "questionId": 420102,
                  "question": "Flow'un cold stream olması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece soğuk havalarda çalışır",
                    "Collect edilmeden çalışmaz, her collect'te yeniden başlar",
                    "Daha yavaş çalışır",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Cold stream, collect edilmeden çalışmaz. Her collect çağrısında Flow baştan çalışır ve yeni bir veri akışı başlatır.",
                  "tags": ["flow", "cold_stream"]
                },
                {
                  "questionId": 420103,
                  "question": "Flow kaç değer yayabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece 1 değer",
                    "Birden fazla değer (asenkron stream)",
                    "Sadece 2 değer",
                    "Hiç değer yayamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Flow, zaman içerisinde birden fazla değer yayabilir. emit() ile her seferinde yeni bir değer gönderilebilir.",
                  "tags": ["flow", "emit"]
                },
                {
                  "questionId": 420104,
                  "question": "Aşağıdaki Flow'da kaç değer yayınlanır?",
                  "questionType": "multiple_choice",
                  "code": "fun numbersFlow(): Flow<Int> = flow {\n    emit(1)\n    emit(2)\n    emit(3)\n}",
                  "difficulty": "easy",
                  "options": [
                    "1 değer",
                    "2 değer",
                    "3 değer",
                    "Hiç değer yayınlanmaz"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Flow, emit() ile 3 değer (1, 2, 3) yayınlar. Her emit çağrısı bir değer gönderir.",
                  "tags": ["flow", "emit", "values"]
                }
              ]
            },
            {
              "topicId": 4202,
              "title": "Flow Collect",
              "summary": "collect, Flow'dan gelen verileri dinlemek ve işlemek için kullanılan suspend fonksiyondur.",
              "content": "## Collect\n\nFlow collect edilmeden çalışmaz.\n\nSuspend fonksiyondur.\n\nCoroutine scope içinde çağrılır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Flow Collect",
                  "code": "lifecycleScope.launch {\n    numbersFlow().collect {\n        println(it)\n    }\n}",
                  "explanation": "Flow collect örneği."
                }
              ],
              "keyPoints": [
                "Suspend fonksiyondur",
                "Coroutine scope gerektirir",
                "Flow başlatır",
                "UI lifecycle ile birlikte çalışır"
              ],
              "questions": [
                {
                  "questionId": 420201,
                  "question": "Flow'dan veri almak için ne kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "get()",
                    "collect()",
                    "fetch()",
                    "observe()"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collect(), Flow'dan gelen verileri dinlemek ve işlemek için kullanılan suspend fonksiyondur.",
                  "tags": ["flow", "collect"]
                },
                {
                  "questionId": 420202,
                  "question": "collect() nerede çağrılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her yerde",
                    "Sadece coroutine scope içinde",
                    "Sadece main thread'de",
                    "Sadece Activity'de"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collect() bir suspend fonksiyondur ve sadece coroutine scope içinde (lifecycleScope, viewModelScope vb.) çağrılabilir.",
                  "tags": ["flow", "collect", "scope"]
                },
                {
                  "questionId": 420203,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "lifecycleScope.launch {\n    numbersFlow().collect {\n        println(it)\n    }\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hiçbir şey yapmaz",
                    "Flow'u başlatır ve her değeri yazdırır",
                    "Sadece ilk değeri yazdırır",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "lifecycleScope içinde Flow collect edilir ve her emit edilen değer (it) konsola yazdırılır.",
                  "tags": ["flow", "collect", "lifecyclescope"]
                }
              ]
            },
            {
              "topicId": 4203,
              "title": "StateFlow Nedir",
              "summary": "StateFlow, her zaman güncel bir state tutan ve yeni observer'lara son değeri anında ileten sıcak (hot) bir Flow türüdür.",
              "content": "## StateFlow\n\nHot stream'dir.\n\nHer zaman bir initial değeri vardır.\n\nUI state yönetimi için idealdir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "StateFlow Tanımı",
                  "code": "private val _uiState = MutableStateFlow(0)\nval uiState: StateFlow<Int> = _uiState",
                  "explanation": "StateFlow tanımlama."
                }
              ],
              "keyPoints": [
                "Hot stream'dir",
                "Initial value zorunludur",
                "Son değeri saklar",
                "UI state için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 420301,
                  "question": "StateFlow nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece veritabanı",
                    "Her zaman güncel bir state tutan hot Flow türü",
                    "Sadece network için",
                    "Cold stream"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow, her zaman güncel bir state tutan ve yeni observer'lara son değeri anında ileten sıcak (hot) bir Flow türüdür.",
                  "tags": ["stateflow", "temel"]
                },
                {
                  "questionId": 420302,
                  "question": "StateFlow'un hot stream olması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Daha hızlıdır",
                    "Collect edilmese bile aktiftir, yeni observer'a son değeri hemen verir",
                    "Sadece sıcak havalarda çalışır",
                    "Cold stream ile aynıdır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hot stream, collect edilmese bile aktiftir. StateFlow her zaman bir değer tutar ve yeni observer geldiğinde son değeri anında iletir.",
                  "tags": ["stateflow", "hot_stream"]
                },
                {
                  "questionId": 420303,
                  "question": "StateFlow tanımlarken ne zorunludur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Hiçbir şey",
                    "Initial (başlangıç) değeri",
                    "Sadece tip",
                    "Sadece isim"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow tanımlanırken mutlaka bir initial (başlangıç) değeri verilmelidir. StateFlow her zaman bir değer tutar.",
                  "tags": ["stateflow", "initial_value"]
                },
                {
                  "questionId": 420304,
                  "question": "StateFlow ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece network işlemleri",
                    "UI state yönetimi ve reaktif data flow",
                    "Sadece veritabanı",
                    "Sadece animasyon"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow, UI state yönetimi için idealdir. ViewModel'de UI state'i tutar ve UI tarafından observe edilir.",
                  "tags": ["stateflow", "ui_state"]
                }
              ]
            },
            {
              "topicId": 4204,
              "title": "Flow vs LiveData",
              "summary": "Flow ve LiveData benzer amaçlara hizmet etse de Flow daha esnek ve güçlüdür. Modern Android geliştirmede Flow tercih edilir.",
              "content": "## Flow vs LiveData\n\nFlow coroutine tabanlıdır.\n\nLiveData lifecycle-aware'dır.\n\nStateFlow lifecycle bağımsızdır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Flow daha esnektir",
                "LiveData XML uyumludur",
                "StateFlow lifecycle'dan bağımsızdır",
                "Modern projelerde Flow önerilir"
              ],
              "questions": [
                {
                  "questionId": 420401,
                  "question": "Flow ve LiveData arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Flow coroutine tabanlı ve daha esnektir, LiveData lifecycle-aware'dır",
                    "LiveData daha hızlıdır",
                    "Flow kullanımdan kalkmıştır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Flow, coroutine tabanlıdır ve daha esnek operatörler sunar. LiveData ise lifecycle-aware'dır ancak daha sınırlıdır.",
                  "tags": ["flow", "livedata", "comparison"]
                },
                {
                  "questionId": 420402,
                  "question": "Modern Android projelerinde hangisi önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "LiveData",
                    "Flow (özellikle StateFlow)",
                    "İkisi de eşit",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modern Android geliştirmede Flow (özellikle StateFlow) önerilir. Daha esnek, coroutine ile uyumlu ve güçlü operatörler sunar.",
                  "tags": ["flow", "stateflow", "best_practice"]
                },
                {
                  "questionId": 420403,
                  "question": "StateFlow'un LiveData'ya göre avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha hızlı",
                    "Lifecycle'dan bağımsız, coroutine operatörleri kullanılabilir",
                    "Sadece daha az kod",
                    "LiveData'dan daha yavaş"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow, lifecycle'dan bağımsızdır ve map, filter gibi coroutine Flow operatörleri kullanılabilir. Daha esnek ve test edilebilir.",
                  "tags": ["stateflow", "livedata", "advantage"]
                },
                {
                  "questionId": 420404,
                  "question": "LiveData'nın hala kullanılabileceği durum nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir zaman kullanılmamalı",
                    "XML Data Binding ile uyumlu olduğu için eski projelerde",
                    "Her zaman tercih edilmeli",
                    "Sadece test için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LiveData, XML Data Binding ile doğrudan uyumludur. Eski projeler veya XML Data Binding kullanılan durumlarda hala kullanılabilir.",
                  "tags": ["livedata", "databinding", "legacy"]
                }
              ]
            },
            {
              "topicId": 4205,
              "title": "ViewModel + StateFlow Kullanımı",
              "summary": "StateFlow genellikle ViewModel içinde tanımlanır ve UI tarafından observe edilir.",
              "content": "## ViewModel + StateFlow\n\nUI state ViewModel'de tutulur.\n\nLifecycle ile collect edilir.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "StateFlow Observe",
                  "code": "lifecycleScope.launch {\n    viewModel.uiState.collect {\n        textView.text = it.toString()\n    }\n}",
                  "explanation": "UI tarafında StateFlow collect edilmesi."
                }
              ],
              "keyPoints": [
                "StateFlow ViewModel'de tutulur",
                "UI sadece observe eder",
                "Tek yönlü data flow sağlar",
                "MVVM ile uyumludur"
              ],
              "questions": [
                {
                  "questionId": 420501,
                  "question": "StateFlow genellikle nerede tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Activity'de",
                    "ViewModel'de",
                    "Fragment'te",
                    "Repository'de"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow genellikle ViewModel içinde tanımlanır ve UI state'ini tutar. UI tarafından observe edilir.",
                  "tags": ["stateflow", "viewmodel"]
                },
                {
                  "questionId": 420502,
                  "question": "ViewModel'de StateFlow tanımlarken MutableStateFlow neden private tutulur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Performans için",
                    "Encapsulation: UI sadece okusun, değiştirmesin (tek yönlü data flow)",
                    "Zorunlu değildir",
                    "Hata önlemek için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MutableStateFlow private tutulur, dışarıya read-only StateFlow expose edilir. Bu sayede UI sadece observe eder, değiştiremez (tek yönlü data flow).",
                  "tags": ["stateflow", "encapsulation", "mutable"]
                },
                {
                  "questionId": 420503,
                  "question": "Aşağıdaki kodda StateFlow nasıl güncellenir?",
                  "questionType": "multiple_choice",
                  "code": "private val _uiState = MutableStateFlow(0)\nval uiState: StateFlow<Int> = _uiState",
                  "difficulty": "medium",
                  "options": [
                    "uiState.value = 5",
                    "_uiState.value = 5",
                    "uiState.update(5)",
                    "Güncellenemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MutableStateFlow'un value property'si ile güncellenir: _uiState.value = 5. uiState read-only olduğu için güncellenemez.",
                  "tags": ["stateflow", "update", "value"]
                },
                {
                  "questionId": 420504,
                  "question": "UI tarafında StateFlow'u lifecycle-aware şekilde nasıl collect etmeliyiz?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "GlobalScope.launch { collect }",
                    "lifecycleScope.launch { repeatOnLifecycle(STARTED) { collect } }",
                    "Thread içinde",
                    "Doğrudan collect"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow'u lifecycle-aware şekilde collect etmek için lifecycleScope ve repeatOnLifecycle(STARTED) kullanılmalıdır. Bu, Activity/Fragment arka plandayken collect'i durdurur.",
                  "tags": ["stateflow", "lifecycle", "repeatonlifecycle"]
                },
                {
                  "questionId": 420505,
                  "question": "ViewModel + StateFlow kullanımının MVVM'deki rolü nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece veri saklar",
                    "Tek yönlü data flow sağlar: ViewModel state tutar, UI sadece observe eder",
                    "Sadece network işlemleri yapar",
                    "Veritabanı yönetir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewModel'de StateFlow ile UI state tutulur, UI sadece observe eder ve state'e göre kendini günceller. Bu, MVVM'de tek yönlü data flow ve separation of concerns sağlar.",
                  "tags": ["mvvm", "stateflow", "viewmodel", "unidirectional"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 420001,
              "question": "Flow operatörleri (map, filter) ne için kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece görsel için",
                "Flow'daki verileri dönüştürmek ve filtrelemek",
                "Sadece hata yönetimi",
                "Flow'u iptal eder"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Flow operatörleri (map, filter, transform vb.), Flow'dan gelen verileri dönüştürmek, filtrelemek ve işlemek için kullanılır.",
              "tags": ["flow", "operators"]
            },
            {
              "questionId": 420002,
              "question": "SharedFlow nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Cold stream",
                "Hot stream, birden fazla collector'a aynı anda yayın yapabilir",
                "StateFlow ile aynı",
                "Kullanımdan kalkmıştır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SharedFlow, hot stream'dir ve birden fazla collector'a aynı anda yayın yapabilir. Event-driven yapılar için kullanılır (örn: one-time events, navigation).",
              "tags": ["sharedflow", "hot_stream"]
            },
            {
              "questionId": 420003,
              "question": "StateFlow ve SharedFlow arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "StateFlow her zaman bir state tutar, SharedFlow event-driven'dır",
                "SharedFlow daha yavaştır",
                "StateFlow kullanımdan kalkmıştır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "StateFlow her zaman bir state (değer) tutar ve yeni observer'a son değeri verir. SharedFlow ise event-driven'dır, geçmiş değerleri tutmayabilir.",
              "tags": ["stateflow", "sharedflow", "difference"]
            },
            {
              "questionId": 420004,
              "question": "Flow'da exception handling nasıl yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Exception handle edilemez",
                "try-catch veya catch operatörü kullanılır",
                "Otomatik handle edilir",
                "Sadece log yazılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Flow'da exception handling için try-catch bloğu veya catch { } operatörü kullanılır. catch operatörü Flow chain'inde upstream exception'ları yakalar.",
              "tags": ["flow", "exception", "catch"]
            },
            {
              "questionId": 420005,
              "question": "flowOn() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Flow'u iptal eder",
                "Flow'un hangi dispatcher'da çalışacağını belirler",
                "Flow'u başlatır",
                "Sadece hız artırır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "flowOn() operatörü, Flow'un upstream kısmının hangi dispatcher üzerinde çalışacağını belirler. Örneğin flowOn(Dispatchers.IO) ile IO thread'de çalıştırılabilir.",
              "tags": ["flow", "flowon", "dispatcher"]
            },
            {
              "questionId": 420006,
              "question": "stateIn() operatörü ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Flow'u iptal eder",
                "Cold Flow'u hot StateFlow'a dönüştürür",
                "Sadece hata yakalar",
                "Flow'u başlatır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "stateIn() operatörü, cold Flow'u hot StateFlow'a dönüştürür. Bu sayede birden fazla collector aynı Flow'u dinleyebilir ve son değer tutulur.",
              "tags": ["flow", "statein", "stateflow"]
            },
            {
              "questionId": 420007,
              "question": "Room Database ile Flow kullanmanın avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece daha hızlı",
                "Veritabanı değiştiğinde otomatik olarak UI güncellenir (reactive)",
                "Sadece daha az kod",
                "Hiçbir fark yok"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Room, Flow döndüren query'leri destekler. Veritabanı değiştiğinde Flow otomatik olarak yeni veriyi yayar ve UI reaktif şekilde güncellenir.",
              "tags": ["flow", "room", "reactive"]
            },
            {
              "questionId": 420008,
              "question": "Retrofit ile Flow kullanmanın amacı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece hız artışı",
                "Asenkron network çağrıları ve reaktif data stream",
                "Sadece hata yönetimi",
                "Kullanılamaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Retrofit ile Flow kullanarak asenkron network çağrıları yapılabilir ve veri reaktif şekilde UI'a iletilebilir. callbackFactory ile Flow desteği eklenir.",
              "tags": ["flow", "retrofit", "network"]
            },
            {
              "questionId": 420009,
              "question": "collectLatest() ve collect() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "collectLatest() yeni değer geldiğinde önceki işlemi iptal eder",
                "collect() daha hızlıdır",
                "collectLatest() kullanımdan kalkmıştır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "collectLatest(), yeni değer geldiğinde önceki collect işlemini iptal eder ve yeni değer ile devam eder. Search gibi hızlı güncellemelerde kullanışlıdır.",
              "tags": ["flow", "collectlatest", "collect"]
            },
            {
              "questionId": 420010,
              "question": "asStateFlow() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Flow'u iptal eder",
                "MutableStateFlow'u read-only StateFlow'a dönüştürür (encapsulation)",
                "StateFlow'u oluşturur",
                "Sadece Compose için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "asStateFlow(), MutableStateFlow'u read-only StateFlow'a dönüştürür. Bu sayede dışarıya sadece okunabilir interface expose edilir (encapsulation).",
              "tags": ["stateflow", "asstateflow", "encapsulation"]
            }
          ]
        },
        {
          "sectionId": 4300,
          "sectionTitle": "Dependency Injection (Hilt)",
          "sectionDescription": "Bağımlılıkları merkezi ve yönetilebilir şekilde sağlamak için kullanılan Hilt tabanlı Dependency Injection yapısı",
          "order": 3,
          "topics": [
            {
              "topicId": 4301,
              "title": "Dependency Injection Nedir",
              "summary": "Dependency Injection (DI), bir sınıfın ihtiyaç duyduğu bağımlılıkları kendisinin oluşturması yerine dışarıdan almasını sağlayan tasarım desenidir.",
              "content": "## Dependency Injection Nedir\n\nDI, sıkı bağımlılıkları azaltır.\n\nKodun test edilebilirliğini artırır.\n\nBakımı ve ölçeklenebilirliği kolaylaştırır.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Sıkı bağımlılığı azaltır",
                "Test yazımını kolaylaştırır",
                "Kod tekrarını önler",
                "Clean Architecture için gereklidir"
              ],
              "questions": [
                {
                  "questionId": 430101,
                  "question": "Dependency Injection (DI) nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece veritabanı aracı",
                    "Bir sınıfın bağımlılıklarını kendisi oluşturması yerine dışarıdan alması",
                    "Sadece UI tasarımı",
                    "Network kütüphanesi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dependency Injection, bir sınıfın ihtiyaç duyduğu bağımlılıkları kendisinin oluşturması yerine dışarıdan almasını sağlayan tasarım desenidir.",
                  "tags": ["dependency_injection", "design_pattern"]
                },
                {
                  "questionId": 430102,
                  "question": "Dependency Injection'ın avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece hız artışı",
                    "Sıkı bağımlılığı azaltır, test edilebilirliği artırır, kod tekrarını önler",
                    "Sadece görsel iyileştirme",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "DI, sıkı bağımlılıkları azaltır, kodun test edilebilirliğini artırır, kod tekrarını önler ve bakımı kolaylaştırır.",
                  "tags": ["dependency_injection", "advantages"]
                },
                {
                  "questionId": 430103,
                  "question": "Dependency Injection hangi mimari yapı için gereklidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece MVC",
                    "Clean Architecture ve MVVM",
                    "Sadece MVP",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "DI, Clean Architecture ve MVVM gibi modern mimari yapılar için gereklidir. Katmanlar arası bağımlılıkları yönetir.",
                  "tags": ["dependency_injection", "architecture"]
                }
              ]
            },
            {
              "topicId": 4302,
              "title": "Hilt Nedir",
              "summary": "Hilt, Android için geliştirilmiş, Dagger üzerine kurulu resmi Dependency Injection kütüphanesidir.",
              "content": "## Hilt Nedir\n\nGoogle tarafından önerilir.\n\nAndroid bileşenleriyle entegredir.\n\nBoilerplate kodu azaltır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Hilt Kurulumu",
                  "code": "@HiltAndroidApp\nclass MyApplication : Application()",
                  "explanation": "Application seviyesinde Hilt başlatma."
                }
              ],
              "keyPoints": [
                "Dagger tabanlıdır",
                "Android'e özeldir",
                "Otomatik lifecycle yönetimi sağlar",
                "Resmi DI çözümüdür"
              ],
              "questions": [
                {
                  "questionId": 430201,
                  "question": "Hilt nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı kütüphanesi",
                    "Android için Dagger tabanlı resmi DI kütüphanesi",
                    "Network kütüphanesi",
                    "UI kütüphanesi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt, Android için geliştirilmiş, Dagger üzerine kurulu resmi Dependency Injection kütüphanesidir.",
                  "tags": ["hilt", "temel"]
                },
                {
                  "questionId": 430202,
                  "question": "Hilt hangi şirket tarafından önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Facebook",
                    "Google",
                    "Microsoft",
                    "Apple"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt, Google tarafından önerilen ve desteklenen resmi Android DI çözümüdür.",
                  "tags": ["hilt", "google"]
                },
                {
                  "questionId": 430203,
                  "question": "Hilt'in Dagger'a göre avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha hızlı",
                    "Android bileşenleriyle entegre, boilerplate kodu azaltır",
                    "Sadece daha az bellek kullanır",
                    "Hiçbir fark yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt, Android bileşenleriyle (Activity, Fragment, ViewModel) entegredir ve Dagger'a göre çok daha az boilerplate kod gerektirir.",
                  "tags": ["hilt", "dagger", "advantage"]
                },
                {
                  "questionId": 430204,
                  "question": "Aşağıdaki kod ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": "@HiltAndroidApp\nclass MyApplication : Application()",
                  "difficulty": "easy",
                  "options": [
                    "Activity oluşturur",
                    "Application seviyesinde Hilt'i başlatır",
                    "ViewModel oluşturur",
                    "Fragment oluşturur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@HiltAndroidApp annotation'ı, Application sınıfına eklenerek Hilt'in uygulama seviyesinde başlatılmasını sağlar.",
                  "tags": ["hilt", "hiltandroidapp"]
                }
              ]
            },
            {
              "topicId": 4303,
              "title": "Hilt Modülleri",
              "summary": "Hilt modülleri, bağımlılıkların nasıl oluşturulacağını tanımlayan sınıflardır.",
              "content": "## Hilt Modülleri\n\n@Module anotasyonu ile tanımlanır.\n\n@Provides veya @Binds kullanılır.\n\nSingleton gibi scope'lar desteklenir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Hilt Module Örneği",
                  "code": "@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n    @Provides\n    fun provideApi(): ApiService {\n        return ApiService.create()\n    }\n}",
                  "explanation": "Basit bir Hilt modül tanımı."
                }
              ],
              "keyPoints": [
                "Bağımlılık tanımı yapılır",
                "Singleton scope desteklenir",
                "Merkezi yapı sağlar",
                "Test için mock edilebilir"
              ],
              "questions": [
                {
                  "questionId": 430301,
                  "question": "Hilt modülleri ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI çizmek",
                    "Bağımlılıkların nasıl oluşturulacağını tanımlamak",
                    "Veritabanı oluşturmak",
                    "Network isteği yapmak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt modülleri, bağımlılıkların nasıl oluşturulacağını ve sağlanacağını tanımlayan sınıflardır.",
                  "tags": ["hilt", "module"]
                },
                {
                  "questionId": 430302,
                  "question": "Hilt modülü tanımlamak için hangi annotation kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "@Inject",
                    "@Module",
                    "@Component",
                    "@HiltModule"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Module annotation'ı ile Hilt modülü tanımlanır. @InstallIn ile hangi component'te kullanılacağı belirtilir.",
                  "tags": ["hilt", "module", "annotation"]
                },
                {
                  "questionId": 430303,
                  "question": "@Provides ve @Binds arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir fark yok",
                    "@Provides concrete tip döner, @Binds interface'i implementasyona bağlar",
                    "@Binds daha yavaştır",
                    "@Provides kullanımdan kalkmıştır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Provides, concrete bir nesne döndürmek için kullanılır. @Binds ise interface'i implementasyona bağlamak için kullanılır (daha performanslıdır).",
                  "tags": ["hilt", "provides", "binds"]
                },
                {
                  "questionId": 430304,
                  "question": "Aşağıdaki Hilt modülü ne sağlar?",
                  "questionType": "multiple_choice",
                  "code": "@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    fun provideApi(): ApiService {\n        return ApiService.create()\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "ViewModel sağlar",
                    "Singleton scope'ta ApiService sağlar",
                    "Fragment sağlar",
                    "Hiçbir şey sağlamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Module, SingletonComponent'e install edildiği için ApiService'i singleton olarak sağlar (uygulama boyunca tek instance).",
                  "tags": ["hilt", "module", "singleton"]
                }
              ]
            },
            {
              "topicId": 4304,
              "title": "Hilt ile ViewModel Kullanımı",
              "summary": "Hilt, ViewModel bağımlılıklarını otomatik olarak sağlayarak constructor injection kullanımını mümkün kılar.",
              "content": "## ViewModel + Hilt\n\nConstructor injection desteklenir.\n\n@HiltViewModel anotasyonu kullanılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Hilt ViewModel",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel()",
                  "explanation": "Hilt ile ViewModel injection."
                }
              ],
              "keyPoints": [
                "Constructor injection kullanılır",
                "ViewModel daha test edilebilir olur",
                "Boilerplate azalır",
                "MVVM ile tam uyumludur"
              ],
              "questions": [
                {
                  "questionId": 430401,
                  "question": "Hilt ile ViewModel nasıl inject edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Manual olarak oluşturulur",
                    "@HiltViewModel annotation'ı ve constructor injection kullanılır",
                    "Factory pattern kullanılır",
                    "Inject edilemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@HiltViewModel annotation'ı ile ViewModel işaretlenir ve constructor'a @Inject eklenerek bağımlılıklar otomatik sağlanır.",
                  "tags": ["hilt", "viewmodel"]
                },
                {
                  "questionId": 430402,
                  "question": "Hilt ile ViewModel kullanmanın avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha hızlı",
                    "Constructor injection kullanılır, test edilebilirlik artar, boilerplate azalır",
                    "Sadece görsel iyileştirme",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt ile ViewModel'de constructor injection kullanılır, bu da test edilebilirliği artırır ve ViewModelProvider.Factory gibi boilerplate kodları ortadan kaldırır.",
                  "tags": ["hilt", "viewmodel", "advantage"]
                },
                {
                  "questionId": 430403,
                  "question": "Aşağıdaki ViewModel'de repository nereden gelir?",
                  "questionType": "multiple_choice",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val repository: UserRepository\n) : ViewModel()",
                  "difficulty": "medium",
                  "options": [
                    "Manuel olarak oluşturulur",
                    "Hilt tarafından otomatik inject edilir",
                    "Activity'den gönderilir",
                    "Fragment'ten gönderilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Inject constructor sayesinde Hilt, repository bağımlılığını otomatik olarak sağlar (Hilt module'den veya @Inject constructor'dan).",
                  "tags": ["hilt", "viewmodel", "injection"]
                },
                {
                  "questionId": 430404,
                  "question": "Hilt ile ViewModel kullanmak MVVM'de nasıl bir rol oynar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece hız artışı",
                    "Separation of concerns sağlar, ViewModel bağımlılıkları merkezi yönetilir",
                    "Sadece UI iyileştirir",
                    "Hiçbir rolü yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt, ViewModel'in bağımlılıklarını merkezi yönetir, separation of concerns sağlar ve MVVM mimarisinde clean code yazmayı kolaylaştırır.",
                  "tags": ["hilt", "viewmodel", "mvvm"]
                }
              ]
            },
            {
              "topicId": 4305,
              "title": "Hilt Scope'ları",
              "summary": "Hilt scope'ları, bağımlılıkların yaşam döngüsünü belirlemek için kullanılır.",
              "content": "## Hilt Scope\n\n@Singleton\n\n@ActivityScoped\n\n@ViewModelScoped gibi scope'lar vardır.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Lifecycle bazlı yönetim sağlar",
                "Bellek kullanımını optimize eder",
                "Yanlış instance oluşumunu önler",
                "Performansı artırır"
              ],
              "questions": [
                {
                  "questionId": 430501,
                  "question": "Hilt scope'ları ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece hız artırır",
                    "Bağımlılıkların yaşam döngüsünü belirler",
                    "Sadece UI çizer",
                    "Veritabanı yönetir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt scope'ları, bağımlılıkların yaşam döngüsünü belirlemek için kullanılır (Singleton, ActivityScoped, ViewModelScoped vb.).",
                  "tags": ["hilt", "scope"]
                },
                {
                  "questionId": 430502,
                  "question": "@Singleton scope ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Her seferinde yeni instance",
                    "Uygulama boyunca tek instance",
                    "Activity başına bir instance",
                    "ViewModel başına bir instance"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Singleton scope, bağımlılığın uygulama boyunca tek bir instance olarak yaşamasını sağlar (Application lifecycle).",
                  "tags": ["hilt", "singleton"]
                },
                {
                  "questionId": 430503,
                  "question": "Hilt'te hangi scope'lar vardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece Singleton",
                    "@Singleton, @ActivityScoped, @ViewModelScoped, @ActivityRetainedScoped vb.",
                    "Sadece ViewModelScoped",
                    "Scope yoktur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt, @Singleton, @ActivityScoped, @FragmentScoped, @ViewModelScoped, @ActivityRetainedScoped gibi birçok scope sunar. Her biri farklı lifecycle'a bağlıdır.",
                  "tags": ["hilt", "scopes"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 430001,
              "question": "Hilt kullanmadan önce hangi annotation Application sınıfına eklenmeli?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "@Inject",
                "@HiltAndroidApp",
                "@Module",
                "@Component"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@HiltAndroidApp annotation'ı Application sınıfına eklenerek Hilt başlatılır. Bu zorunludur.",
              "tags": ["hilt", "setup"]
            },
            {
              "questionId": 430002,
              "question": "Activity'ye Hilt desteği eklemek için hangi annotation kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "@HiltActivity",
                "@AndroidEntryPoint",
                "@HiltAndroidApp",
                "@Inject"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@AndroidEntryPoint annotation'ı Activity, Fragment, Service gibi Android bileşenlerine eklenerek Hilt desteği sağlanır.",
              "tags": ["hilt", "androidentrypoint"]
            },
            {
              "questionId": 430003,
              "question": "Constructor injection ne demektir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Manuel nesne oluşturma",
                "Bağımlılıkların constructor'dan geçilmesi",
                "Setter injection",
                "Field injection"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Constructor injection, bir sınıfın bağımlılıklarının constructor parametreleri olarak geçilmesidir. En tercih edilen DI yöntemidir.",
              "tags": ["dependency_injection", "constructor"]
            },
            {
              "questionId": 430004,
              "question": "@InstallIn annotation'ı ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Module'ü siler",
                "Module'ün hangi component'e kurulacağını belirtir",
                "Sadece hız artırır",
                "Test yapar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@InstallIn, Hilt module'ünün hangi component'e (SingletonComponent, ActivityComponent vb.) kurulacağını belirtir.",
              "tags": ["hilt", "installin"]
            },
            {
              "questionId": 430005,
              "question": "Hilt ile test yazmak neden daha kolaydır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece daha hızlı",
                "Bağımlılıklar mock edilebilir, test modülleri yazılabilir",
                "Sadece daha az kod",
                "Test yazılamaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Hilt ile bağımlılıklar merkezi yönetildiği için kolayca mock edilebilir ve test modülleri yazılabilir. DI test edilebilirliği artırır.",
              "tags": ["hilt", "testing"]
            },
            {
              "questionId": 430006,
              "question": "@Qualifier annotation'ı ne için kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece isim vermek",
                "Aynı tipte birden fazla bağımlılığı ayırt etmek",
                "Module oluşturmak",
                "Scope belirlemek"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@Qualifier, aynı tipte birden fazla bağımlılık olduğunda (örn: 2 farklı Retrofit instance) hangisinin inject edileceğini belirtmek için kullanılır.",
              "tags": ["hilt", "qualifier"]
            },
            {
              "questionId": 430007,
              "question": "Hilt ile Field Injection yerine Constructor Injection neden tercih edilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece daha hızlı",
                "Daha test edilebilir, immutability sağlar, null safety vardır",
                "Sadece daha az kod",
                "Hiçbir fark yok"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Constructor injection daha test edilebilir, field'ları final/val yaparak immutability sağlar ve null safety sunar. Field injection'da bu avantajlar yoktur.",
              "tags": ["dependency_injection", "constructor_vs_field"]
            },
            {
              "questionId": 430008,
              "question": "SingletonComponent ve ActivityComponent arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "SingletonComponent uygulama boyunca, ActivityComponent Activity lifecycle'ı boyunca yaşar",
                "ActivityComponent daha yavaştır",
                "SingletonComponent kullanımdan kalkmıştır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SingletonComponent'e install edilen bağımlılıklar uygulama boyunca yaşar. ActivityComponent'e install edilenler ise sadece Activity lifecycle'ı boyunca yaşar.",
              "tags": ["hilt", "component", "lifecycle"]
            },
            {
              "questionId": 430009,
              "question": "Hilt ile WorkManager entegrasyonu mümkün müdür?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hayır, mümkün değil",
                "Evet, @HiltWorker annotation'ı ile mümkün",
                "Sadece manuel injection ile",
                "Sadece Service'lerde"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Hilt, WorkManager ile entegre edilebilir. @HiltWorker annotation'ı ile Worker sınıflarına dependency injection yapılabilir.",
              "tags": ["hilt", "workmanager"]
            },
            {
              "questionId": 430010,
              "question": "Hilt ile Retrofit instance nasıl sağlanır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Her Activity'de manuel oluşturulur",
                "@Module ve @Provides ile merkezi olarak sağlanır",
                "Sadece Application'da",
                "Sağlanamaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Retrofit instance, Hilt Module içinde @Provides ile merkezi olarak sağlanır ve tüm uygulama genelinde kullanılır (genellikle Singleton scope ile).",
              "tags": ["hilt", "retrofit", "module"]
            }
          ]
        },
        {
          "sectionId": 4400,
          "sectionTitle": "Clean Architecture",
          "sectionDescription": "Uygulamanın katmanlara ayrılarak daha sürdürülebilir, test edilebilir ve ölçeklenebilir hale getirilmesini sağlayan mimari yaklaşım",
          "order": 4,
          "topics": [
            {
              "topicId": 4401,
              "title": "Clean Architecture Nedir",
              "summary": "Clean Architecture, uygulamayı katmanlara ayırarak bağımlılıkların tek yönlü olmasını sağlayan bir mimari yaklaşımdır.",
              "content": "## Clean Architecture Nedir\n\nBu mimari, iş kurallarını framework ve UI bağımlılıklarından ayırır.\n\nMerkezde domain katmanı bulunur.\n\nDış katmanlar iç katmanlara bağımlıdır, tersi mümkün değildir.",
              "difficulty": "hard",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Katmanlı yapı sunar",
                "Bağımlılıklar tek yönlüdür",
                "İş mantığı UI'dan bağımsızdır",
                "Test yazımı kolaylaşır"
              ],
              "questions": [
                {
                  "questionId": 440101,
                  "question": "Clean Architecture nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece UI tasarımı",
                    "Uygulamayı katmanlara ayırarak bağımlılıkların tek yönlü olmasını sağlayan mimari",
                    "Sadece veritabanı yönetimi",
                    "Network kütüphanesi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture, uygulamayı katmanlara ayırarak bağımlılıkların tek yönlü olmasını sağlayan bir mimari yaklaşımdır.",
                  "tags": ["clean_architecture", "temel"]
                },
                {
                  "questionId": 440102,
                  "question": "Clean Architecture'da bağımlılıkların yönü nasıldır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her yöne olabilir",
                    "Dış katmanlar iç katmanlara bağımlıdır (içe doğru)",
                    "İç katmanlar dış katmanlara bağımlıdır",
                    "Bağımlılık yoktur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture'da bağımlılık kuralı: Dış katmanlar (UI, Framework) iç katmanlara (Domain) bağımlıdır, tersi asla olmaz. Bu, iş mantığının UI'dan bağımsız olmasını sağlar.",
                  "tags": ["clean_architecture", "dependency_rule"]
                },
                {
                  "questionId": 440103,
                  "question": "Clean Architecture'ın avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece hız artışı",
                    "Test edilebilirlik, sürdürülebilirlik, iş mantığının UI'dan bağımsızlığı",
                    "Sadece daha az kod",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture, test edilebilirliği artırır, sürdürülebilir kod sağlar, iş mantığını UI ve framework'lerden bağımsız hale getirir.",
                  "tags": ["clean_architecture", "advantages"]
                }
              ]
            },
            {
              "topicId": 4402,
              "title": "Katmanlar (Presentation, Domain, Data)",
              "summary": "Clean Architecture, uygulamayı üç ana katmana ayırır: Presentation, Domain ve Data.",
              "content": "## Clean Architecture Katmanları\n\n- Presentation: UI ve ViewModel\n- Domain: UseCase ve Entity\n- Data: Repository ve veri kaynakları\n\nHer katmanın sorumluluğu nettir.",
              "difficulty": "hard",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "Presentation UI logic içerir",
                "Domain saf Kotlin'dir",
                "Data veri kaynaklarını yönetir",
                "Katmanlar arası bağımlılık sınırlandırılmıştır"
              ],
              "questions": [
                {
                  "questionId": 440201,
                  "question": "Clean Architecture'da kaç ana katman vardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "2 katman",
                    "3 katman (Presentation, Domain, Data)",
                    "4 katman",
                    "5 katman"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture genellikle üç ana katmana ayrılır: Presentation (UI), Domain (Business Logic), Data (Veri Kaynakları).",
                  "tags": ["clean_architecture", "layers"]
                },
                {
                  "questionId": 440202,
                  "question": "Presentation katmanı neyi içerir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı işlemleri",
                    "UI ve ViewModel (UI logic)",
                    "UseCase'ler",
                    "Network istekleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Presentation katmanı, Activity, Fragment, ViewModel gibi UI bileşenlerini ve UI logic'i içerir.",
                  "tags": ["clean_architecture", "presentation"]
                },
                {
                  "questionId": 440203,
                  "question": "Domain katmanı neyi içerir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Activity ve Fragment",
                    "UseCase ve Entity (Business Logic)",
                    "Retrofit ve Room",
                    "ViewModel"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Domain katmanı, UseCase (Business Logic) ve Entity (Model) içerir. Framework bağımlılığı yoktur, saf Kotlin'dir.",
                  "tags": ["clean_architecture", "domain"]
                },
                {
                  "questionId": 440204,
                  "question": "Data katmanı neyi içerir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "ViewModel",
                    "Repository implementasyonları ve veri kaynakları (API, Room)",
                    "UseCase'ler",
                    "Activity"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Data katmanı, Repository implementasyonlarını ve veri kaynaklarını (Remote: Retrofit, Local: Room, Cache) yönetir.",
                  "tags": ["clean_architecture", "data"]
                }
              ]
            },
            {
              "topicId": 4403,
              "title": "Domain Katmanı",
              "summary": "Domain katmanı, uygulamanın iş kurallarını ve UseCase yapılarını içerir.",
              "content": "## Domain Katmanı\n\nFramework bağımlılığı yoktur.\n\nSaf Kotlin kodu içerir.\n\nUygulamanın kalbidir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "UseCase Örneği",
                  "code": "class GetUsersUseCase(private val repository: UserRepository) {\n    suspend operator fun invoke() = repository.getUsers()\n}",
                  "explanation": "Domain katmanında bir UseCase örneği."
                }
              ],
              "keyPoints": [
                "Framework bağımsızdır",
                "Business logic burada yer alır",
                "Test edilmesi çok kolaydır",
                "Uzun vadede stabil yapı sağlar"
              ],
              "questions": [
                {
                  "questionId": 440301,
                  "question": "Domain katmanının en önemli özelliği nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI bağımlıdır",
                    "Framework bağımlılığı yoktur, saf Kotlin'dir",
                    "Sadece Android API kullanır",
                    "Retrofit gerektirir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Domain katmanı framework bağımlılığı olmayan, saf Kotlin kodudur. Bu sayede kolayca test edilebilir ve platform bağımsızdır.",
                  "tags": ["domain", "framework_independent"]
                },
                {
                  "questionId": 440302,
                  "question": "UseCase nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI bileşeni",
                    "İş mantığını kapsülleyen, tek bir işi yapan sınıf",
                    "Veritabanı tablosu",
                    "Network kütüphanesi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UseCase, uygulamanın iş mantığını (business logic) kapsülleyen, tek bir sorumluluğu olan (Single Responsibility) sınıftır.",
                  "tags": ["domain", "usecase"]
                },
                {
                  "questionId": 440303,
                  "question": "Aşağıdaki UseCase ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "class GetUsersUseCase(private val repository: UserRepository) {\n    suspend operator fun invoke() = repository.getUsers()\n}",
                  "difficulty": "easy",
                  "options": [
                    "UI çizer",
                    "Repository'den kullanıcıları alır (business logic)",
                    "Veritabanı oluşturur",
                    "Network isteği yapar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UseCase, repository'den kullanıcıları almak için iş mantığını kapsüller. operator fun invoke() ile direkt çağrılabilir.",
                  "tags": ["domain", "usecase", "invoke"]
                },
                {
                  "questionId": 440304,
                  "question": "Domain katmanının test edilebilirliği neden yüksektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha hızlıdır",
                    "Framework bağımlılığı yok, repository mock edilebilir, saf Kotlin",
                    "Sadece UI test edilir",
                    "Test edilemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Domain katmanı framework bağımlılığı olmadığı için JUnit ile kolayca test edilebilir. Repository interface mock edilerek unit test yazılır.",
                  "tags": ["domain", "testing"]
                }
              ]
            },
            {
              "topicId": 4404,
              "title": "Data Katmanı",
              "summary": "Data katmanı, veri kaynaklarını (API, Room, Cache) yöneten katmandır.",
              "content": "## Data Katmanı\n\nRepository implementasyonları burada bulunur.\n\nRemote ve local data source'lar ayrılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Repository Implementasyonu",
                  "code": "class UserRepositoryImpl(\n    private val api: ApiService\n) : UserRepository {\n    override suspend fun getUsers() = api.getUsers()\n}",
                  "explanation": "Data katmanında repository implementasyonu."
                }
              ],
              "keyPoints": [
                "Veri kaynaklarını soyutlar",
                "API ve Room ayrımı yapılır",
                "Domain ile interface üzerinden konuşur",
                "Mocklama kolaydır"
              ],
              "questions": [
                {
                  "questionId": 440401,
                  "question": "Data katmanının görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI çizmek",
                    "Veri kaynaklarını (API, Room, Cache) yönetmek",
                    "UseCase oluşturmak",
                    "ViewModel yönetmek"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Data katmanı, veri kaynaklarını (Remote: API, Local: Room, Cache) yönetir ve Repository implementasyonlarını içerir.",
                  "tags": ["data", "layer"]
                },
                {
                  "questionId": 440402,
                  "question": "Repository implementasyonu hangi katmanda bulunur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Domain katmanında",
                    "Data katmanında",
                    "Presentation katmanında",
                    "Her katmanda"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Repository interface Domain katmanında tanımlanır, implementasyonu ise Data katmanında bulunur.",
                  "tags": ["data", "repository"]
                },
                {
                  "questionId": 440403,
                  "question": "Data katmanında Remote ve Local data source'ları ayırmanın amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha fazla kod",
                    "Separation of concerns, test edilebilirlik ve esneklik",
                    "Sadece görsel amaçlı",
                    "Hiçbir amacı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Remote (API) ve Local (Room) data source'ları ayırmak, separation of concerns sağlar, test edilebilirliği artırır ve offline-first stratejisi uygulama esnekliği kazandırır.",
                  "tags": ["data", "separation"]
                },
                {
                  "questionId": 440404,
                  "question": "Aşağıdaki Repository implementasyonu hangi katmandadır?",
                  "questionType": "multiple_choice",
                  "code": "class UserRepositoryImpl(\n    private val api: ApiService\n) : UserRepository {\n    override suspend fun getUsers() = api.getUsers()\n}",
                  "difficulty": "easy",
                  "options": [
                    "Domain",
                    "Data",
                    "Presentation",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Repository implementasyonu Data katmanında bulunur. Domain'deki interface'i implement eder ve concrete veri kaynaklarını (API) kullanır.",
                  "tags": ["data", "repository", "implementation"]
                }
              ]
            },
            {
              "topicId": 4405,
              "title": "Presentation Katmanı",
              "summary": "Presentation katmanı, UI ve kullanıcı etkileşimlerini yöneten katmandır.",
              "content": "## Presentation Katmanı\n\nActivity, Fragment ve ViewModel içerir.\n\nSadece UI logic bulunur.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [
                {
                  "title": "ViewModel + UseCase",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val getUsersUseCase: GetUsersUseCase\n) : ViewModel()",
                  "explanation": "Presentation katmanında ViewModel örneği."
                }
              ],
              "keyPoints": [
                "UI ile sınırlıdır",
                "Business logic içermez",
                "UseCase kullanır",
                "MVVM ile birlikte çalışır"
              ],
              "questions": [
                {
                  "questionId": 440501,
                  "question": "Presentation katmanının sorumluluğu nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Business logic",
                    "UI ve kullanıcı etkileşimleri (UI logic)",
                    "Veritabanı işlemleri",
                    "Network istekleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Presentation katmanı, UI (Activity, Fragment) ve kullanıcı etkileşimlerini yönetir. Sadece UI logic içerir, business logic içermez.",
                  "tags": ["presentation", "responsibility"]
                },
                {
                  "questionId": 440502,
                  "question": "Presentation katmanında ViewModel hangi katmanla iletişim kurar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Doğrudan Data katmanı ile",
                    "Domain katmanı (UseCase) ile",
                    "Repository ile doğrudan",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewModel, Domain katmanındaki UseCase'leri çağırır. Repository veya Data katmanıyla direkt iletişim kurmaz (Clean Architecture prensibi).",
                  "tags": ["presentation", "viewmodel", "usecase"]
                },
                {
                  "questionId": 440503,
                  "question": "Presentation katmanında business logic olmamasının nedeni nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha hızlı olur",
                    "Separation of concerns, test edilebilirlik ve yeniden kullanılabilirlik",
                    "Sadece daha az kod",
                    "Hiçbir nedeni yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Business logic Domain katmanında tutularak UI'dan bağımsız hale gelir. Bu, separation of concerns, test edilebilirlik ve farklı platformlarda (iOS, web) yeniden kullanılabilirlik sağlar.",
                  "tags": ["presentation", "separation"]
                }
              ]
            },
            {
              "topicId": 4406,
              "title": "Clean Architecture + MVVM",
              "summary": "Clean Architecture, MVVM ile birlikte kullanıldığında güçlü ve sürdürülebilir bir yapı ortaya çıkar.",
              "content": "## Clean Architecture + MVVM\n\nMVVM, Presentation katmanında kullanılır.\n\nUseCase'ler ViewModel tarafından çağrılır.",
              "difficulty": "hard",
              "order": 6,
              "codeExamples": [],
              "keyPoints": [
                "Modern Android için ideal yapı",
                "Test edilebilirlik maksimumdur",
                "Büyük projelerde tercih edilir",
                "Senior seviye mimaridir"
              ],
              "questions": [
                {
                  "questionId": 440601,
                  "question": "Clean Architecture ile MVVM nasıl bir ilişki içindedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Birbirinden bağımsızdır",
                    "MVVM, Clean Architecture'ın Presentation katmanında kullanılır",
                    "MVVM daha üstündür",
                    "Clean Architecture MVVM'i kapsar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MVVM (Model-View-ViewModel), Clean Architecture'ın Presentation katmanında kullanılan bir pattern'dir. Clean Architecture tüm uygulamayı kapsarken, MVVM sadece UI katmanını organize eder.",
                  "tags": ["clean_architecture", "mvvm", "relationship"]
                },
                {
                  "questionId": 440602,
                  "question": "Clean Architecture + MVVM kombinasyonunun avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece hız artışı",
                    "Test edilebilirlik maksimum, separation of concerns, ölçeklenebilirlik",
                    "Sadece daha az kod",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kombinasyon, maksimum test edilebilirlik, katmanlar arası net separation of concerns, ölçeklenebilirlik ve sürdürülebilir kod sağlar. Büyük ve karmaşık projelerde tercih edilir.",
                  "tags": ["clean_architecture", "mvvm", "advantages"]
                },
                {
                  "questionId": 440603,
                  "question": "Clean Architecture + MVVM hangi seviye projelerde tercih edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece küçük projelerde",
                    "Orta ve büyük ölçekli, uzun vadeli projelerde",
                    "Sadece demo projelerde",
                    "Hiçbir projede kullanılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture + MVVM, orta ve büyük ölçekli, uzun vadeli projelerde tercih edilir. Küçük projelerde overengineering olabilir.",
                  "tags": ["clean_architecture", "mvvm", "project_size"]
                },
                {
                  "questionId": 440604,
                  "question": "Aşağıdaki ViewModel hangi mimari yaklaşımı kullanıyor?",
                  "questionType": "multiple_choice",
                  "code": "@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val getUsersUseCase: GetUsersUseCase\n) : ViewModel()",
                  "difficulty": "hard",
                  "options": [
                    "Sadece MVVM",
                    "Clean Architecture + MVVM + Dependency Injection",
                    "Sadece Repository Pattern",
                    "MVC"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu ViewModel, Clean Architecture (UseCase kullanımı), MVVM (ViewModel pattern) ve Dependency Injection (Hilt ile constructor injection) kombinasyonunu kullanıyor.",
                  "tags": ["clean_architecture", "mvvm", "hilt"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 440001,
              "question": "Clean Architecture'da hangi katman hiçbir Android framework bağımlılığı içermemelidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Presentation",
                "Domain",
                "Data",
                "Hepsi"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Domain katmanı, hiçbir Android framework bağımlılığı içermemelidir. Saf Kotlin/Java kodu olmalıdır ki platform bağımsız ve kolayca test edilebilir olsun.",
              "tags": ["clean_architecture", "domain", "framework"]
            },
            {
              "questionId": 440002,
              "question": "Repository interface neden Domain katmanında tanımlanır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece organizasyon için",
                "Dependency Inversion Principle: Domain, Data'ya bağımlı olmamalı",
                "Daha hızlı olur",
                "Zorunlu değildir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Repository interface Domain'de tanımlanır çünkü Dependency Inversion Principle gereği, Domain katmanı dış katmanlara (Data) bağımlı olmamalıdır. Data, Domain'in interface'ini implement eder.",
              "tags": ["clean_architecture", "dip", "repository"]
            },
            {
              "questionId": 440003,
              "question": "UseCase'in operator fun invoke() kullanmasının avantajı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece görsel",
                "UseCase'i fonksiyon gibi direkt çağırabilme (getUsersUseCase())",
                "Daha yavaş çalışır",
                "Hiçbir avantajı yok"
              ],
              "correctAnswerIndex": 1,
              "explanation": "operator fun invoke() kullanarak UseCase'i fonksiyon gibi direkt çağırabiliriz: getUsersUseCase() yerine getUsersUseCase.invoke(). Daha clean syntax sağlar.",
              "tags": ["usecase", "invoke", "operator"]
            },
            {
              "questionId": 440004,
              "question": "Entity nedir ve hangi katmanda bulunur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "UI bileşeni, Presentation'da",
                "Business model, Domain katmanında",
                "Veritabanı tablosu, Data'da",
                "Network modeli, Data'da"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Entity, uygulamanın business modelini temsil eden saf data class'tır ve Domain katmanında bulunur. UI veya veritabanı bağımlılığı yoktur.",
              "tags": ["entity", "domain", "model"]
            },
            {
              "questionId": 440005,
              "question": "DTO (Data Transfer Object) nedir ve hangi katmanda kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Domain model, Domain'de",
                "API response modeli, Data katmanında (Network'ten gelen ham veri)",
                "UI modeli, Presentation'da",
                "UseCase"
              ],
              "correctAnswerIndex": 1,
              "explanation": "DTO, API'den gelen ham veriyi temsil eder ve Data katmanında kullanılır. Data katmanında DTO'dan Domain Entity'ye mapping yapılır (toEntity()).",
              "tags": ["dto", "data", "mapping"]
            },
            {
              "questionId": 440006,
              "question": "Clean Architecture'da katmanlar arası veri dönüşümü (mapping) neden yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece ekstra iş",
                "Katmanların birbirinden bağımsız olması ve Domain'in temiz kalması",
                "Performans artışı",
                "Zorunlu değildir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Mapping, katmanların birbirinden bağımsız olmasını sağlar. API response'u değişse bile sadece Data katmanı etkilenir, Domain ve Presentation etkilenmez. Bu da maintainability artırır.",
              "tags": ["mapping", "separation", "independence"]
            },
            {
              "questionId": 440007,
              "question": "Clean Architecture'da Result/Resource pattern ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece veri saklar",
                "Success, Error, Loading state'lerini yönetmek",
                "Sadece UI çizer",
                "Network isteği yapar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Result/Resource pattern, UseCase'lerden dönen sonuçları Success, Error, Loading state'leri ile sarmalayarak UI'ın durumu yönetmesini kolaylaştırır.",
              "tags": ["result", "resource", "state_management"]
            },
            {
              "questionId": 440008,
              "question": "UseCase'lerde birden fazla repository kullanılabilir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hayır, sadece 1 repository",
                "Evet, karmaşık business logic için birden fazla repository koordine edilebilir",
                "Repository kullanılamaz",
                "Sadece Data katmanında"
              ],
              "correctAnswerIndex": 1,
              "explanation": "UseCase'ler karmaşık business logic için birden fazla repository'yi koordine edebilir. Örneğin: UserRepository ve PostRepository'yi kullanarak kullanıcının post'larını getirme.",
              "tags": ["usecase", "repository", "coordination"]
            },
            {
              "questionId": 440009,
              "question": "Clean Architecture'da test stratejisi nasıl olmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece UI test",
                "Domain (Unit test), Data (Integration test), Presentation (UI test) - piramit",
                "Sadece Integration test",
                "Test yazılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Test piramidi: Domain katmanı (Unit test - en çok), Data katmanı (Integration test), Presentation (UI test - en az). Bu strateji hızlı ve güvenilir test suite sağlar.",
              "tags": ["testing", "test_pyramid", "strategy"]
            },
            {
              "questionId": 440010,
              "question": "Clean Architecture küçük projeler için overengineering olabilir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hayır, her zaman kullanılmalı",
                "Evet, küçük projelerde gereksiz karmaşıklık yaratabilir",
                "Sadece büyük projelerde overengineering",
                "Asla overengineering olmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Küçük projelerde (prototip, POC, basit uygulamalar) Clean Architecture gereksiz karmaşıklık yaratabilir. Proje büyüklüğüne göre mimari seçilmelidir. Ancak büyüyecek projelerde baştan uygulanması önerilir.",
              "tags": ["clean_architecture", "project_size", "overengineering"]
            }
          ]
        },
        {
          "sectionId": 4500,
          "sectionTitle": "Coroutines",
          "sectionDescription": "Asenkron işlemleri daha okunabilir, güvenli ve performanslı şekilde yönetmek için kullanılan Kotlin Coroutine yapısı",
          "order": 5,
          "topics": [
            {
              "topicId": 4501,
              "title": "Coroutines Nedir",
              "summary": "Coroutines, uzun süren işlemleri (network, database vb.) ana thread'i bloklamadan çalıştırmayı sağlayan Kotlin'in asenkron programlama çözümüdür.",
              "content": "## Coroutines Nedir\n\nCoroutines, callback ve RxJava gibi yapılara modern bir alternatiftir.\n\nKodun senkron gibi okunmasını sağlar ancak asenkron çalışır.\n\nAndroid'de performans ve kullanıcı deneyimi için kritik öneme sahiptir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Asenkron işlemleri basitleştirir",
                "Callback hell sorununu çözer",
                "Okunabilir kod yapısı sağlar",
                "Android tarafından resmi olarak desteklenir"
              ],
              "questions": [
                {
                  "questionId": 450101,
                  "question": "Coroutines'in ana kullanım amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece UI çizmek",
                    "Uzun süren işlemleri ana thread'i bloklamadan çalıştırmak",
                    "Veritabanı oluşturmak",
                    "Sadece animasyon"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutines, uzun süren işlemleri (network, database) ana thread'i bloklamadan çalıştırmayı sağlayan Kotlin'in asenkron programlama çözümüdür.",
                  "tags": ["coroutines", "temel"]
                },
                {
                  "questionId": 450102,
                  "question": "Coroutines hangi problemi çözer?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece performans",
                    "Callback hell ve asenkron kod karmaşıklığı",
                    "Sadece UI sorunu",
                    "Hiçbir problem çözmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutines, callback hell problemini çözer ve asenkron kodu senkron gibi okunabilir hale getirir.",
                  "tags": ["coroutines", "callback_hell"]
                },
                {
                  "questionId": 450103,
                  "question": "Coroutines Android tarafından destekleniyor mu?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Hayır, üçüncü parti",
                    "Evet, resmi olarak desteklenir",
                    "Sadece Kotlin'de",
                    "Kullanımdan kaldırıldı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutines, Android tarafından resmi olarak desteklenir ve Room, Retrofit gibi kütüphanelerle entegredir.",
                  "tags": ["coroutines", "android", "support"]
                }
              ]
            },
            {
              "topicId": 4502,
              "title": "CoroutineScope ve Lifecycle",
              "summary": "CoroutineScope, coroutine'lerin hangi yaşam döngüsüne bağlı çalışacağını belirler.",
              "content": "## CoroutineScope\n\nAndroid'de en sık kullanılan scope'lar:\n\n- viewModelScope\n- lifecycleScope\n- GlobalScope (önerilmez)\n\nLifecycle-aware scope'lar memory leak riskini azaltır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "viewModelScope Kullanımı",
                  "code": "viewModelScope.launch {\n    val users = repository.getUsers()\n}",
                  "explanation": "ViewModel yok edildiğinde coroutine otomatik iptal edilir."
                }
              ],
              "keyPoints": [
                "Lifecycle'a duyarlı çalışır",
                "Memory leak riskini azaltır",
                "GlobalScope önerilmez",
                "UI güvenliğini artırır"
              ],
              "questions": [
                {
                  "questionId": 450201,
                  "question": "Android'de en çok kullanılan lifecycle-aware scope'lar hangileridir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece GlobalScope",
                    "viewModelScope ve lifecycleScope",
                    "Sadece MainScope",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android'de en çok kullanılan lifecycle-aware scope'lar viewModelScope (ViewModel için) ve lifecycleScope (Activity/Fragment için)'dur.",
                  "tags": ["scope", "lifecycle"]
                },
                {
                  "questionId": 450202,
                  "question": "viewModelScope ne zaman iptal edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir zaman",
                    "ViewModel yok edildiğinde (onCleared)",
                    "Activity kapandığında",
                    "Manuel iptal edilmeli"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "viewModelScope, ViewModel yok edildiğinde (onCleared çağrıldığında) otomatik olarak iptal edilir ve içindeki tüm coroutine'ler durdurulur.",
                  "tags": ["viewmodelscope", "lifecycle"]
                },
                {
                  "questionId": 450203,
                  "question": "GlobalScope kullanmanın dezavantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir dezavantajı yok",
                    "Lifecycle'a bağlı değildir, memory leak riski yüksektir",
                    "Daha yavaştır",
                    "Sadece test için kullanılır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "GlobalScope, uygulama yaşam döngüsü boyunca yaşar ve lifecycle'a bağlı değildir. Bu, memory leak riski yaratır ve önerilmez.",
                  "tags": ["globalscope", "memory_leak"]
                },
                {
                  "questionId": 450204,
                  "question": "Aşağıdaki kodda coroutine ne zaman iptal edilir?",
                  "questionType": "multiple_choice",
                  "code": "viewModelScope.launch {\n    val users = repository.getUsers()\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hiçbir zaman",
                    "ViewModel temizlendiğinde",
                    "Activity kapandığında hemen",
                    "Manuel iptal edilmeli"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "viewModelScope kullanıldığı için coroutine, ViewModel temizlendiğinde (onCleared) otomatik olarak iptal edilir.",
                  "tags": ["viewmodelscope", "cancellation"]
                }
              ]
            },
            {
              "topicId": 4503,
              "title": "Dispatchers",
              "summary": "Dispatchers, coroutine'in hangi thread üzerinde çalışacağını belirler.",
              "content": "## Dispatchers\n\n- Dispatchers.Main → UI işlemleri\n- Dispatchers.IO → Network / Database\n- Dispatchers.Default → CPU yoğun işlemler\n\nYanlış dispatcher kullanımı performans sorunlarına yol açar.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Dispatcher Kullanımı",
                  "code": "withContext(Dispatchers.IO) {\n    dao.getAllUsers()\n}",
                  "explanation": "IO işlemleri ana thread dışında çalıştırılır."
                }
              ],
              "keyPoints": [
                "Thread yönetimini kolaylaştırır",
                "UI thread bloklanmaz",
                "Doğru dispatcher performansı artırır",
                "Yanlış kullanım ANR'a sebep olabilir"
              ],
              "questions": [
                {
                  "questionId": 450301,
                  "question": "Dispatchers.Main ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Network işlemleri",
                    "UI işlemleri ve kullanıcı etkileşimleri",
                    "Veritabanı işlemleri",
                    "Dosya okuma"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dispatchers.Main, Android'in main (UI) thread'inde çalışır ve UI güncellemeleri için kullanılır.",
                  "tags": ["dispatchers", "main"]
                },
                {
                  "questionId": 450302,
                  "question": "Dispatchers.IO ne tür işlemler için uygundur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI güncellemeleri",
                    "Network istekleri ve veritabanı işlemleri",
                    "Matematiksel hesaplamalar",
                    "Sadece animasyon"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dispatchers.IO, network istekleri, veritabanı okuma/yazma, dosya işlemleri gibi I/O operasyonları için optimize edilmiştir.",
                  "tags": ["dispatchers", "io"]
                },
                {
                  "questionId": 450303,
                  "question": "Dispatchers.Default ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI işlemleri",
                    "CPU yoğun işlemler (sıralama, parsing, hesaplama)",
                    "Network istekleri",
                    "Veritabanı işlemleri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dispatchers.Default, CPU-intensive işlemler (büyük veri sıralama, JSON parsing, karmaşık hesaplamalar) için optimize edilmiştir.",
                  "tags": ["dispatchers", "default"]
                },
                {
                  "questionId": 450304,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "withContext(Dispatchers.IO) {\n    dao.getAllUsers()\n}",
                  "difficulty": "easy",
                  "options": [
                    "UI thread'de veritabanı okur",
                    "IO thread'de veritabanı okur, sonucu main thread'e döner",
                    "Hata verir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "withContext(Dispatchers.IO) ile veritabanı işlemi IO thread'de yapılır, işlem bitince sonuç otomatik olarak çağıran thread'e (genellikle Main) döner.",
                  "tags": ["withcontext", "dispatchers", "io"]
                }
              ]
            },
            {
              "topicId": 4504,
              "title": "launch ve async",
              "summary": "launch ve async, coroutine başlatmak için kullanılan iki temel builder'dır.",
              "content": "## launch vs async\n\n- launch → Sonuç dönmez\n- async → Deferred<T> döner\n\nasync genellikle paralel işlemler için kullanılır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "async / await",
                  "code": "val result = async { api.getData() }\nresult.await()",
                  "explanation": "async sonucu await ile alınır."
                }
              ],
              "keyPoints": [
                "launch fire-and-forget",
                "async sonuç döner",
                "await ile senkron bekleme yapılır",
                "Yanlış kullanım memory leak doğurabilir"
              ],
              "questions": [
                {
                  "questionId": 450401,
                  "question": "launch ve async arasındaki temel fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "launch sonuç dönmez, async Deferred<T> döner",
                    "async daha yavaştır",
                    "launch kullanımdan kalkmıştır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "launch, Job döner ve sonuç beklenmez (fire-and-forget). async ise Deferred<T> döner ve await() ile sonuç alınabilir.",
                  "tags": ["launch", "async", "difference"]
                },
                {
                  "questionId": 450402,
                  "question": "async ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir zaman",
                    "Sonuç döndürmesi gereken ve/veya paralel işlemler için",
                    "Sadece UI için",
                    "Her zaman launch yerine"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "async, sonuç döndürmesi gereken veya paralel olarak birden fazla işlem yapıp sonuçlarını toplamak için kullanılır.",
                  "tags": ["async", "use_case"]
                },
                {
                  "questionId": 450403,
                  "question": "await() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Coroutine'i iptal eder",
                    "async'in sonucunu bekler ve alır",
                    "Coroutine başlatır",
                    "Thread bloklar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "await(), async'den dönen Deferred'ın sonucunu bekler ve alır. Suspend fonksiyondur ve thread bloklamaz.",
                  "tags": ["async", "await"]
                },
                {
                  "questionId": 450404,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val result = async { api.getData() }\nresult.await()",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "API'den veri alır ve sonucu bekler",
                    "Sadece coroutine başlatır",
                    "Thread bloklar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "async ile API çağrısı başlatılır, await() ile sonuç beklenir. async suspend olmadan başlatılabilir, await() suspend'dir.",
                  "tags": ["async", "await", "example"]
                }
              ]
            },
            {
              "topicId": 4505,
              "title": "Exception Handling",
              "summary": "Coroutine'lerde hata yönetimi structured concurrency prensibine göre yapılır.",
              "content": "## Coroutine Exception Handling\n\ntry-catch ve CoroutineExceptionHandler kullanılır.\n\nSupervisorJob ile child coroutine hataları izole edilebilir.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "try-catch Kullanımı",
                  "code": "viewModelScope.launch {\n    try {\n        api.getData()\n    } catch (e: Exception) {\n        // hata yönetimi\n    }\n}",
                  "explanation": "Coroutine içinde hata yakalama."
                }
              ],
              "keyPoints": [
                "Structured concurrency önemlidir",
                "Hatalar scope'a yayılabilir",
                "SupervisorJob izolasyon sağlar",
                "Doğru hata yönetimi crash'i önler"
              ],
              "questions": [
                {
                  "questionId": 450501,
                  "question": "Coroutine'lerde exception handling nasıl yapılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Exception handle edilemez",
                    "try-catch veya CoroutineExceptionHandler kullanılır",
                    "Otomatik handle edilir",
                    "Sadece log yazılır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Coroutine'lerde exception handling için try-catch bloğu veya CoroutineExceptionHandler kullanılır.",
                  "tags": ["exception", "handling"]
                },
                {
                  "questionId": 450502,
                  "question": "launch ile başlatılan coroutine'de hata olursa ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir şey olmaz",
                    "Hata parent scope'a yayılır ve tüm scope iptal olabilir",
                    "Sadece o coroutine durur",
                    "Uygulama crash olur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "launch ile başlatılan coroutine'de yakalanmayan exception, parent scope'a yayılır ve structured concurrency gereği tüm scope iptal olabilir.",
                  "tags": ["launch", "exception", "propagation"]
                },
                {
                  "questionId": 450503,
                  "question": "SupervisorJob ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece hız artırır",
                    "Child coroutine hatalarını izole eder, parent'a yayılmasını engeller",
                    "Coroutine başlatır",
                    "Sadece test için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "SupervisorJob, child coroutine'lerin hatalarını izole eder. Bir child'da hata olsa bile diğer child'lar ve parent etkilenmez.",
                  "tags": ["supervisorjob", "isolation"]
                },
                {
                  "questionId": 450504,
                  "question": "async ile başlatılan coroutine'de hata ne zaman fırlatılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "async çağrıldığında",
                    "await() çağrıldığında",
                    "Hiçbir zaman",
                    "Otomatik handle edilir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "async ile başlatılan coroutine'de exception, await() çağrıldığında fırlatılır. Bu nedenle await()'i try-catch içine almak gerekir.",
                  "tags": ["async", "exception", "await"]
                },
                {
                  "questionId": 450505,
                  "question": "Aşağıdaki kod doğru exception handling yapıyor mu?",
                  "questionType": "multiple_choice",
                  "code": "viewModelScope.launch {\n    try {\n        api.getData()\n    } catch (e: Exception) {\n        // hata yönetimi\n    }\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, doğru yaklaşım",
                    "try-catch coroutine'de kullanılamaz",
                    "Sadece async'de çalışır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru bir exception handling yaklaşımıdır. Coroutine içinde try-catch kullanılarak exception yakalanabilir.",
                  "tags": ["exception", "try_catch", "best_practice"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 450001,
              "question": "lifecycleScope ne zaman kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece ViewModel'de",
                "Activity ve Fragment'te UI ile ilgili işlemler için",
                "Sadece Service'de",
                "GlobalScope yerine"
              ],
              "correctAnswerIndex": 1,
              "explanation": "lifecycleScope, Activity ve Fragment'te kullanılır. Lifecycle'a bağlıdır ve Activity/Fragment yok olduğunda coroutine'ler otomatik iptal edilir.",
              "tags": ["lifecyclescope", "lifecycle"]
            },
            {
              "questionId": 450002,
              "question": "Coroutine'de job.cancel() ne yapar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Coroutine'i duraklatır",
                "Coroutine'i iptal eder ve CancellationException fırlatır",
                "Coroutine'i yeniden başlatır",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "job.cancel(), coroutine'i iptal eder ve CancellationException fırlatır. finally bloğunda cleanup yapılabilir.",
              "tags": ["cancel", "job"]
            },
            {
              "questionId": 450003,
              "question": "Birden fazla async işlemini paralel çalıştırıp sonuçlarını almak için hangi pattern kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "launch kullanılır",
                "Birden fazla async başlatılır, await() ile toplanır",
                "Sadece sıralı çağrılır",
                "Mümkün değil"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Paralel işlemler için birden fazla async başlatılır ve await() ile sonuçlar toplanır: val result1 = async { }, val result2 = async { }, result1.await() + result2.await()",
              "tags": ["async", "parallel", "pattern"]
            },
            {
              "questionId": 450004,
              "question": "withTimeout() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece hız artırır",
                "Coroutine'e timeout ekler, süre aşımında TimeoutCancellationException fırlatır",
                "Coroutine'i durdurur",
                "Sadece test için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "withTimeout(), coroutine'e zaman sınırı ekler. Belirtilen sürede tamamlanmazsa TimeoutCancellationException fırlatır ve coroutine iptal edilir.",
              "tags": ["timeout", "withtimeout"]
            },
            {
              "questionId": 450005,
              "question": "CoroutineExceptionHandler ne zaman kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Her zaman",
                "launch ile başlatılan coroutine'lerde global exception handling için",
                "Sadece async'de",
                "Kullanılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "CoroutineExceptionHandler, launch ile başlatılan coroutine'lerde global exception handling için kullanılır. async'de çalışmaz, await()'de exception fırlatılır.",
              "tags": ["exception", "handler"]
            },
            {
              "questionId": 450006,
              "question": "runBlocking() ne işe yarar ve neden production kodda önerilmez?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Her zaman kullanılmalı",
                "Coroutine başlatır ve thread'i bloklar; UI thread'de ANR riski yaratır",
                "Sadece test için önerilir",
                "Asenkron çalışır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "runBlocking(), coroutine başlatır ve çağıran thread'i bloklar. Production'da main thread'de kullanılırsa ANR riskine yol açar. Genellikle sadece test ve main fonksiyonlarda kullanılır.",
              "tags": ["runblocking", "blocking"]
            },
            {
              "questionId": 450007,
              "question": "Coroutine'de isActive property'si ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Coroutine'i başlatır",
                "Coroutine'in aktif olup olmadığını kontrol eder (iptal edilmemiş)",
                "Coroutine'i iptal eder",
                "Sadece log için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "isActive, coroutine'in hala aktif olup olmadığını kontrol eder. Uzun döngülerde isActive kontrolü yaparak iptal durumuna responsive olmak gerekir.",
              "tags": ["isactive", "cancellation"]
            },
            {
              "questionId": 450008,
              "question": "ensureActive() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Coroutine'i başlatır",
                "Coroutine iptal edilmişse CancellationException fırlatır",
                "Coroutine'i duraklatır",
                "Sadece log için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ensureActive(), coroutine iptal edilmişse hemen CancellationException fırlatır. Uzun işlemlerde düzenli olarak çağrılarak cancellation'a responsive olunur.",
              "tags": ["ensureactive", "cancellation"]
            },
            {
              "questionId": 450009,
              "question": "Coroutine'de NonCancellable context ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Coroutine'i iptal edilemez yapar",
                "finally bloğunda cleanup işlemleri için suspend fonksiyon çağırabilmeyi sağlar",
                "Sadece hız artırır",
                "Hiçbir işe yaramaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "NonCancellable, iptal edilmiş coroutine'de finally bloğunda suspend fonksiyon çağırabilmeyi sağlar. Cleanup işlemleri için kullanılır: withContext(NonCancellable) { }",
              "tags": ["noncancellable", "cleanup"]
            },
            {
              "questionId": 450010,
              "question": "Coroutine context nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece dispatcher",
                "Dispatcher, Job, CoroutineName gibi elementlerin birleşimi",
                "Sadece scope",
                "Sadece exception handler"
              ],
              "correctAnswerIndex": 1,
              "explanation": "CoroutineContext, Dispatcher, Job, CoroutineName, CoroutineExceptionHandler gibi elementlerin birleşimidir. + operatörü ile combine edilebilir.",
              "tags": ["context", "coroutinecontext"]
            }
          ]
        },
        {
          "sectionId": 4600,
          "sectionTitle": "Testing",
          "sectionDescription": "Android uygulamalarda hataları erken yakalamak, sürdürülebilir ve güvenilir kod yazmak için kullanılan test yaklaşımları",
          "order": 6,
          "topics": [
            {
              "topicId": 4601,
              "title": "Testing Nedir ve Neden Önemlidir",
              "summary": "Testing, yazılan kodun beklenen şekilde çalışıp çalışmadığını doğrulamak için yapılan kontrollü test süreçleridir. Hataları erken yakalamayı ve kod kalitesini artırmayı sağlar.",
              "content": "## Testing Nedir\n\nTest yazmak, uygulamanın davranışlarını otomatik olarak kontrol etmeyi sağlar.\n\nBüyük projelerde regresyon hatalarını önler.\n\nProfesyonel yazılım geliştirme süreçlerinin vazgeçilmezidir.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Hataları erken yakalar",
                "Kod kalitesini artırır",
                "Refactor sürecini güvenli hale getirir",
                "Profesyonel projelerde zorunludur"
              ],
              "questions": [
                {
                  "questionId": 460101,
                  "question": "Testing (Test yazma) nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece debug yapmak",
                    "Yazılan kodun beklenen şekilde çalışıp çalışmadığını doğrulamak",
                    "Sadece UI çizmek",
                    "Sadece performans ölçmek"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Testing, yazılan kodun beklenen şekilde çalışıp çalışmadığını doğrulamak için yapılan kontrollü test süreçleridir.",
                  "tags": ["testing", "temel"]
                },
                {
                  "questionId": 460102,
                  "question": "Test yazmanın avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha fazla kod",
                    "Hataları erken yakalar, kod kalitesini artırır, refactor'u güvenli hale getirir",
                    "Sadece daha yavaş geliştirme",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Test yazmak, hataları erken yakalar, kod kalitesini artırır ve refactor sürecini güvenli hale getirir. Büyük projelerde regresyon hatalarını önler.",
                  "tags": ["testing", "advantages"]
                },
                {
                  "questionId": 460103,
                  "question": "Profesyonel yazılım geliştirmede test yazımı nasıl görülür?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Opsiyonel",
                    "Vazgeçilmezdir ve zorunludur",
                    "Sadece büyük şirketler için",
                    "Gereksizdir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Profesyonel yazılım geliştirme süreçlerinde test yazımı vazgeçilmezdir ve zorunludur. Kod kalitesi ve güvenilirlik için kritik öneme sahiptir.",
                  "tags": ["testing", "professional"]
                }
              ]
            },
            {
              "topicId": 4602,
              "title": "Unit Test",
              "summary": "Unit Test, uygulamadaki en küçük test edilebilir birimlerin (fonksiyon, ViewModel vb.) izole şekilde test edilmesini sağlar.",
              "content": "## Unit Test\n\nAndroid'de genellikle ViewModel ve business logic test edilir.\n\nJUnit ve Mockito sık kullanılan araçlardır.\n\nUI'dan bağımsız çalışır.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "ViewModel Unit Test",
                  "code": "@Test\nfun counter_increases_correctly() {\n    val vm = MainViewModel()\n    vm.increase()\n    assertEquals(1, vm.counter.value)\n}",
                  "explanation": "ViewModel fonksiyonunun doğru çalıştığını test eder."
                }
              ],
              "keyPoints": [
                "UI bağımsız test edilir",
                "Hızlı çalışır",
                "ViewModel için idealdir",
                "Regression hatalarını önler"
              ],
              "questions": [
                {
                  "questionId": 460201,
                  "question": "Unit Test nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Tüm uygulamayı test etme",
                    "En küçük test edilebilir birimleri (fonksiyon, ViewModel) izole şekilde test etme",
                    "Sadece UI test",
                    "Sadece database test"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Unit Test, uygulamadaki en küçük test edilebilir birimlerin (fonksiyon, ViewModel, UseCase) izole şekilde test edilmesini sağlar.",
                  "tags": ["unit_test", "temel"]
                },
                {
                  "questionId": 460202,
                  "question": "Android'de Unit Test genellikle hangi bileşenler için yazılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Activity",
                    "ViewModel, UseCase ve business logic",
                    "Sadece XML layout",
                    "Sadece Manifest"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android'de Unit Test genellikle ViewModel, UseCase ve business logic için yazılır. Bu bileşenler UI'dan bağımsızdır ve kolayca test edilebilir.",
                  "tags": ["unit_test", "viewmodel"]
                },
                {
                  "questionId": 460203,
                  "question": "Unit Test'in avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha fazla kod",
                    "Hızlı çalışır, UI bağımsız, regression hatalarını önler",
                    "Sadece yavaş çalışır",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Unit Test, UI bağımsız çalıştığı için çok hızlıdır (saniyeler içinde), regression hatalarını önler ve sürekli çalıştırılabilir.",
                  "tags": ["unit_test", "advantages"]
                },
                {
                  "questionId": 460204,
                  "question": "Aşağıdaki test ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "@Test\nfun counter_increases_correctly() {\n    val vm = MainViewModel()\n    vm.increase()\n    assertEquals(1, vm.counter.value)\n}",
                  "difficulty": "easy",
                  "options": [
                    "UI test yapar",
                    "ViewModel'in increase fonksiyonunun counter'ı 1 artırdığını test eder",
                    "Network testi yapar",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu Unit Test, MainViewModel'in increase() fonksiyonunu çağırır ve counter değerinin 1 olduğunu doğrular (assertEquals).",
                  "tags": ["unit_test", "viewmodel", "example"]
                }
              ]
            },
            {
              "topicId": 4603,
              "title": "Mocking (Mockito)",
              "summary": "Mocking, gerçek bağımlılıkların yerine sahte (mock) nesneler kullanarak test yazmayı sağlar.",
              "content": "## Mocking\n\nRepository, API veya database bağımlılıkları mock'lanır.\n\nTest izolasyonu sağlar.\n\nMockito Android'de sık kullanılır.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Mockito Kullanımı",
                  "code": "val repo = mock(UserRepository::class.java)\n`when`(repo.getUsers()).thenReturn(listOf())",
                  "explanation": "Repository davranışı taklit edilir."
                }
              ],
              "keyPoints": [
                "Bağımlılıkları izole eder",
                "Test senaryolarını kontrol etmeyi sağlar",
                "Gerçek API çağrısı yapılmaz",
                "Test stabilitesini artırır"
              ],
              "questions": [
                {
                  "questionId": 460301,
                  "question": "Mocking nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Gerçek API kullanma",
                    "Gerçek bağımlılıkların yerine sahte (mock) nesneler kullanma",
                    "Sadece UI çizme",
                    "Veritabanı oluşturma"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Mocking, gerçek bağımlılıkların (Repository, API, Database) yerine sahte (mock) nesneler kullanarak izole test yazmayı sağlar.",
                  "tags": ["mocking", "temel"]
                },
                {
                  "questionId": 460302,
                  "question": "Mocking neden kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha fazla kod",
                    "Test izolasyonu, gerçek API çağrısı yapmadan test, stabilite",
                    "Sadece hız artışı",
                    "Hiçbir nedeni yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Mocking, bağımlılıkları izole eder, gerçek API/Database çağrısı yapmadan test yazılmasını sağlar ve test stabilitesini artırır.",
                  "tags": ["mocking", "reasons"]
                },
                {
                  "questionId": 460303,
                  "question": "Android'de en yaygın mocking kütüphanesi hangisidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Glide",
                    "Mockito",
                    "Retrofit",
                    "Room"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Mockito, Android'de en yaygın kullanılan mocking kütüphanesidir. MockK (Kotlin için) de popülerdir.",
                  "tags": ["mocking", "mockito"]
                },
                {
                  "questionId": 460304,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val repo = mock(UserRepository::class.java)\n`when`(repo.getUsers()).thenReturn(listOf())",
                  "difficulty": "medium",
                  "options": [
                    "Gerçek repository oluşturur",
                    "Mock repository oluşturur ve getUsers() çağrıldığında boş liste döner",
                    "Veritabanı oluşturur",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "mock() ile sahte repository oluşturulur. when().thenReturn() ile getUsers() çağrıldığında boş liste döndürülmesi sağlanır (mocking behavior).",
                  "tags": ["mocking", "mockito", "example"]
                }
              ]
            },
            {
              "topicId": 4604,
              "title": "UI Test (Espresso)",
              "summary": "UI Test, uygulamanın kullanıcı arayüzünün doğru çalışıp çalışmadığını otomatik olarak test etmeyi sağlar.",
              "content": "## UI Test\n\nEspresso Android'in resmi UI test aracıdır.\n\nKullanıcı etkileşimlerini simüle eder.\n\nGerçek cihaz veya emülatör üzerinde çalışır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Espresso Örneği",
                  "code": "onView(withId(R.id.button)).perform(click())",
                  "explanation": "Butona tıklama işlemi test edilir."
                }
              ],
              "keyPoints": [
                "Gerçek kullanıcı davranışını test eder",
                "UI hatalarını yakalar",
                "Yavaş çalışır ama etkilidir",
                "Release öncesi kritik öneme sahiptir"
              ],
              "questions": [
                {
                  "questionId": 460401,
                  "question": "UI Test (Espresso) ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece ViewModel test eder",
                    "Uygulamanın kullanıcı arayüzünü otomatik olarak test eder",
                    "Sadece network test eder",
                    "Sadece veritabanı test eder"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UI Test (Espresso), uygulamanın kullanıcı arayüzünün doğru çalışıp çalışmadığını otomatik olarak test etmeyi sağlar.",
                  "tags": ["ui_test", "espresso"]
                },
                {
                  "questionId": 460402,
                  "question": "Espresso testleri nerede çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece bilgisayarda",
                    "Gerçek cihaz veya emülatör üzerinde",
                    "Sadece cloud'da",
                    "Hiçbir yerde"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Espresso testleri, gerçek cihaz veya emülatör üzerinde çalışır. Gerçek kullanıcı etkileşimlerini simüle eder.",
                  "tags": ["espresso", "device"]
                },
                {
                  "questionId": 460403,
                  "question": "Aşağıdaki Espresso kodu ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "onView(withId(R.id.button)).perform(click())",
                  "difficulty": "easy",
                  "options": [
                    "Button oluşturur",
                    "ID'si button olan view'a tıklama işlemi yapar (simüle eder)",
                    "Button siler",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "onView(withId(R.id.button)) ile button bulunur, perform(click()) ile tıklama işlemi simüle edilir. Gerçek kullanıcı etkileşimi test edilir.",
                  "tags": ["espresso", "click", "example"]
                }
              ]
            },
            {
              "topicId": 4605,
              "title": "Test Pyramid",
              "summary": "Test Pyramid, test stratejisinde hangi test türüne ne kadar ağırlık verilmesi gerektiğini tanımlar.",
              "content": "## Test Pyramid\n\n- Unit Test → Çok\n- Integration Test → Orta\n- UI Test → Az\n\nBu yapı test maliyetini optimize eder.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Unit test ağırlıklı olmalı",
                "UI test sayısı sınırlı tutulmalı",
                "Bakım maliyetini düşürür",
                "Doğru test stratejisi sağlar"
              ],
              "questions": [
                {
                  "questionId": 460501,
                  "question": "Test Pyramid nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI framework",
                    "Test stratejisinde hangi test türüne ne kadar ağırlık verilmesi gerektiğini tanımlayan yapı",
                    "Veritabanı şeması",
                    "Network protokolü"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Test Pyramid, test stratejisinde hangi test türüne (Unit, Integration, UI) ne kadar ağırlık verilmesi gerektiğini tanımlar.",
                  "tags": ["test_pyramid", "strategy"]
                },
                {
                  "questionId": 460502,
                  "question": "Test Pyramid'e göre hangi test türü en fazla olmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI Test",
                    "Unit Test",
                    "Integration Test",
                    "Hepsi eşit"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Test Pyramid'e göre: Unit Test (en çok) → Integration Test (orta) → UI Test (en az). Unit test hızlı ve ucuzdur, UI test yavaş ve pahalıdır.",
                  "tags": ["test_pyramid", "unit_test"]
                },
                {
                  "questionId": 460503,
                  "question": "Test Pyramid'in amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece görsel",
                    "Test maliyetini optimize etmek ve doğru test stratejisi sağlamak",
                    "Sadece UI test yazmak",
                    "Test yazmamak"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Test Pyramid, test maliyetini (zaman, bakım) optimize eder ve doğru test stratejisi sağlar. Unit test ağırlıklı, UI test sınırlı tutulur.",
                  "tags": ["test_pyramid", "optimization"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 460001,
              "question": "JUnit nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "UI test framework",
                "Java/Kotlin için Unit Test framework'ü",
                "Network kütüphanesi",
                "Veritabanı aracı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "JUnit, Java ve Kotlin için en yaygın kullanılan Unit Test framework'üdür. @Test annotation'ı ile test fonksiyonları tanımlanır.",
              "tags": ["junit", "framework"]
            },
            {
              "questionId": 460002,
              "question": "assertEquals() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "İki değeri karşılaştırır ve eşit olup olmadığını kontrol eder",
                "Değer atar",
                "UI çizer",
                "Network isteği yapar"
              ],
              "correctAnswerIndex": 0,
              "explanation": "assertEquals(expected, actual), beklenen (expected) ve gerçek (actual) değerleri karşılaştırır. Eşit değilse test fail olur.",
              "tags": ["assertion", "junit"]
            },
            {
              "questionId": 460003,
              "question": "TDD (Test-Driven Development) nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "UI tasarımı",
                "Önce test yazıp sonra kodu yazma yaklaşımı",
                "Sadece test yazmama",
                "Manuel test"
              ],
              "correctAnswerIndex": 1,
              "explanation": "TDD, önce test yazıp (fail), sonra kodu yazarak (pass), son olarak refactor yapma yaklaşımıdır. Red-Green-Refactor cycle.",
              "tags": ["tdd", "methodology"]
            },
            {
              "questionId": 460004,
              "question": "Integration Test nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece tek fonksiyon test",
                "Birden fazla bileşenin birlikte çalışmasını test etme",
                "Sadece UI test",
                "Manuel test"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Integration Test, birden fazla bileşenin (örn: ViewModel + Repository + Database) birlikte doğru çalışıp çalışmadığını test eder.",
              "tags": ["integration_test", "testing"]
            },
            {
              "questionId": 460005,
              "question": "ViewModel test ederken LiveData/StateFlow değerini nasıl kontrol ederiz?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Doğrudan kontrol edilemez",
                "InstantTaskExecutorRule ve observeForever veya Flow.first() kullanılır",
                "Sadece log yazılır",
                "UI test gerekir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "LiveData test için InstantTaskExecutorRule ve observeForever kullanılır. StateFlow için Flow.first() veya test observer kullanılır.",
              "tags": ["viewmodel", "livedata", "testing"]
            },
            {
              "questionId": 460006,
              "question": "Espresso'da onView() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "View oluşturur",
                "Test edilecek view'ı bulur (matcher ile)",
                "View siler",
                "Layout inflate eder"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onView() Espresso'da test edilecek view'ı bulmak için kullanılır. withId(), withText() gibi matcher'larla eşleşme yapılır.",
              "tags": ["espresso", "onview"]
            },
            {
              "questionId": 460007,
              "question": "@Before annotation'ı ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Test sonrası çalışır",
                "Her test öncesi çalışır (setup için)",
                "Sadece ilk test öncesi",
                "Hiçbir zaman çalışmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@Before, her test fonksiyonu öncesinde çalışır. Test setup (örn: ViewModel oluşturma, mock ayarlama) için kullanılır.",
              "tags": ["junit", "before", "annotation"]
            },
            {
              "questionId": 460008,
              "question": "@After annotation'ı ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Test öncesi çalışır",
                "Her test sonrası çalışır (cleanup için)",
                "Sadece son test sonrası",
                "Hiçbir zaman çalışmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@After, her test fonksiyonu sonrasında çalışır. Cleanup (örn: database kapatma, resource temizleme) için kullanılır.",
              "tags": ["junit", "after", "annotation"]
            },
            {
              "questionId": 460009,
              "question": "Code Coverage nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "UI tasarımı",
                "Kodun ne kadarının test tarafından kapsandığını gösteren metrik",
                "Sadece test sayısı",
                "Network hızı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Code Coverage, kodun ne kadarının test tarafından kapsandığını gösteren metrik'tir (%). %100 coverage her zaman iyi kod kalitesi anlamına gelmez.",
              "tags": ["coverage", "metrics"]
            },
            {
              "questionId": 460010,
              "question": "Hangi durumlarda UI test (Espresso) yazmak şarttır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Her zaman",
                "Kritik user flow'lar (login, checkout vb.) ve release öncesi",
                "Hiçbir zaman",
                "Sadece demo için"
              ],
              "correctAnswerIndex": 1,
              "explanation": "UI test, kritik user flow'lar (login, ödeme, kayıt) ve release öncesi yazılmalıdır. Her feature için UI test yazmak maliyetlidir, kritik noktalara odaklanılmalıdır.",
              "tags": ["ui_test", "strategy"]
            }
          ]
        },
        {
          "sectionId": 4700,
          "sectionTitle": "Performance & Memory Management",
          "sectionDescription": "Android uygulamalarda performans sorunlarını tespit etmek, bellek yönetimini doğru yapmak ve ANR/crash risklerini azaltmak",
          "order": 7,
          "topics": [
            {
              "topicId": 4701,
              "title": "Performance Nedir",
              "summary": "Performance, bir Android uygulamasının hızlı, akıcı ve kaynakları verimli kullanarak çalışmasıdır. Kötü performans kullanıcı kaybına yol açar.",
              "content": "## Performance\n\nAndroid'de performans; CPU, memory, disk ve network kullanımına bağlıdır.\n\nAkıcı UI için ana thread'in bloklanmaması gerekir.\n\nGoogle Play puanlamasını doğrudan etkiler.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Akıcı UI kullanıcı deneyimini artırır",
                "Ana thread bloklanmamalıdır",
                "Performans doğrudan Play Store puanını etkiler",
                "Profiling ile ölçülmelidir"
              ],
              "questions": [
                {
                  "questionId": 470101,
                  "question": "Android'de performance (performans) ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece hız",
                    "Uygulamanın hızlı, akıcı ve kaynakları verimli kullanarak çalışması",
                    "Sadece görsel kalite",
                    "Sadece kod miktarı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Performance, bir Android uygulamasının hızlı, akıcı ve kaynakları (CPU, memory, disk, network) verimli kullanarak çalışmasıdır.",
                  "tags": ["performance", "temel"]
                },
                {
                  "questionId": 470102,
                  "question": "Kötü performansın sonuçları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir şey olmaz",
                    "Kullanıcı kaybı, kötü Play Store puanı, ANR ve crash",
                    "Sadece daha fazla bellek kullanımı",
                    "Sadece pil tüketimi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Kötü performans, kullanıcı kaybına, kötü Play Store puanlarına, ANR hatalarına ve crash'lere yol açar.",
                  "tags": ["performance", "consequences"]
                },
                {
                  "questionId": 470103,
                  "question": "Akıcı UI için en kritik kural nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece hızlı kod yazmak",
                    "Ana (main) thread'in bloklanmaması",
                    "Sadece optimize edilmiş layout",
                    "Sadece küçük resimler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Akıcı UI için ana thread bloklanmamalıdır. Uzun süren işlemler (network, database) background thread'de yapılmalıdır.",
                  "tags": ["performance", "main_thread"]
                }
              ]
            },
            {
              "topicId": 4702,
              "title": "ANR (Application Not Responding)",
              "summary": "ANR, ana thread uzun süre bloklandığında Android tarafından uygulamanın durdurulmasıdır.",
              "content": "## ANR\n\nGenellikle network, database veya heavy işlem ana thread'de yapıldığında oluşur.\n\n5 saniyeden uzun UI bloklanması ANR sebebidir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Yanlış Kullanım",
                  "code": "Thread.sleep(6000)",
                  "explanation": "Ana thread'de bekleme ANR oluşturur."
                }
              ],
              "keyPoints": [
                "Ana thread bloklanmamalı",
                "Uzun işlemler background thread'e taşınmalı",
                "Coroutines / WorkManager kullanılmalı",
                "ANR Play Console'da raporlanır"
              ],
              "questions": [
                {
                  "questionId": 470201,
                  "question": "ANR (Application Not Responding) ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece crash",
                    "Ana thread uzun süre bloklandığında uygulamanın Android tarafından durdurulması",
                    "Sadece slow performance",
                    "Network hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ANR, ana thread uzun süre (genellikle 5 saniye+) bloklandığında Android tarafından uygulamanın durdurulmasıdır. Kullanıcıya 'Uygulama Yanıt Vermiyor' dialogu gösterilir.",
                  "tags": ["anr", "temel"]
                },
                {
                  "questionId": 470202,
                  "question": "ANR genellikle ne zaman oluşur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece crash durumunda",
                    "Network, database veya heavy işlem ana thread'de yapıldığında",
                    "Sadece bellek dolduğunda",
                    "Hiçbir zaman oluşmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ANR, genellikle network istekleri, veritabanı işlemleri veya ağır hesaplamalar ana thread'de yapıldığında oluşur.",
                  "tags": ["anr", "causes"]
                },
                {
                  "questionId": 470203,
                  "question": "ANR'ı önlemek için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir şey yapılmaz",
                    "Uzun işlemler Coroutines, WorkManager ile background thread'e taşınmalı",
                    "Sadece UI optimize edilmeli",
                    "Sadece pil tasarrufu"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ANR'ı önlemek için uzun süren işlemler Coroutines, WorkManager, AsyncTask (deprecated) gibi yapılarla background thread'de çalıştırılmalıdır.",
                  "tags": ["anr", "prevention"]
                },
                {
                  "questionId": 470204,
                  "question": "Aşağıdaki kod neden ANR oluşturur?",
                  "questionType": "multiple_choice",
                  "code": "Thread.sleep(6000)",
                  "difficulty": "easy",
                  "options": [
                    "Hata vermez",
                    "Ana thread'i 6 saniye bloklar, 5 saniye limitini aşar",
                    "Sadece yavaşlatır",
                    "Sadece bellek kullanır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Thread.sleep(6000) ana thread'i 6 saniye bloklar. 5 saniye limitini aştığı için ANR dialogu gösterilir.",
                  "tags": ["anr", "example", "thread_sleep"]
                }
              ]
            },
            {
              "topicId": 4703,
              "title": "Memory Leak",
              "summary": "Memory leak, artık kullanılmayan nesnelerin bellekten temizlenmemesi durumudur ve uygulamanın yavaşlamasına veya çökmesine neden olur.",
              "content": "## Memory Leak\n\nEn sık nedenler:\n\n- Static Activity referansı\n- Yanlış Context kullanımı\n- Lifecycle'a bağlı olmayan observer'lar",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Yanlış Context Kullanımı",
                  "code": "object Manager {\n    lateinit var context: Context\n}",
                  "explanation": "Activity context'i tutulursa leak oluşur."
                }
              ],
              "keyPoints": [
                "Context dikkatli kullanılmalı",
                "Lifecycle-aware bileşenler tercih edilmeli",
                "LeakCanary ile tespit edilebilir",
                "Static referanslardan kaçınılmalı"
              ],
              "questions": [
                {
                  "questionId": 470301,
                  "question": "Memory Leak nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece crash",
                    "Artık kullanılmayan nesnelerin bellekten temizlenmemesi",
                    "Sadece ANR",
                    "Network hatası"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Memory Leak, artık kullanılmayan nesnelerin bellekten temizlenmemesi durumudur ve uygulamanın yavaşlamasına veya çökmesine (OutOfMemoryError) neden olur.",
                  "tags": ["memory_leak", "temel"]
                },
                {
                  "questionId": 470302,
                  "question": "Memory Leak'in en sık nedenleri nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece UI hatası",
                    "Static Activity referansı, yanlış Context kullanımı, lifecycle'a bağlı olmayan observer'lar",
                    "Sadece network hatası",
                    "Hiçbir nedeni yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Memory Leak'in en sık nedenleri: Static Activity/Context referansı, yanlış Context kullanımı (Activity yerine Application), lifecycle'a bağlı olmayan observer/listener'lar.",
                  "tags": ["memory_leak", "causes"]
                },
                {
                  "questionId": 470303,
                  "question": "Activity Context yerine hangi Context kullanılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her zaman Activity Context",
                    "Singleton veya long-lived nesnelerde Application Context",
                    "Fark etmez",
                    "Context kullanılmamalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Singleton veya uzun ömürlü nesnelerde Activity Context tutulursa memory leak oluşur. Application Context kullanılmalıdır çünkü uygulama boyunca yaşar.",
                  "tags": ["memory_leak", "context"]
                },
                {
                  "questionId": 470304,
                  "question": "Aşağıdaki kod neden memory leak oluşturur?",
                  "questionType": "multiple_choice",
                  "code": "object Manager {\n    lateinit var context: Context\n}",
                  "difficulty": "hard",
                  "options": [
                    "Hata vermez",
                    "Singleton object Activity context'ini tutarsa, Activity yok olsa bile referans kalır (leak)",
                    "Sadece yavaşlatır",
                    "Hiçbir problem yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "object (Singleton) Activity context'ini tutarsa, Activity destroy olsa bile referans devam eder ve Garbage Collector Activity'yi temizleyemez (memory leak). Application Context kullanılmalı.",
                  "tags": ["memory_leak", "singleton", "context"]
                },
                {
                  "questionId": 470305,
                  "question": "Memory Leak tespit etmek için hangi araç kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece log",
                    "LeakCanary kütüphanesi",
                    "Sadece crash report",
                    "Tespit edilemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LeakCanary, Android uygulamalarda memory leak'leri otomatik tespit eden ve raporlayan popüler bir kütüphanedir. Android Profiler'da da memory analiz edilebilir.",
                  "tags": ["memory_leak", "leakcanary", "tools"]
                }
              ]
            },
            {
              "topicId": 4704,
              "title": "Garbage Collection",
              "summary": "Garbage Collector, kullanılmayan nesneleri bellekten otomatik olarak temizleyen mekanizmadır.",
              "content": "## Garbage Collection\n\nSık GC çalışması performans düşüşüne neden olur.\n\nAşırı nesne oluşturmak GC baskısı yaratır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Aşırı nesne üretiminden kaçınılmalı",
                "Reusable objeler tercih edilmeli",
                "GC UI thread'i etkileyebilir",
                "Profiling ile izlenmelidir"
              ],
              "questions": [
                {
                  "questionId": 470401,
                  "question": "Garbage Collection (GC) nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Manuel bellek temizleme",
                    "Kullanılmayan nesneleri bellekten otomatik olarak temizleyen mekanizma",
                    "Sadece crash önleme",
                    "Network yönetimi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Garbage Collector, kullanılmayan nesneleri bellekten otomatik olarak temizleyen mekanizmadır. Developer'ın manuel müdahalesine gerek yoktur.",
                  "tags": ["gc", "temel"]
                },
                {
                  "questionId": 470402,
                  "question": "Sık GC çalışmasının performans üzerindeki etkisi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir etkisi yok",
                    "Performans düşüşüne neden olur, UI thread'i etkileyebilir",
                    "Performansı artırır",
                    "Sadece bellek azalır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Sık GC çalışması performans düşüşüne neden olur ve UI thread'i etkileyebilir (frame drop). Aşırı nesne oluşturmaktan kaçınılmalıdır.",
                  "tags": ["gc", "performance"]
                },
                {
                  "questionId": 470403,
                  "question": "GC baskısını azaltmak için ne yapılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir şey yapılmaz",
                    "Aşırı nesne üretiminden kaçınılmalı, reusable objeler (object pool) tercih edilmeli",
                    "Daha fazla nesne oluşturulmalı",
                    "GC manuel çağrılmalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "GC baskısını azaltmak için aşırı nesne üretiminden kaçınılmalı, özellikle loop içinde nesne yaratmaktan sakınılmalı ve mümkünse reusable objeler (object pool pattern) kullanılmalıdır.",
                  "tags": ["gc", "optimization"]
                }
              ]
            },
            {
              "topicId": 4705,
              "title": "Android Profiler",
              "summary": "Android Profiler, CPU, memory ve network kullanımını analiz etmek için kullanılan resmi Android Studio aracıdır.",
              "content": "## Android Profiler\n\nGerçek zamanlı performans ölçümü sağlar.\n\nMemory leak ve ANR analizinde kullanılır.",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "CPU, Memory, Network analiz edilir",
                "Gerçek cihazda ölçüm önerilir",
                "Bottleneck tespiti yapılır",
                "Performans iyileştirme için şarttır"
              ],
              "questions": [
                {
                  "questionId": 470501,
                  "question": "Android Profiler ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece kod yazma",
                    "CPU, memory ve network kullanımını analiz etmek",
                    "Sadece UI çizme",
                    "Sadece crash report"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android Profiler, CPU, memory ve network kullanımını gerçek zamanlı olarak analiz etmek için kullanılan resmi Android Studio aracıdır.",
                  "tags": ["profiler", "tools"]
                },
                {
                  "questionId": 470502,
                  "question": "Android Profiler ile ne tür analizler yapılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece CPU",
                    "CPU, Memory, Network kullanımı, method trace, heap dump",
                    "Sadece UI",
                    "Sadece crash"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android Profiler ile CPU kullanımı, Memory (heap) analizi, Network trafiği, method tracing ve allocation tracking yapılabilir. Memory leak ve performans bottleneck tespit edilir.",
                  "tags": ["profiler", "features"]
                },
                {
                  "questionId": 470503,
                  "question": "Android Profiler kullanırken hangi öneri doğrudur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece emülatörde kullan",
                    "Gerçek cihazda ölçüm yapılması önerilir",
                    "Fark etmez",
                    "Sadece debug build'de"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android Profiler ile gerçek cihazda ölçüm yapılması önerilir çünkü emülatör performansı gerçek cihazdan farklı olabilir. Release build'de profiling daha doğru sonuç verir.",
                  "tags": ["profiler", "best_practice"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 470001,
              "question": "60 FPS (Frame Per Second) için her frame ne kadar sürede render edilmelidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "100ms",
                "16ms (1000ms / 60)",
                "1ms",
                "500ms"
              ],
              "correctAnswerIndex": 1,
              "explanation": "60 FPS için her frame 16ms'de (1000ms / 60 = 16.66ms) render edilmelidir. Bu süre aşılırsa frame drop (jank) oluşur ve UI akıcı olmaz.",
              "tags": ["performance", "fps", "frame"]
            },
            {
              "questionId": 470002,
              "question": "StrictMode ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "UI çizer",
                "Ana thread'de yapılan yanlış işlemleri (network, disk) tespit eder",
                "Sadece crash önler",
                "Bellek temizler"
              ],
              "correctAnswerIndex": 1,
              "explanation": "StrictMode, development sırasında ana thread'de yapılan yanlış işlemleri (network, disk I/O) tespit eder ve log/crash ile uyarır. Production'da kapatılmalıdır.",
              "tags": ["strictmode", "debugging"]
            },
            {
              "questionId": 470003,
              "question": "ViewHolder pattern RecyclerView'da neden önemlidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece görsel",
                "findViewById çağrılarını önbelleğe alarak performansı artırır",
                "Sadece bellek kullanır",
                "Hiçbir önemi yok"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ViewHolder pattern, findViewById çağrılarını önbelleğe alır. Her scroll'da tekrar findViewById çağrılmaz, view'lar reuse edilir, bu da büyük performans artışı sağlar.",
              "tags": ["performance", "recyclerview", "viewholder"]
            },
            {
              "questionId": 470004,
              "question": "Bitmap kullanırken memory leak'ten kaçınmak için ne yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey yapılmaz",
                "Kullanılmayan bitmap'ler recycle() ile temizlenmeli (API 10 altı), image loading library (Glide, Coil) kullanılmalı",
                "Daha fazla bitmap yükle",
                "Static olarak tut"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Bitmap'ler çok yer kaplar. Modern yaklaşım Glide, Coil gibi kütüphaneler kullanmaktır (otomatik cache ve memory yönetimi). API 10 altında bitmap.recycle() kullanılırdı.",
              "tags": ["memory", "bitmap", "leak"]
            },
            {
              "questionId": 470005,
              "question": "OutOfMemoryError (OOM) ne zaman oluşur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hiçbir zaman",
                "Uygulama ayrılmış memory limitini aştığında",
                "Sadece network hatası",
                "Sadece UI hatası"
              ],
              "correctAnswerIndex": 1,
              "explanation": "OutOfMemoryError, uygulama ayrılmış memory limitini (device'a göre değişir, örn: 512MB) aştığında oluşur. Genellikle büyük bitmap'ler, memory leak veya aşırı nesne yaratma sebeptir.",
              "tags": ["memory", "oom", "error"]
            },
            {
              "questionId": 470006,
              "question": "Layout performansını artırmak için hangi yaklaşım doğrudur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Daha fazla nested layout kullan",
                "ConstraintLayout kullan, nested layout'tan kaçın, ViewStub ile lazy loading yap",
                "Sadece LinearLayout kullan",
                "Hiçbir önlem alma"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Layout performansı için: ConstraintLayout kullan (flat hierarchy), nested layout'tan kaçın, ViewStub ile lazy loading yap, <merge> tag kullan, overdraw'dan kaçın.",
              "tags": ["performance", "layout", "optimization"]
            },
            {
              "questionId": 470007,
              "question": "NetworkOnMainThreadException ne zaman fırlatılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Her zaman",
                "Ana thread'de network işlemi yapılmaya çalışıldığında",
                "Sadece emülatörde",
                "Hiçbir zaman"
              ],
              "correctAnswerIndex": 1,
              "explanation": "NetworkOnMainThreadException, ana thread'de (Honeycomb/API 11+ sonrası) network işlemi yapılmaya çalışıldığında fırlatılır. Coroutine, AsyncTask (deprecated) kullanılmalıdır.",
              "tags": ["network", "exception", "main_thread"]
            },
            {
              "questionId": 470008,
              "question": "Lazy initialization neden performans artırır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir etkisi yok",
                "Nesne sadece gerektiğinde yaratılır, başlangıç süresi kısalır",
                "Daha fazla bellek kullanır",
                "Sadece görsel amaçlı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Lazy initialization (Kotlin'de lazy { }), nesneyi sadece ilk kullanımda yaratır. Bu, uygulama başlangıç süresini kısaltır ve kullanılmayan nesneler için gereksiz initialization yapılmaz.",
              "tags": ["performance", "lazy", "optimization"]
            },
            {
              "questionId": 470009,
              "question": "ProGuard/R8 ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece debug yapar",
                "Kod obfuscation, shrinking ve optimization yapar (APK boyutunu azaltır)",
                "Sadece crash report",
                "Hiçbir işe yaramaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ProGuard/R8, kod obfuscation (karıştırma), shrinking (kullanılmayan kod temizleme) ve optimization yapar. APK boyutunu küçültür ve reverse engineering'i zorlaştırır.",
              "tags": ["performance", "proguard", "r8"]
            },
            {
              "questionId": 470010,
              "question": "App Startup time'ı optimize etmek için ne yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey",
                "Application onCreate'de heavy işlemlerden kaçın, lazy init kullan, WorkManager ile ertele",
                "Daha fazla initialization",
                "Tüm işleri başlangıçta yap"
              ],
              "correctAnswerIndex": 1,
              "explanation": "App Startup time optimize etmek için: Application onCreate'de heavy işlemlerden kaçın, lazy initialization kullan, gerekli olmayan işleri WorkManager ile ertele, ContentProvider sayısını azalt.",
              "tags": ["performance", "startup", "optimization"]
            }
          ]
        },
        {
          "sectionId": 4800,
          "sectionTitle": "Modularization (Multi-Module Android)",
          "sectionDescription": "Büyük Android projelerinde kodun yönetilebilirliğini, test edilebilirliğini ve build performansını artırmak için kullanılan çok modüllü mimari yaklaşımı",
          "order": 8,
          "topics": [
            {
              "topicId": 4801,
              "title": "Modularization Nedir",
              "summary": "Modularization, bir Android uygulamasını bağımsız ve yeniden kullanılabilir modüllere bölme yaklaşımıdır. Büyük projelerde karmaşıklığı azaltır.",
              "content": "## Modularization Nedir\n\nUygulama tek bir module yerine birden fazla module ayrılır.\n\nHer modül belirli bir sorumluluğa sahiptir.\n\nTakım çalışmasını ve ölçeklenebilirliği artırır.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [],
              "keyPoints": [
                "Kod karmaşıklığını azaltır",
                "Takım çalışmasını kolaylaştırır",
                "Bağımlılık yönetimini iyileştirir",
                "Büyük projeler için idealdir"
              ],
              "questions": [
                {
                  "questionId": 480101,
                  "question": "Modularization (Modülerleştirme) nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece kod yazmak",
                    "Uygulamayı bağımsız ve yeniden kullanılabilir modüllere bölme yaklaşımı",
                    "Sadece veritabanı tasarımı",
                    "Sadece UI tasarımı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modularization, bir Android uygulamasını bağımsız ve yeniden kullanılabilir modüllere bölme yaklaşımıdır. Büyük projelerde karmaşıklığı azaltır.",
                  "tags": ["modularization", "temel"]
                },
                {
                  "questionId": 480102,
                  "question": "Modularization'ın avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha fazla dosya",
                    "Kod karmaşıklığını azaltır, takım çalışmasını kolaylaştırır, build performansını artırır",
                    "Sadece daha yavaş build",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modularization, kod karmaşıklığını azaltır, takım çalışmasını kolaylaştırır (parallel development), bağımlılık yönetimini iyileştirir ve build performansını artırır (incremental build).",
                  "tags": ["modularization", "advantages"]
                },
                {
                  "questionId": 480103,
                  "question": "Modularization hangi büyüklükte projeler için uygundur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her proje için şart",
                    "Orta ve büyük ölçekli projeler için idealdir",
                    "Sadece küçük projeler",
                    "Hiçbir proje için uygun değil"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modularization, orta ve büyük ölçekli projeler için idealdir. Küçük projelerde gereksiz karmaşıklık yaratabilir (overengineering).",
                  "tags": ["modularization", "project_size"]
                }
              ]
            },
            {
              "topicId": 4802,
              "title": "Module Türleri",
              "summary": "Android projelerinde farklı amaçlara hizmet eden çeşitli modül türleri bulunur.",
              "content": "## Module Türleri\n\n- App Module\n- Library Module\n- Feature Module (Dynamic Feature)\n\nHer modül farklı sorumluluklar üstlenir.",
              "difficulty": "easy",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "App module uygulamanın giriş noktasıdır",
                "Library module yeniden kullanılabilir kod içerir",
                "Feature module opsiyonel özellikler sunar",
                "Dynamic Feature ile indirme boyutu küçülür"
              ],
              "questions": [
                {
                  "questionId": 480201,
                  "question": "Android'de kaç tür modül vardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece 1 tür",
                    "App Module, Library Module, Feature Module",
                    "Sadece App Module",
                    "10 tür"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Android'de temel modül türleri: App Module (uygulama giriş noktası), Library Module (yeniden kullanılabilir kod), Feature Module (opsiyonel özellikler, Dynamic Feature).",
                  "tags": ["module", "types"]
                },
                {
                  "questionId": 480202,
                  "question": "App Module'ün görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece test yapar",
                    "Uygulamanın giriş noktasıdır, diğer modülleri birleştirir",
                    "Sadece UI çizer",
                    "Veritabanı yönetir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "App Module, uygulamanın giriş noktasıdır (Application class, MainActivity). Diğer modülleri birleştirir ve APK/AAB üretir.",
                  "tags": ["app_module", "module"]
                },
                {
                  "questionId": 480203,
                  "question": "Dynamic Feature Module'ün avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha hızlı",
                    "Opsiyonel özellikleri on-demand indirerek başlangıç APK boyutunu küçültür",
                    "Sadece daha güvenli",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dynamic Feature Module, opsiyonel özellikleri (kamera filtreler, premium features) on-demand indirerek başlangıç APK boyutunu küçültür. Play Core Library ile yönetilir.",
                  "tags": ["dynamic_feature", "module", "optimization"]
                }
              ]
            },
            {
              "topicId": 4803,
              "title": "Gradle Module Yapısı",
              "summary": "Multi-module projelerde Gradle, modüller arası bağımlılıkları ve build sürecini yönetir.",
              "content": "## Gradle Module Yapısı\n\nsettings.gradle dosyası modülleri tanımlar.\n\nModüller arası bağımlılıklar implementation(project()) ile eklenir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Module Bağımlılığı",
                  "code": "implementation(project(\":core\"))",
                  "explanation": "core modülünü app modülüne dahil eder."
                }
              ],
              "keyPoints": [
                "Modüller arası bağımlılık açıkça tanımlanır",
                "Yanlış bağımlılık circular dependency oluşturabilir",
                "Build süresi optimize edilir",
                "Gradle yapılandırması kritik öneme sahiptir"
              ],
              "questions": [
                {
                  "questionId": 480301,
                  "question": "Multi-module projede modüller hangi dosyada tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "build.gradle",
                    "settings.gradle",
                    "AndroidManifest.xml",
                    "gradle.properties"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Multi-module projede modüller settings.gradle (veya settings.gradle.kts) dosyasında include ile tanımlanır. Örnek: include ':app', ':core'",
                  "tags": ["gradle", "settings"]
                },
                {
                  "questionId": 480302,
                  "question": "Bir modülün başka bir modüle bağımlılığı nasıl eklenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Otomatik eklenir",
                    "implementation(project(':module_adi'))",
                    "Eklenemez",
                    "Sadece Manifest'e yazılır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modüller arası bağımlılık, build.gradle dosyasında implementation(project(':module_adi')) ile eklenir.",
                  "tags": ["gradle", "dependency"]
                },
                {
                  "questionId": 480303,
                  "question": "Circular dependency nedir ve neden problemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir problem değil",
                    "İki modülün birbirine bağımlı olması; build hatası verir",
                    "Sadece yavaşlatır",
                    "Performans artırır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Circular dependency, iki modülün birbirine bağımlı olmasıdır (A → B ve B → A). Gradle build hatası verir. Çözüm: ortak kod yeni bir modüle taşınmalı (örn: :common).",
                  "tags": ["gradle", "circular_dependency", "error"]
                },
                {
                  "questionId": 480304,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "implementation(project(':core'))",
                  "difficulty": "easy",
                  "options": [
                    "core modülünü siler",
                    "core modülünü bağımlılık olarak ekler",
                    "Hata verir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, :core modülünü mevcut modüle bağımlılık olarak ekler. core modülündeki kodlar kullanılabilir hale gelir.",
                  "tags": ["gradle", "implementation", "example"]
                }
              ]
            },
            {
              "topicId": 4804,
              "title": "Clean Architecture ile Modularization",
              "summary": "Clean Architecture, modüller arası bağımlılıkların tek yönlü olmasını sağlar ve kodun test edilebilirliğini artırır.",
              "content": "## Clean Architecture & Modules\n\nGenellikle şu yapı kullanılır:\n\n- data\n- domain\n- ui\n\nDomain katmanı hiçbir Android bağımlılığı içermez.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [],
              "keyPoints": [
                "Bağımlılıklar içe doğru olmalıdır",
                "Domain katmanı saf Kotlin içerir",
                "Test yazımı kolaylaşır",
                "Uzun vadeli sürdürülebilirlik sağlar"
              ],
              "questions": [
                {
                  "questionId": 480401,
                  "question": "Clean Architecture ile modülerleştirmede tipik modül yapısı nasıldır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Tek modül",
                    ":app, :data, :domain, :presentation (veya feature modülleri)",
                    "Sadece :app ve :test",
                    "Rastgele modüller"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture ile modülerleştirmede tipik yapı: :app (giriş noktası), :data (repository impl), :domain (UseCase, Entity), :presentation veya feature bazlı modüller.",
                  "tags": ["clean_architecture", "module", "structure"]
                },
                {
                  "questionId": 480402,
                  "question": "Domain modülü hangi özelliklere sahip olmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Android bağımlılıkları içermeli",
                    "Hiçbir Android framework bağımlılığı içermemeli, saf Kotlin olmalı",
                    "UI içermeli",
                    "Sadece test için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Domain modülü, hiçbir Android framework bağımlılığı içermemeli, saf Kotlin/Java olmalıdır. Bu, platform bağımsızlık ve test edilebilirlik sağlar.",
                  "tags": ["domain", "module", "clean_architecture"]
                },
                {
                  "questionId": 480403,
                  "question": "Modüller arası bağımlılık yönü nasıl olmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her yöne olabilir",
                    "İçe doğru: app → presentation → domain ← data",
                    "Dışa doğru",
                    "Fark etmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Clean Architecture'da bağımlılık içe doğrudur: app → presentation → domain ← data. Domain katmanı hiçbir dış katmana bağımlı değildir (Dependency Inversion Principle).",
                  "tags": ["dependency", "clean_architecture", "direction"]
                },
                {
                  "questionId": 480404,
                  "question": "Feature modül yaklaşımının avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha fazla dosya",
                    "Her feature bağımsız geliştirilebilir, parallel çalışma ve ownership kolaylaşır",
                    "Sadece daha yavaş",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Feature modül yaklaşımı (:feature-login, :feature-profile), her feature'ın bağımsız geliştirilmesini sağlar. Takım üyeleri parallel çalışabilir, feature ownership net olur.",
                  "tags": ["feature_module", "parallel_development"]
                }
              ]
            },
            {
              "topicId": 4805,
              "title": "Modularization Avantajları ve Dezavantajları",
              "summary": "Multi-module mimari birçok avantaj sunsa da yanlış kullanımda karmaşıklık yaratabilir.",
              "content": "## Avantajlar & Dezavantajlar\n\nAvantajlar:\n- Daha hızlı build\n- Daha temiz kod\n\nDezavantajlar:\n- İlk kurulum karmaşıktır\n- Küçük projeler için gereksiz olabilir",
              "difficulty": "medium",
              "order": 5,
              "codeExamples": [],
              "keyPoints": [
                "Büyük projelerde ciddi fayda sağlar",
                "Küçük projelerde overengineering olabilir",
                "Doğru planlama şarttır",
                "Senior seviye mimari bilgisidir"
              ],
              "questions": [
                {
                  "questionId": 480501,
                  "question": "Modularization'ın build performansına etkisi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her zaman yavaşlatır",
                    "Incremental build sayesinde daha hızlı build süresi (sadece değişen modüller build edilir)",
                    "Hiçbir etkisi yok",
                    "Sadece küçük projelerde hızlandırır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modularization, incremental build sayesinde build süresini kısaltır. Sadece değişen modüller yeniden build edilir, değişmeyen modüller cache'ten kullanılır.",
                  "tags": ["modularization", "build_performance"]
                },
                {
                  "questionId": 480502,
                  "question": "Modularization'ın dezavantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir dezavantajı yok",
                    "İlk kurulum karmaşık, küçük projeler için overengineering, Gradle yapılandırması dikkat gerektirir",
                    "Sadece yavaş build",
                    "Sadece daha fazla kod"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modularization'ın dezavantajları: İlk kurulum karmaşık, küçük projeler için gereksiz (overengineering), Gradle yapılandırması ve bağımlılık yönetimi dikkat gerektirir.",
                  "tags": ["modularization", "disadvantages"]
                },
                {
                  "questionId": 480503,
                  "question": "Modularization ne zaman uygulanmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her projede hemen başta",
                    "Büyük projelerde veya proje büyümeye başladığında, küçük projelerde gerekli değilse sonra",
                    "Hiçbir zaman",
                    "Sadece test projelerinde"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modularization, büyük projelerde baştan veya proje büyümeye başladığında uygulanmalıdır. Küçük/MVP projelerde başta gerekli değilse sonra refactor edilebilir. Ancak büyüyecek projelerde erken uygulamak migrasyonu kolaylaştırır.",
                  "tags": ["modularization", "when", "strategy"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 480001,
              "question": "Multi-module projede hangi modül APK/AAB üretir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Her modül",
                "Sadece App Module (com.android.application plugin'i olan)",
                "Sadece Library Module",
                "Feature Module"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Sadece App Module (com.android.application plugin'i olan) APK/AAB üretir. Library ve Feature modüller AAR (Android Archive) üretir.",
              "tags": ["module", "apk", "app_module"]
            },
            {
              "questionId": 480002,
              "question": "api() ve implementation() arasındaki fark nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "api() bağımlılığı transitive (geçişli) olarak dışa açar, implementation() gizler",
                "api() daha yavaştır",
                "implementation() kullanımdan kalkmıştır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "api(), bağımlılığı transitive olarak dışa açar (A→B→C hepsine erişir). implementation() gizler (A→B, ama A'dan C'ye direkt erişim yok). implementation() tercih edilir (daha hızlı build).",
              "tags": ["gradle", "api", "implementation"]
            },
            {
              "questionId": 480003,
              "question": "Convention Plugin nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece UI plugin",
                "Ortak Gradle yapılandırmasını tüm modüllerde paylaşmak için kullanılan custom plugin",
                "Sadece test plugin",
                "Android Studio plugin"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Convention Plugin, ortak Gradle yapılandırmasını (Kotlin version, dependencies, compiler options) tüm modüllerde paylaşmak için kullanılan custom plugin'dir. Kod tekrarını önler.",
              "tags": ["gradle", "convention_plugin", "buildSrc"]
            },
            {
              "questionId": 480004,
              "question": "Version Catalog nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "UI komponenti",
                "Dependency versiyonlarını merkezi yönetmek için kullanılan Gradle özelliği",
                "Veritabanı",
                "Test aracı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Version Catalog (libs.versions.toml), dependency versiyonlarını merkezi yönetmek için kullanılan Gradle özelliğidir. Tüm modüllerde aynı version kullanımını garantiler.",
              "tags": ["gradle", "version_catalog", "dependency"]
            },
            {
              "questionId": 480005,
              "question": "buildSrc klasörü ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece kaynak dosyaları",
                "Gradle plugin ve convention plugin yazmak için kullanılan özel Gradle klasörü",
                "Sadece test dosyaları",
                "APK üretir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "buildSrc, Gradle plugin ve convention plugin yazmak için kullanılan özel klasördür. Kotlin DSL ile custom logic yazılabilir ve tüm modüllerde kullanılabilir.",
              "tags": ["gradle", "buildsrc", "plugin"]
            },
            {
              "questionId": 480006,
              "question": "Composite Build nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece UI build",
                "Birden fazla Gradle projesini tek build içinde birleştirme",
                "Sadece test build",
                "APK oluşturma"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Composite Build, birden fazla bağımsız Gradle projesini (örn: app + shared library) tek build içinde birleştirmeyi sağlar. includeBuild() ile tanımlanır.",
              "tags": ["gradle", "composite_build"]
            },
            {
              "questionId": 480007,
              "question": "Modüller arası navigation nasıl yönetilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Doğrudan Activity çağrısı",
                "Navigation Component + Deep Link veya Interface/Callback pattern",
                "Sadece Intent",
                "Yönetilemez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Multi-module'de navigation için Navigation Component + Deep Link veya Interface/Callback pattern kullanılır. Bu, modüller arası sıkı bağımlılığı (tight coupling) önler.",
              "tags": ["navigation", "multi_module", "deep_link"]
            },
            {
              "questionId": 480008,
              "question": "Modüller arası resource (R class) paylaşımı nasıl yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Otomatik paylaşılır",
                "Library module'deki resources implementation ile bağımlılık alan modülde kullanılabilir",
                "Paylaşılamaz",
                "Sadece copy-paste"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Library module'deki resources (drawable, string, style), implementation(project(':module')) ile bağımlılık alan modülde R.drawable.xxx şeklinde kullanılabilir.",
              "tags": ["resource", "multi_module", "r_class"]
            },
            {
              "questionId": 480009,
              "question": "Parallel module build nasıl etkinleştirilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Otomatik aktif",
                "gradle.properties'e org.gradle.parallel=true eklenerek",
                "AndroidManifest'e eklenerek",
                "Etkinleştirilemez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Parallel module build, gradle.properties dosyasına org.gradle.parallel=true eklenerek etkinleştirilir. Bu, bağımsız modüllerin paralel build edilmesini sağlar (daha hızlı build).",
              "tags": ["gradle", "parallel", "performance"]
            },
            {
              "questionId": 480010,
              "question": "Multi-module projede test stratejisi nasıl olmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece app module'de test",
                "Her modül kendi testlerini içermeli (unit, integration), app module end-to-end test",
                "Test yazılmaz",
                "Sadece UI test"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Multi-module'de her modül kendi testlerini içermelidir: domain (unit test), data (integration test), feature (unit + UI test), app module (end-to-end test). Bu, modüler test stratejisi sağlar.",
              "tags": ["testing", "multi_module", "strategy"]
            }
          ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 490001,
          "question": "Coroutine'lerde suspend function ne demektir ve neden önemlidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Normal fonksiyon ile aynı",
            "Coroutine içinde çalışabilen, thread bloklamadan askıya alınabilen fonksiyon",
            "Sadece network için",
            "Kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Suspend function, coroutine içinde çalışabilen ve execution'ı askıya alabilen (pausable) fonksiyondur. Thread bloklamaz, asenkron işlemler için temeldir.",
          "tags": ["coroutines", "suspend"]
        },
        {
          "questionId": 490002,
          "question": "Flow ve LiveData arasındaki temel fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Hiçbir fark yok",
            "Flow coroutine tabanlı ve daha esnektir, LiveData lifecycle-aware'dır",
            "LiveData daha modern",
            "Flow kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Flow, coroutine tabanlıdır ve map, filter gibi operatörlerle daha esnektir. LiveData ise lifecycle-aware'dır ancak sınırlıdır. Modern projelerde Flow (özellikle StateFlow) tercih edilir.",
          "tags": ["flow", "livedata", "comparison"]
        },
        {
          "questionId": 490003,
          "question": "Hilt'te @HiltViewModel ve constructor injection kullanmanın avantajı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece daha hızlı",
            "ViewModel bağımlılıkları otomatik sağlanır, test edilebilirlik artar, boilerplate azalır",
            "Sadece görsel",
            "Hiçbir avantajı yok"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Hilt ile ViewModel'de constructor injection kullanarak bağımlılıklar otomatik sağlanır, test edilebilirlik artar ve ViewModelProvider.Factory gibi boilerplate kodlar ortadan kalkar.",
          "tags": ["hilt", "viewmodel", "dependency_injection"]
        },
        {
          "questionId": 490004,
          "question": "Clean Architecture'da bağımlılık yönü nasıl olmalıdır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Her yöne olabilir",
            "İçe doğru: Presentation → Domain ← Data (Domain hiçbir dış katmana bağımlı değil)",
            "Dışa doğru",
            "Fark etmez"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Clean Architecture'da bağımlılık kuralı: Dış katmanlar (Presentation, Data) iç katmana (Domain) bağımlıdır, tersi asla olmaz. Domain, framework bağımsızdır (Dependency Inversion Principle).",
          "tags": ["clean_architecture", "dependency_rule"]
        },
        {
          "questionId": 490005,
          "question": "Dispatchers.IO ve Dispatchers.Default arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Hiçbir fark yok",
            "IO: Network/Database, Default: CPU yoğun işlemler",
            "Default daha yavaş",
            "IO kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Dispatchers.IO, I/O operasyonları (network, database, file) için optimize edilmiştir. Dispatchers.Default ise CPU-intensive işlemler (parsing, sıralama, hesaplama) için optimize edilmiştir.",
          "tags": ["coroutines", "dispatchers"]
        },
        {
          "questionId": 490006,
          "question": "StateFlow'un hot stream olması ne anlama gelir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Daha hızlı",
            "Collect edilmese bile aktiftir, yeni observer'a son değeri hemen verir",
            "Sadece sıcak havalarda",
            "Cold stream ile aynı"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Hot stream, collect edilmese bile aktiftir. StateFlow her zaman bir değer tutar ve yeni observer geldiğinde son değeri anında iletir. UI state yönetimi için idealdir.",
          "tags": ["flow", "stateflow", "hot_stream"]
        },
        {
          "questionId": 490007,
          "question": "Test Pyramid'e göre hangi test türü en fazla olmalıdır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "UI Test",
            "Unit Test",
            "Integration Test",
            "Hepsi eşit"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Test Pyramid: Unit Test (en çok) → Integration Test (orta) → UI Test (en az). Unit test hızlı ve ucuzdur, UI test yavaş ve pahalıdır.",
          "tags": ["testing", "test_pyramid"]
        },
        {
          "questionId": 490008,
          "question": "Memory Leak'in en sık nedenleri nelerdir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Sadece UI hatası",
            "Static Activity referansı, yanlış Context kullanımı, lifecycle'a bağlı olmayan observer'lar",
            "Sadece network hatası",
            "Hiçbir nedeni yok"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Memory Leak'in en sık nedenleri: Static Activity/Context referansı, yanlış Context kullanımı (Activity yerine Application), lifecycle'a bağlı olmayan observer/listener'lar.",
          "tags": ["performance", "memory_leak"]
        },
        {
          "questionId": 490009,
          "question": "UseCase nedir ve neden kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "UI bileşeni",
            "İş mantığını kapsülleyen, tek bir sorumluluğu olan sınıf (Clean Architecture - Domain)",
            "Veritabanı tablosu",
            "Network kütüphanesi"
          ],
          "correctAnswerIndex": 1,
          "explanation": "UseCase, Clean Architecture'ın Domain katmanında, uygulamanın iş mantığını (business logic) kapsülleyen, tek bir sorumluluğu olan (Single Responsibility) sınıftır.",
          "tags": ["clean_architecture", "usecase", "domain"]
        },
        {
          "questionId": 490010,
          "question": "Mockito ile test yazmanın amacı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Gerçek API kullanma",
            "Bağımlılıkları mock ederek izole test yazma",
            "Sadece UI test",
            "Hiçbir amacı yok"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Mockito, bağımlılıkları (Repository, API, Database) mock ederek izole test yazılmasını sağlar. Gerçek API çağrısı yapmadan test yazılabilir, test stabilitesi artar.",
          "tags": ["testing", "mockito", "mocking"]
        },
        {
          "questionId": 490011,
          "question": "ANR (Application Not Responding) ne zaman oluşur?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Hiçbir zaman",
            "Ana thread 5+ saniye bloklandığında",
            "Sadece crash durumunda",
            "Sadece bellek dolduğunda"
          ],
          "correctAnswerIndex": 1,
          "explanation": "ANR, ana thread uzun süre (genellikle 5 saniye+) bloklandığında Android tarafından uygulamanın durdurulmasıdır. Network, database veya heavy işlem ana thread'de yapılmamalıdır.",
          "tags": ["performance", "anr"]
        },
        {
          "questionId": 490012,
          "question": "withContext() ne işe yarar?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Yeni scope oluşturur",
            "Mevcut coroutine'in dispatcher'ını geçici olarak değiştirir",
            "Coroutine'i iptal eder",
            "Sadece hız artırır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "withContext(), mevcut coroutine içinde dispatcher'ı geçici olarak değiştirmek için kullanılır. Örneğin IO'da çalışıp sonucu Main'de döndürmek için: withContext(Dispatchers.IO) { }",
          "tags": ["coroutines", "withcontext"]
        },
        {
          "questionId": 490013,
          "question": "Repository pattern'in amacı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Sadece veri saklar",
            "Veri kaynaklarını (API, Database) soyutlar ve ViewModel'e tek bir veri akışı sunar",
            "Sadece network işlemleri",
            "UI çizer"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Repository pattern, veri kaynaklarını (Retrofit, Room, SharedPreferences) soyutlar ve ViewModel'e tek bir clean data interface sunar. Single source of truth ve abstraction sağlar.",
          "tags": ["repository", "architecture", "mvvm"]
        },
        {
          "questionId": 490014,
          "question": "Hilt'te @Singleton scope ne anlama gelir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Her seferinde yeni instance",
            "Uygulama boyunca tek instance (Application lifecycle)",
            "Activity başına bir instance",
            "ViewModel başına bir instance"
          ],
          "correctAnswerIndex": 1,
          "explanation": "@Singleton scope, bağımlılığın uygulama boyunca tek bir instance olarak yaşamasını sağlar (Application lifecycle). Memory ve performans için önemlidir.",
          "tags": ["hilt", "singleton", "scope"]
        },
        {
          "questionId": 490015,
          "question": "Modularization'ın build performansına etkisi nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Her zaman yavaşlatır",
            "Incremental build sayesinde daha hızlı (sadece değişen modüller build edilir)",
            "Hiçbir etkisi yok",
            "Sadece küçük projelerde hızlandırır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Modularization, incremental build sayesinde build süresini kısaltır. Sadece değişen modüller yeniden build edilir, değişmeyen modüller cache'ten kullanılır.",
          "tags": ["modularization", "build_performance"]
        },
        {
          "questionId": 490016,
          "question": "viewModelScope'un lifecycleScope'a göre avantajı nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Hiçbir fark yok",
            "ViewModel configuration change'lerde hayatta kalır, lifecycleScope Activity/Fragment lifecycle'ına bağlı",
            "lifecycleScope daha hızlı",
            "viewModelScope kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "viewModelScope, ViewModel'in lifecycle'ına bağlıdır ve configuration change'lerde (ekran döndürme) hayatta kalır. lifecycleScope ise Activity/Fragment lifecycle'ına bağlıdır ve yok olduğunda iptal edilir.",
          "tags": ["coroutines", "viewmodelscope", "lifecycle"]
        },
        {
          "questionId": 490017,
          "question": "Clean Architecture'da DTO (Data Transfer Object) nedir ve hangi katmanda kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Domain model, Domain'de",
            "API response modeli, Data katmanında (Network'ten gelen ham veri)",
            "UI modeli, Presentation'da",
            "UseCase"
          ],
          "correctAnswerIndex": 1,
          "explanation": "DTO, API'den gelen ham veriyi temsil eder ve Data katmanında kullanılır. Data katmanında DTO'dan Domain Entity'ye mapping yapılır (toEntity()). Bu, katmanların bağımsız olmasını sağlar.",
          "tags": ["clean_architecture", "dto", "data"]
        },
        {
          "questionId": 490018,
          "question": "SharedFlow ve StateFlow arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiçbir fark yok",
            "StateFlow her zaman bir state tutar, SharedFlow event-driven'dır",
            "SharedFlow daha yavaş",
            "StateFlow kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "StateFlow her zaman bir state (değer) tutar ve yeni observer'a son değeri verir (UI state için). SharedFlow ise event-driven'dır, geçmiş değerleri tutmayabilir (one-time events, navigation için).",
          "tags": ["flow", "stateflow", "sharedflow"]
        },
        {
          "questionId": 490019,
          "question": "Unit Test ve UI Test arasındaki temel fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Hiçbir fark yok",
            "Unit Test UI bağımsız ve hızlı, UI Test gerçek cihazda çalışır ve yavaş",
            "UI Test daha önemli",
            "Unit Test kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Unit Test, UI bağımsız çalışır, çok hızlıdır (saniyeler) ve ViewModel/UseCase test eder. UI Test (Espresso), gerçek cihaz/emülatörde çalışır, yavaştır ama kullanıcı etkileşimini test eder.",
          "tags": ["testing", "unit_test", "ui_test"]
        },
        {
          "questionId": 490020,
          "question": "Circular dependency nedir ve neden problemlidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiçbir problem değil",
            "İki modülün birbirine bağımlı olması; Gradle build hatası verir",
            "Sadece yavaşlatır",
            "Performans artırır"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Circular dependency, iki modülün birbirine bağımlı olmasıdır (A → B ve B → A). Gradle build hatası verir. Çözüm: ortak kod yeni bir modüle (örn: :common) taşınmalı.",
          "tags": ["modularization", "circular_dependency", "gradle"]
        }
      ]
    },
    {
      "categoryId": 5,
      "categoryTitle": "Jetpack Compose",
      "categoryDescription": "Modern UI geliştirme için Jetpack Compose kütüphanesini öğrenin.",
      "order": 5,
      "sections": [
        {
          "sectionId": 5100,
          "sectionTitle": "Compose Temelleri",
          "sectionDescription": "Jetpack Compose'un temel yapısı, declarative UI yaklaşımı ve temel UI bileşenleri",
          "order": 1,
          "topics": [
            {
              "topicId": 5101,
              "title": "Compose Nedir ve Neden Compose",
              "summary": "Jetpack Compose, Android için modern, declarative (bildirimsel) bir UI toolkit'tir. XML yerine Kotlin kod ile UI oluşturmayı sağlar.",
              "content": "## Compose Nedir\n\nCompose, Google tarafından geliştirilen resmi modern UI framework'üdür.\n\nDeclarative (bildirimsel) yaklaşım kullanır.\n\nDaha az kod, daha kolay bakım ve daha güçlü UI sağlar.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Basit Compose Örneği",
                  "code": "@Composable\nfun Greeting() {\n    Text(text = \"Merhaba Compose!\")\n}",
                  "explanation": "Compose'da UI Kotlin fonksiyonları ile oluşturulur."
                }
              ],
              "keyPoints": [
                "Modern Android UI framework'ü",
                "Declarative yaklaşım kullanır",
                "XML yerine Kotlin ile UI",
                "Daha az boilerplate kod"
              ],
              "questions": [
                {
                  "questionId": 510101,
                  "question": "Jetpack Compose nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı kütüphanesi",
                    "Android için modern, declarative UI toolkit",
                    "Network kütüphanesi",
                    "Test framework'ü"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Jetpack Compose, Android için Google tarafından geliştirilen modern, declarative (bildirimsel) UI toolkit'tir.",
                  "tags": ["compose", "temel"]
                },
                {
                  "questionId": 510102,
                  "question": "Compose'un XML'e göre avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece daha hızlı",
                    "Daha az kod, Kotlin'in gücü, daha kolay bakım, type-safe",
                    "Sadece görsel",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose, daha az kod, Kotlin'in gücünü kullanma, daha kolay bakım, type-safety ve declarative yaklaşım avantajları sunar.",
                  "tags": ["compose", "advantages", "xml"]
                },
                {
                  "questionId": 510103,
                  "question": "Compose hangi programlama dili ile yazılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Java",
                    "Kotlin",
                    "XML",
                    "JavaScript"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Jetpack Compose, Kotlin ile yazılır. XML kullanılmaz, UI tamamen Kotlin kodu ile oluşturulur.",
                  "tags": ["compose", "kotlin"]
                },
                {
                  "questionId": 510104,
                  "question": "Compose hangi şirket tarafından geliştirilmiştir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Facebook",
                    "Google",
                    "Microsoft",
                    "Apple"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Jetpack Compose, Google tarafından geliştirilmiş resmi Android UI framework'üdür.",
                  "tags": ["compose", "google"]
                },
                {
                  "questionId": 510105,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "@Composable\nfun Greeting() {\n    Text(text = \"Merhaba Compose!\")\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "Ekrana 'Merhaba Compose!' metnini gösterir",
                    "Sadece log yazdırır",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu Composable fonksiyon, ekrana 'Merhaba Compose!' metnini gösteren bir Text bileşeni oluşturur.",
                  "tags": ["compose", "text", "example"]
                }
              ]
            },
            {
              "topicId": 5102,
              "title": "Declarative vs Imperative UI",
              "summary": "Declarative UI, 'nasıl' değil 'ne' istediğini söyler. Compose declarative, XML imperative yaklaşımdır.",
              "content": "## Declarative vs Imperative\n\nDeclarative: UI'ın son halini tanımla, framework halleder.\n\nImperative: UI'ı adım adım oluştur, her değişikliği manuel yap.\n\nCompose declarative, XML imperative'dir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [],
              "keyPoints": [
                "Declarative 'ne' istediğini söyler",
                "Imperative 'nasıl' yapılacağını söyler",
                "Compose declarative yaklaşım",
                "Daha az hata, daha kolay bakım"
              ],
              "questions": [
                {
                  "questionId": 510201,
                  "question": "Declarative UI nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI'ı adım adım oluşturma",
                    "UI'ın son halini tanımlama, framework'ün nasıl yapacağını belirlemesi",
                    "Sadece XML kullanma",
                    "Manuel UI güncelleme"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Declarative UI, 'nasıl' değil 'ne' istediğini söyler. UI'ın son halini tanımlarsınız, framework nasıl yapılacağını halleder.",
                  "tags": ["declarative", "ui"]
                },
                {
                  "questionId": 510202,
                  "question": "Imperative UI nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI'ın son halini tanımlama",
                    "UI'ı adım adım oluşturma ve her değişikliği manuel yapma",
                    "Sadece Compose kullanma",
                    "Otomatik UI güncelleme"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Imperative UI, 'nasıl' yapılacağını söyler. UI'ı adım adım oluşturur ve her değişikliği manuel yaparsınız (findViewById, setText vb.).",
                  "tags": ["imperative", "ui"]
                },
                {
                  "questionId": 510203,
                  "question": "XML hangi yaklaşımı kullanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Declarative",
                    "Imperative (findViewById, setText vb. ile manuel güncelleme)",
                    "Her ikisi de",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "XML, UI tanımı declarative olsa da güncelleme imperative'dir (findViewById, setText gibi manuel işlemler). Compose ise tamamen declarative'dir.",
                  "tags": ["xml", "imperative"]
                },
                {
                  "questionId": 510204,
                  "question": "Declarative yaklaşımın avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha hızlı",
                    "Daha az hata, daha kolay bakım, state değişince UI otomatik güncellenir",
                    "Sadece daha az kod",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Declarative yaklaşımda, state değişince UI otomatik güncellenir (recomposition). Bu, daha az hata, daha kolay bakım ve tutarlı UI sağlar.",
                  "tags": ["declarative", "advantages"]
                }
              ]
            },
            {
              "topicId": 5103,
              "title": "@Composable Fonksiyonlar",
              "summary": "@Composable annotation'ı ile işaretlenen fonksiyonlar UI oluşturur. Compose'un temel yapı taşıdır.",
              "content": "## @Composable\n\n@Composable annotation'ı fonksiyonu UI bileşeni yapar.\n\nSadece başka @Composable içinden çağrılabilir.\n\nCapital letter ile başlamalıdır (convention).",
              "difficulty": "easy",
              "order": 3,
              "codeExamples": [
                {
                  "title": "@Composable Fonksiyon",
                  "code": "@Composable\nfun MyButton() {\n    Button(onClick = { }) {\n        Text(\"Tıkla\")\n    }\n}",
                  "explanation": "Composable fonksiyon tanımlama."
                }
              ],
              "keyPoints": [
                "UI bileşeni oluşturur",
                "Sadece Composable içinden çağrılır",
                "Capital letter convention",
                "Return type yok (Unit)"
              ],
              "questions": [
                {
                  "questionId": 510301,
                  "question": "@Composable annotation'ı ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece görsel amaçlı",
                    "Fonksiyonu UI bileşeni yapar, Compose compiler'a bildirir",
                    "Test için kullanılır",
                    "Hiçbir işe yaramaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Composable annotation'ı, fonksiyonu UI bileşeni yapar ve Compose compiler'a bu fonksiyonun özel şekilde işlenmesi gerektiğini bildirir.",
                  "tags": ["composable", "annotation"]
                },
                {
                  "questionId": 510302,
                  "question": "@Composable fonksiyon nereden çağrılabilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her yerden",
                    "Sadece başka @Composable fonksiyon içinden",
                    "Sadece Activity'den",
                    "Sadece ViewModel'den"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Composable fonksiyonlar sadece başka @Composable fonksiyon içinden veya setContent { } bloğu içinden çağrılabilir.",
                  "tags": ["composable", "scope"]
                },
                {
                  "questionId": 510303,
                  "question": "Composable fonksiyon isimlendirme convention'ı nasıldır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "camelCase (myButton)",
                    "PascalCase - Capital letter ile başlamalı (MyButton)",
                    "snake_case (my_button)",
                    "Fark etmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Composable fonksiyonlar PascalCase ile (Capital letter ile başlayarak) isimlendirilir. Bu, Compose convention'ıdır ve UI bileşeni olduğunu gösterir.",
                  "tags": ["composable", "naming", "convention"]
                },
                {
                  "questionId": 510304,
                  "question": "Composable fonksiyonun return type'ı ne olmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "View",
                    "Unit (genellikle belirtilmez)",
                    "String",
                    "Int"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Composable fonksiyonlar genellikle Unit döner (hiçbir şey dönmez). UI bileşenini compose tree'ye ekler, return etmez.",
                  "tags": ["composable", "return_type"]
                },
                {
                  "questionId": 510305,
                  "question": "Aşağıdaki kod doğru mu?",
                  "questionType": "multiple_choice",
                  "code": "@Composable\nfun MyButton() {\n    Button(onClick = { }) {\n        Text(\"Tıkla\")\n    }\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, doğru Composable fonksiyon",
                    "Sadece Preview'da çalışır",
                    "Return type eksik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru bir Composable fonksiyondur. @Composable ile işaretlenmiş, PascalCase isimlendirme ve içinde başka Composable'lar (Button, Text) kullanılmış.",
                  "tags": ["composable", "example", "button"]
                }
              ]
            },
            {
              "topicId": 5104,
              "title": "Preview & Tooling",
              "summary": "@Preview annotation'ı ile Composable'ı Android Studio'da kod yazarken görüntüleyebilirsiniz.",
              "content": "## Preview\n\n@Preview ile UI'ı emülatör açmadan görüntülersiniz.\n\nInteractive Preview ile tıklama test edilebilir.\n\nMulti-preview desteği vardır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Preview Örneği",
                  "code": "@Preview(showBackground = true)\n@Composable\nfun GreetingPreview() {\n    Greeting()\n}",
                  "explanation": "Preview ile Composable'ı görüntüleme."
                }
              ],
              "keyPoints": [
                "Emülatör gerektirmez",
                "Hızlı UI geliştirme",
                "Interactive preview mevcut",
                "Multiple preview destekler"
              ],
              "questions": [
                {
                  "questionId": 510401,
                  "question": "@Preview annotation'ı ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Uygulamayı başlatır",
                    "Composable'ı Android Studio'da emülatör olmadan görüntüler",
                    "Test yapar",
                    "APK üretir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Preview annotation'ı, Composable'ı Android Studio'da emülatör veya cihaz gerektirmeden görüntülemenizi sağlar.",
                  "tags": ["preview", "tooling"]
                },
                {
                  "questionId": 510402,
                  "question": "@Preview'ın avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece görsel",
                    "Hızlı UI geliştirme, emülatör gerektirmez, multiple preview desteği",
                    "Sadece test için",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Preview, hızlı UI geliştirme sağlar, emülatör gerektirmez, birden fazla preview (dark mode, farklı ekran boyutları) destekler ve interactive preview sunar.",
                  "tags": ["preview", "advantages"]
                },
                {
                  "questionId": 510403,
                  "question": "Aşağıdaki Preview kodu ne gösterir?",
                  "questionType": "multiple_choice",
                  "code": "@Preview(showBackground = true)\n@Composable\nfun GreetingPreview() {\n    Greeting()\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hiçbir şey göstermez",
                    "Greeting Composable'ını beyaz arka plan ile preview'da gösterir",
                    "Sadece kod hata kontrolü yapar",
                    "Emülatörde çalıştırır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, Greeting Composable'ını Android Studio'nun preview panelinde showBackground = true ile beyaz arka plan üzerinde gösterir.",
                  "tags": ["preview", "example", "showbackground"]
                }
              ]
            },
            {
              "topicId": 5105,
              "title": "Temel UI Elementleri (Text, Button, Image)",
              "summary": "Compose'da Text, Button, Image gibi temel UI bileşenleri Composable fonksiyonlar olarak sunulur.",
              "content": "## Temel UI Elementleri\n\nText: Metin gösterir\nButton: Tıklanabilir buton\nImage: Resim gösterir\n\nHer biri özelleştirilebilir Composable'dır.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Temel Bileşenler",
                  "code": "@Composable\nfun BasicUI() {\n    Text(text = \"Merhaba\")\n    Button(onClick = { }) { Text(\"Tıkla\") }\n    Image(painter = painterResource(R.drawable.logo))\n}",
                  "explanation": "Temel UI bileşenleri kullanımı."
                }
              ],
              "keyPoints": [
                "Text metin gösterir",
                "Button tıklama alır",
                "Image resim gösterir",
                "Hepsi Composable fonksiyondur"
              ],
              "questions": [
                {
                  "questionId": 510501,
                  "question": "Compose'da metin göstermek için hangi Composable kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "TextView",
                    "Text",
                    "Label",
                    "String"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose'da metin göstermek için Text Composable kullanılır. XML'deki TextView'ın karşılığıdır.",
                  "tags": ["text", "ui", "composable"]
                },
                {
                  "questionId": 510502,
                  "question": "Compose'da tıklanabilir buton oluşturmak için hangi Composable kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "ClickButton",
                    "Button",
                    "Clickable",
                    "TouchButton"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose'da Button Composable kullanılır. onClick parametresi ile tıklama işlemi yönetilir.",
                  "tags": ["button", "ui", "composable"]
                },
                {
                  "questionId": 510503,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "Image(painter = painterResource(R.drawable.logo), contentDescription = \"Logo\")",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "Drawable'dan logo resmini gösterir",
                    "Sadece URL'den resim gösterir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Image Composable, painterResource ile drawable klasöründeki logo resmini gösterir. contentDescription accessibility için önemlidir.",
                  "tags": ["image", "ui", "composable"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 510001,
              "question": "Compose'da Activity'ye UI eklemek için hangi metot kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "setContentView()",
                "setContent { }",
                "addComposable()",
                "composeUI()"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose'da Activity'ye UI eklemek için setContent { } bloğu kullanılır. XML'deki setContentView()'in yerini alır.",
              "tags": ["activity", "setcontent"]
            },
            {
              "questionId": 510002,
              "question": "Compose'un minimum Android API seviyesi nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "API 16",
                "API 21",
                "API 26",
                "API 30"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Jetpack Compose, minimum Android API 21 (Lollipop) gerektirir.",
              "tags": ["compose", "api_level"]
            },
            {
              "questionId": 510003,
              "question": "Compose'da UI güncellenmesi nasıl olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "findViewById ve setText ile",
                "State değiştiğinde otomatik recomposition ile",
                "Manuel refresh çağrısı ile",
                "Activity yeniden başlatılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose'da state değiştiğinde UI otomatik olarak güncellenir (recomposition). Manuel güncelleme gerekmez, bu declarative yaklaşımın temelidir.",
              "tags": ["compose", "recomposition", "state"]
            },
            {
              "questionId": 510004,
              "question": "Compose projesi oluştururken hangi bağımlılık eklenir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "androidx.appcompat",
                "androidx.compose.ui:ui",
                "androidx.legacy",
                "com.android.compose"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose projesi için androidx.compose.ui:ui, androidx.compose.material3:material3 gibi Compose bağımlılıkları eklenir.",
              "tags": ["compose", "dependency", "setup"]
            },
            {
              "questionId": 510005,
              "question": "Composable fonksiyonlar kaç kez çağrılabilir (recompose edilebilir)?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece 1 kez",
                "Herhangi bir sayıda, state değiştiğinde veya parent recompose olduğunda",
                "En fazla 2 kez",
                "Hiç çağrılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Composable fonksiyonlar herhangi bir sayıda recompose edilebilir. State değiştiğinde, parent recompose olduğunda veya başka nedenlerle tekrar çağrılabilir. Bu nedenle side-effect'siz olmalıdır.",
              "tags": ["composable", "recomposition"]
            },
            {
              "questionId": 510006,
              "question": "Compose'da findViewById kullanılır mı?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Evet, her zaman",
                "Hayır, Compose'da ID ve findViewById yoktur",
                "Sadece test için",
                "Sadece Activity'de"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose'da findViewById kullanılmaz. XML'deki ID kavramı yoktur. UI'a doğrudan state ile erişilir, declarative yaklaşım kullanılır.",
              "tags": ["compose", "findviewbyid"]
            },
            {
              "questionId": 510007,
              "question": "@Preview ile cihazda çalışan kodu test edebilir miyiz?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, tam test",
                "Hayır, sadece UI görünümü, logic çalışmaz (ViewModel vb.)",
                "Her şeyi test eder",
                "Preview sadece layout içindir"
              ],
              "correctAnswerIndex": 1,
              "explanation": "@Preview sadece UI görünümünü gösterir. ViewModel, network, database gibi logic'ler çalışmaz. Interactive preview ile basit tıklama test edilebilir ama tam test değildir.",
              "tags": ["preview", "testing"]
            },
            {
              "questionId": 510008,
              "question": "Compose'da contentDescription neden önemlidir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece görsel",
                "Accessibility (erişilebilirlik) için, screen reader'lar içeriği okur",
                "Performans için",
                "Hiçbir önemi yok"
              ],
              "correctAnswerIndex": 1,
              "explanation": "contentDescription, accessibility (erişilebilirlik) için kritiktir. Screen reader'lar (TalkBack) bu açıklamayı okur. Image gibi görsel bileşenlerde mutlaka kullanılmalıdır.",
              "tags": ["accessibility", "contentdescription"]
            },
            {
              "questionId": 510009,
              "question": "Compose XML'i tamamen değiştirir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, XML artık hiç kullanılamaz",
                "Hayır, Compose ve XML birlikte kullanılabilir (interoperability)",
                "Sadece yeni projelerde",
                "XML daha iyi"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose ve XML birlikte kullanılabilir (interoperability). ComposeView ile XML'de Compose, AndroidView ile Compose'da XML kullanılabilir. Migration aşamalı yapılabilir.",
              "tags": ["compose", "xml", "interoperability"]
            },
            {
              "questionId": 510010,
              "question": "Compose'un stable sürümü ne zaman yayınlandı?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "2019",
                "2021 (1.0.0)",
                "2022",
                "Henüz stable değil"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Jetpack Compose'un ilk stable sürümü (1.0.0) Temmuz 2021'de yayınlandı. Production kullanımı için hazırdır.",
              "tags": ["compose", "history", "stable"]
            }
          ]
        },
        {
          "sectionId": 5200,
          "sectionTitle": "Layout & UI Components",
          "sectionDescription": "Compose'da layout düzenleme, Modifier kullanımı ve temel UI bileşenleri",
          "order": 2,
          "topics": [
            {
              "topicId": 5201,
              "title": "Row, Column, Box",
              "summary": "Row, Column ve Box, Compose'un temel layout bileşenleridir. XML'deki LinearLayout ve FrameLayout'a benzer işlevlere sahiptir.",
              "content": "## Layout Bileşenleri\n\nRow: Yatay dizilim\nColumn: Dikey dizilim\nBox: Üst üste bindirme\n\nBunlar Compose'un temel layout building block'larıdır.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Row, Column, Box Kullanımı",
                  "code": "Row { Text(\"A\"); Text(\"B\") } // Yatay\nColumn { Text(\"A\"); Text(\"B\") } // Dikey\nBox { Text(\"Üstte\"); Text(\"Altta\") } // Üst üste",
                  "explanation": "Temel layout bileşenleri."
                }
              ],
              "keyPoints": [
                "Row yatay dizilim sağlar",
                "Column dikey dizilim sağlar",
                "Box üst üste bindirme sağlar",
                "LinearLayout ve FrameLayout alternatifi"
              ],
              "questions": [
                {
                  "questionId": 520101,
                  "question": "Row Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Dikey dizilim",
                    "Yatay dizilim (horizontal)",
                    "Üst üste bindirme",
                    "Grid yapısı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Row, child Composable'ları yatay (horizontal) olarak yan yana dizer.",
                  "tags": ["row", "layout"]
                },
                {
                  "questionId": 520102,
                  "question": "Column Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Yatay dizilim",
                    "Dikey dizilim (vertical)",
                    "Üst üste bindirme",
                    "Grid yapısı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Column, child Composable'ları dikey (vertical) olarak alt alta dizer.",
                  "tags": ["column", "layout"]
                },
                {
                  "questionId": 520103,
                  "question": "Box Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Yatay dizilim",
                    "Dikey dizilim",
                    "Üst üste bindirme (stack/overlay)",
                    "Tek child"
                  ],
                  "correctAnswerIndex": 2,
                  "explanation": "Box, child Composable'ları üst üste bindirir (z-index mantığı). XML'deki FrameLayout'a benzer.",
                  "tags": ["box", "layout"]
                },
                {
                  "questionId": 520104,
                  "question": "Row'un XML'deki karşılığı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "FrameLayout",
                    "LinearLayout (horizontal)",
                    "RelativeLayout",
                    "ConstraintLayout"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Row, XML'deki LinearLayout (android:orientation=\"horizontal\") ile aynı işlevi görür.",
                  "tags": ["row", "xml", "comparison"]
                },
                {
                  "questionId": 520105,
                  "question": "Aşağıdaki kod nasıl bir layout oluşturur?",
                  "questionType": "multiple_choice",
                  "code": "Row {\n    Text(\"A\")\n    Text(\"B\")\n    Text(\"C\")\n}",
                  "difficulty": "easy",
                  "options": [
                    "Dikey: A, B, C",
                    "Yatay: A B C",
                    "Üst üste: A=B=C",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Row yatay dizilim yaptığı için Text'ler yan yana (A B C) görünür.",
                  "tags": ["row", "example"]
                }
              ]
            },
            {
              "topicId": 5202,
              "title": "Modifier",
              "summary": "Modifier, Composable'ların boyut, padding, background, tıklama gibi özelliklerini değiştirmek için kullanılır.",
              "content": "## Modifier\n\nModifier, Composable'ları özelleştirmek için kullanılır.\n\nChain (zincir) yapısı ile birden fazla modifier uygulanabilir.\n\nSıralama önemlidir.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Modifier Kullanımı",
                  "code": "Text(\n    text = \"Merhaba\",\n    modifier = Modifier\n        .padding(16.dp)\n        .background(Color.Blue)\n        .size(100.dp)\n)",
                  "explanation": "Modifier ile padding, background ve size ekleme."
                }
              ],
              "keyPoints": [
                "Composable özelliklerini değiştirir",
                "Chain yapısı destekler",
                "Sıralama çok önemlidir",
                "padding, size, background gibi birçok modifier var"
              ],
              "questions": [
                {
                  "questionId": 520201,
                  "question": "Modifier ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece renk değiştirir",
                    "Composable'ların boyut, padding, background gibi özelliklerini değiştirir",
                    "Sadece layout için",
                    "Hiçbir işe yaramaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier, Composable'ların boyut, padding, background, tıklama, alignment gibi birçok özelliğini değiştirmek için kullanılır.",
                  "tags": ["modifier", "temel"]
                },
                {
                  "questionId": 520202,
                  "question": "Modifier chain (zincir) yapısı ne demektir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Tek modifier kullanılır",
                    "Birden fazla modifier arka arkaya (.) ile eklenebilir",
                    "Sadece 2 modifier",
                    "Modifier zincirlenemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier chain, birden fazla modifier'ın arka arkaya (.) ile eklenmesidir. Örnek: Modifier.padding(16.dp).background(Color.Blue).size(100.dp)",
                  "tags": ["modifier", "chain"]
                },
                {
                  "questionId": 520203,
                  "question": "Modifier sıralaması neden önemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiç önemli değil",
                    "Modifier'lar soldan sağa uygulanır, sıralama sonucu değiştirir",
                    "Sadece performans için",
                    "Her zaman aynı sonuç"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier sıralaması çok önemlidir. Soldan sağa uygulanır. Örneğin padding sonra background farklı, background sonra padding farklı sonuç verir.",
                  "tags": ["modifier", "order", "chain"]
                },
                {
                  "questionId": 520204,
                  "question": "Modifier.padding(16.dp) ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Margin ekler",
                    "İç boşluk (padding) ekler",
                    "Boyut değiştirir",
                    "Background ekler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier.padding(), Composable'ın iç boşluğunu (padding) ekler. Her yönden (top, bottom, left, right) 16.dp boşluk.",
                  "tags": ["modifier", "padding"]
                },
                {
                  "questionId": 520205,
                  "question": "Aşağıdaki modifier chain'de hangi sıralama doğrudur?",
                  "questionType": "multiple_choice",
                  "code": "Modifier.padding(16.dp).background(Color.Blue)",
                  "difficulty": "medium",
                  "options": [
                    "Önce background, sonra padding",
                    "Önce padding, sonra background (padding'li alanın tamamı mavi)",
                    "Aynı anda uygulanır",
                    "Sıralama fark etmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier'lar soldan sağa uygulanır. Önce 16.dp padding eklenir, sonra background uygulanır. Bu nedenle padding'li alanın tamamı mavi olur.",
                  "tags": ["modifier", "order", "example"]
                }
              ]
            },
            {
              "topicId": 5203,
              "title": "LazyColumn & LazyRow",
              "summary": "LazyColumn ve LazyRow, RecyclerView'ın Compose karşılığıdır. Büyük listeleri performanslı şekilde gösterir.",
              "content": "## LazyColumn & LazyRow\n\nLazyColumn: Dikey scroll liste\nLazyRow: Yatay scroll liste\n\nSadece görünen item'lar render edilir (lazy loading).",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "LazyColumn Örneği",
                  "code": "LazyColumn {\n    items(100) { index ->\n        Text(\"Item $index\")\n    }\n}",
                  "explanation": "100 item'lık scroll edilebilir liste."
                }
              ],
              "keyPoints": [
                "RecyclerView alternatifi",
                "Lazy loading (sadece görünenler)",
                "Performanslı liste gösterimi",
                "items() ile liste oluşturulur"
              ],
              "questions": [
                {
                  "questionId": 520301,
                  "question": "LazyColumn ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Yatay scroll liste",
                    "Dikey scroll liste (RecyclerView gibi)",
                    "Üst üste bindirme",
                    "Static liste"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LazyColumn, dikey scroll edilebilir liste oluşturur. XML'deki RecyclerView'ın Compose karşılığıdır.",
                  "tags": ["lazycolumn", "list"]
                },
                {
                  "questionId": 520302,
                  "question": "LazyColumn'un 'Lazy' olması ne anlama gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Yavaş çalışır",
                    "Sadece görünen item'lar render edilir (lazy loading)",
                    "Tüm item'lar başta yüklenir",
                    "Sadece tek item gösterir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Lazy loading: Sadece ekranda görünen item'lar render edilir. Scroll ettikçe yeni item'lar yüklenir, görünmeyenler bellekten temizlenir. Bu, performans optimizasyonudur.",
                  "tags": ["lazycolumn", "lazy_loading", "performance"]
                },
                {
                  "questionId": 520303,
                  "question": "LazyColumn ve Column arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir fark yok",
                    "LazyColumn lazy loading yapar (scroll), Column tüm child'ları render eder",
                    "Column daha performanslı",
                    "LazyColumn kullanımdan kalkmış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LazyColumn lazy loading yapar, sadece görünen item'lar render edilir ve scroll desteği vardır. Column ise tüm child'ları baştan render eder, büyük listelerde performans sorunu yaratır.",
                  "tags": ["lazycolumn", "column", "difference"]
                },
                {
                  "questionId": 520304,
                  "question": "LazyRow ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Dikey scroll liste",
                    "Yatay scroll liste (horizontal RecyclerView gibi)",
                    "Grid yapısı",
                    "Static yatay liste"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LazyRow, yatay scroll edilebilir liste oluşturur. Horizontal RecyclerView'ın Compose karşılığıdır.",
                  "tags": ["lazyrow", "list"]
                },
                {
                  "questionId": 520305,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "LazyColumn {\n    items(100) { index ->\n        Text(\"Item $index\")\n    }\n}",
                  "difficulty": "easy",
                  "options": [
                    "100 adet yatay item",
                    "100 adet dikey scroll edilebilir item (Item 0, Item 1, ...)",
                    "Sadece 1 item",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "items(100) ile 100 adet item oluşturulur. Her item'da \"Item 0\", \"Item 1\" ... \"Item 99\" metni gösterilir. Dikey scroll edilebilir.",
                  "tags": ["lazycolumn", "items", "example"]
                }
              ]
            },
            {
              "topicId": 5204,
              "title": "Spacer & Divider",
              "summary": "Spacer boşluk eklemek, Divider ise ayırıcı çizgi eklemek için kullanılır.",
              "content": "## Spacer & Divider\n\nSpacer: Boşluk ekler\nDivider: Ayırıcı çizgi ekler\n\nLayout düzenlemede sık kullanılır.",
              "difficulty": "easy",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Spacer ve Divider",
                  "code": "Column {\n    Text(\"Başlık\")\n    Spacer(modifier = Modifier.height(16.dp))\n    Divider()\n    Text(\"İçerik\")\n}",
                  "explanation": "Spacer ile boşluk, Divider ile ayırıcı çizgi."
                }
              ],
              "keyPoints": [
                "Spacer boşluk ekler",
                "Divider ayırıcı çizgi ekler",
                "Layout düzenlemede kullanılır",
                "Material Design'a uygun"
              ],
              "questions": [
                {
                  "questionId": 520401,
                  "question": "Spacer Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Ayırıcı çizgi ekler",
                    "Boşluk (space) ekler",
                    "Text gösterir",
                    "Button oluşturur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Spacer, layout'ta boşluk eklemek için kullanılır. Modifier ile height veya width verilebilir.",
                  "tags": ["spacer", "layout"]
                },
                {
                  "questionId": 520402,
                  "question": "Divider Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Boşluk ekler",
                    "Ayırıcı çizgi ekler",
                    "Text gösterir",
                    "Border ekler"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Divider, Material Design'a uygun ayırıcı çizgi (separator line) ekler. Genellikle liste item'ları arasında kullanılır.",
                  "tags": ["divider", "layout"]
                },
                {
                  "questionId": 520403,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "Spacer(modifier = Modifier.height(16.dp))",
                  "difficulty": "easy",
                  "options": [
                    "16.dp genişlik",
                    "16.dp yükseklik boşluk ekler",
                    "Ayırıcı çizgi ekler",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Spacer ile Modifier.height(16.dp) kullanılarak 16.dp yüksekliğinde dikey boşluk eklenir.",
                  "tags": ["spacer", "height", "example"]
                }
              ]
            },
            {
              "topicId": 5205,
              "title": "Surface & Card",
              "summary": "Surface ve Card, Material Design öğeleridir. Elevation (gölge) ve shape (şekil) özelliklerine sahiptir.",
              "content": "## Surface & Card\n\nSurface: Temel Material container\nCard: Elevation ve rounded corner ile container\n\nMaterial Design prensipleri sağlar.",
              "difficulty": "easy",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Card Örneği",
                  "code": "Card(\n    modifier = Modifier.padding(16.dp),\n    elevation = CardDefaults.cardElevation(4.dp)\n) {\n    Text(\"Card içeriği\")\n}",
                  "explanation": "Elevation ve padding ile Card."
                }
              ],
              "keyPoints": [
                "Material Design container'lar",
                "Elevation (gölge) destekler",
                "Shape özelleştirilebilir",
                "Modern UI için kullanılır"
              ],
              "questions": [
                {
                  "questionId": 520501,
                  "question": "Surface Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece text gösterir",
                    "Material Design container, elevation ve shape desteği",
                    "Sadece liste gösterir",
                    "Navigation yapar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Surface, Material Design'ın temel container'ıdır. Elevation (gölge), shape (şekil), background color gibi özelliklere sahiptir.",
                  "tags": ["surface", "material"]
                },
                {
                  "questionId": 520502,
                  "question": "Card ve Surface arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Card, varsayılan elevation ve rounded corner ile gelen özelleştirilmiş Surface",
                    "Surface daha modern",
                    "Card kullanımdan kalkmış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Card, varsayılan olarak elevation (gölge) ve rounded corner (yuvarlak köşe) ile gelen, özelleştirilmiş bir Surface'tir. Genellikle liste item'ları için kullanılır.",
                  "tags": ["card", "surface", "difference"]
                },
                {
                  "questionId": 520503,
                  "question": "Elevation nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Boyut",
                    "Gölge/Derinlik (Material Design'da z-axis)",
                    "Renk",
                    "Shape"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Elevation, Material Design'da gölge/derinlik anlamına gelir (z-axis). Yüksek elevation daha belirgin gölge verir.",
                  "tags": ["elevation", "material"]
                },
                {
                  "questionId": 520504,
                  "question": "Card genellikle nerede kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece başlık",
                    "Liste item'ları, ürün kartları, içerik grupları",
                    "Sadece buton",
                    "Navigation"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Card, genellikle liste item'ları, ürün kartları, blog post'ları gibi içerik gruplarını görsel olarak ayırmak için kullanılır.",
                  "tags": ["card", "use_case"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 520001,
              "question": "Compose'da ConstraintLayout kullanılabilir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hayır, sadece Row/Column/Box",
                "Evet, ConstraintLayout Compose kütüphanesi var",
                "Sadece XML'de",
                "Kullanımdan kalkmış"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose'da ConstraintLayout kullanılabilir (androidx.constraintlayout:constraintlayout-compose). Ancak çoğu durumda Row/Column/Box yeterlidir.",
              "tags": ["constraintlayout", "compose"]
            },
            {
              "questionId": 520002,
              "question": "Modifier.fillMaxWidth() ne yapar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Yüksekliği doldurur",
                "Genişliği parent'ın tamamına yayar (match_parent gibi)",
                "Sadece 50% genişlik",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.fillMaxWidth(), Composable'ın genişliğini parent'ın tamamına yayar. XML'deki match_parent (width) ile aynıdır.",
              "tags": ["modifier", "fillmaxwidth"]
            },
            {
              "questionId": 520003,
              "question": "Modifier.fillMaxSize() ne yapar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Sadece genişlik",
                "Hem genişlik hem yüksekliği parent'a yayar",
                "Sadece yükseklik",
                "Minimum boyut"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.fillMaxSize(), Composable'ı hem genişlik hem yükseklikte parent'ın tamamına yayar. XML'deki match_parent (width + height) ile aynıdır.",
              "tags": ["modifier", "fillmaxsize"]
            },
            {
              "questionId": 520004,
              "question": "LazyColumn'da key parametresi neden kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece görsel",
                "Recomposition optimizasyonu, item'ları unique tanımlar",
                "Zorunlu parametre",
                "Hiçbir işe yaramaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "key parametresi, her item'ı unique tanımlayarak recomposition optimizasyonu sağlar. Liste değiştiğinde hangi item'ların değiştiği/eklendiği/silindiği daha verimli tespit edilir.",
              "tags": ["lazycolumn", "key", "optimization"]
            },
            {
              "questionId": 520005,
              "question": "Arrangement nedir (Row/Column'da)?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece renk",
                "Child'ların nasıl dizileceğini belirler (SpaceBetween, Center vb.)",
                "Sadece boyut",
                "Background"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Arrangement, Row/Column içinde child'ların nasıl dizileceğini belirler. SpaceBetween (aralarında eşit boşluk), Center (ortala), SpaceAround, SpaceEvenly gibi seçenekler vardır.",
              "tags": ["arrangement", "row", "column"]
            },
            {
              "questionId": 520006,
              "question": "Alignment nedir (Row/Column/Box'ta)?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece renk",
                "Child'ların hizalamasını belirler (Start, End, Center, Top, Bottom)",
                "Sadece boyut",
                "Background"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Alignment, child'ların hizalamasını belirler. Row'da verticalAlignment (Top, CenterVertically, Bottom), Column'da horizontalAlignment (Start, CenterHorizontally, End), Box'ta contentAlignment kullanılır.",
              "tags": ["alignment", "row", "column", "box"]
            },
            {
              "questionId": 520007,
              "question": "Modifier.clickable() ne yapar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Sadece görsel efekt",
                "Composable'ı tıklanabilir yapar, onClick lambda alır",
                "Sadece animasyon",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.clickable(), Composable'ı tıklanabilir yapar. onClick lambda ile tıklama işlemi yönetilir. Ripple effect otomatik eklenir.",
              "tags": ["modifier", "clickable"]
            },
            {
              "questionId": 520008,
              "question": "LazyColumn'da 1000 item varsa ne kadar item render edilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Hepsi (1000)",
                "Sadece ekranda görünen item'lar + buffer",
                "İlk 100",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "LazyColumn lazy loading yapar. Sadece ekranda görünen item'lar + küçük bir buffer render edilir. Bu, 1000 item olsa bile performans sounu yaratmaz.",
              "tags": ["lazycolumn", "lazy_loading", "performance"]
            },
            {
              "questionId": 520009,
              "question": "Modifier.weight() ne işe yarar (Row/Column'da)?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece ağırlık belirler",
                "Available space'i child'lar arasında ağırlıklı böler (LinearLayout weight gibi)",
                "Sadece boyut",
                "Kullanılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.weight(), Row/Column içinde available space'i child'lar arasında ağırlıklı böler. XML'deki LinearLayout weight özelliği ile aynıdır.",
              "tags": ["modifier", "weight", "row", "column"]
            },
            {
              "questionId": 520010,
              "question": "Compose'da ScrollView'ın karşılığı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "ScrollColumn",
                "Column + Modifier.verticalScroll() veya LazyColumn",
                "Sadece LazyColumn",
                "ScrollView kullanılır"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose'da Column + Modifier.verticalScroll() kullanılır (az item için). Çok item için performanslı LazyColumn tercih edilir.",
              "tags": ["scroll", "column", "lazycolumn"]
            }
          ]
        },
        {
          "sectionId": 5300,
          "sectionTitle": "State Management",
          "sectionDescription": "Compose'da state yönetimi, recomposition ve side effect'ler",
          "order": 3,
          "topics": [
            {
              "topicId": 5301,
              "title": "Remember & MutableStateOf",
              "summary": "remember ve mutableStateOf, Compose'da state oluşturmak ve saklamak için kullanılır. State değiştiğinde UI otomatik güncellenir.",
              "content": "## remember & mutableStateOf\n\nremember: State'i recomposition'lar arasında saklar\nmutableStateOf: Değiştirilebilir state oluşturur\n\nState değişince UI otomatik recompose olur.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "remember ve mutableStateOf",
                  "code": "@Composable\nfun Counter() {\n    var count by remember { mutableStateOf(0) }\n    Button(onClick = { count++ }) {\n        Text(\"Count: $count\")\n    }\n}",
                  "explanation": "Her tıklamada count artar ve UI güncellenir."
                }
              ],
              "keyPoints": [
                "remember recomposition'da state'i korur",
                "mutableStateOf değiştirilebilir state",
                "State değişince recomposition tetiklenir",
                "by delegate kullanılabilir"
              ],
              "questions": [
                {
                  "questionId": 530101,
                  "question": "remember ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece değişken oluşturur",
                    "State'i recomposition'lar arasında saklar",
                    "Sadece performans için",
                    "Hiçbir işe yaramaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "remember, state'i recomposition'lar arasında saklar. remember olmazsa her recomposition'da state sıfırlanır.",
                  "tags": ["remember", "state"]
                },
                {
                  "questionId": 530102,
                  "question": "mutableStateOf ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece okuma için state",
                    "Değiştirilebilir (mutable) state oluşturur",
                    "Sadece String için",
                    "Kullanımdan kalkmış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "mutableStateOf, değiştirilebilir (mutable) state oluşturur. State değiştiğinde Compose otomatik olarak recomposition tetikler.",
                  "tags": ["mutablestateof", "state"]
                },
                {
                  "questionId": 530103,
                  "question": "State değiştiğinde ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir şey olmaz",
                    "UI otomatik olarak recompose olur (yeniden çizilir)",
                    "Sadece log yazılır",
                    "Activity yeniden başlar"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "State değiştiğinde Compose, o state'i kullanan Composable'ları otomatik olarak recompose eder (yeniden çizer). Bu, declarative UI'ın temelidir.",
                  "tags": ["state", "recomposition"]
                },
                {
                  "questionId": 530104,
                  "question": "by delegate kullanmanın avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir avantajı yok",
                    "State'e .value yazmadan direkt erişim sağlar",
                    "Sadece hız artışı",
                    "Zorunludur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "by delegate kullanarak state'e .value yazmadan direkt erişebilirsiniz. var count by remember { mutableStateOf(0) } → count++ (count.value++ yerine)",
                  "tags": ["by", "delegate", "state"]
                },
                {
                  "questionId": 530105,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "var count by remember { mutableStateOf(0) }\nButton(onClick = { count++ }) {\n    Text(\"Count: $count\")\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "Her tıklamada count artar ve UI güncellenir",
                    "Sadece ilk tıklama",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Her tıklamada count artar (mutableStateOf), remember sayesinde değer korunur ve state değiştiği için UI otomatik recompose olur.",
                  "tags": ["remember", "mutablestateof", "example"]
                }
              ]
            },
            {
              "topicId": 5302,
              "title": "State Hoisting",
              "summary": "State Hoisting, state'i child Composable'dan parent'a taşıyarak Composable'ı stateless ve reusable hale getirir.",
              "content": "## State Hoisting\n\nState'i parent'a taşı, child'a parametre ve callback ver.\n\nComposable stateless ve reusable olur.\n\nUnidirectional data flow sağlar.",
              "difficulty": "hard",
              "order": 2,
              "codeExamples": [
                {
                  "title": "State Hoisting Örneği",
                  "code": "@Composable\nfun Counter(count: Int, onIncrement: () -> Unit) {\n    Button(onClick = onIncrement) {\n        Text(\"Count: $count\")\n    }\n}",
                  "explanation": "State parent'ta, child stateless."
                }
              ],
              "keyPoints": [
                "State'i parent'a taşır",
                "Child stateless olur",
                "Reusability artar",
                "Single source of truth"
              ],
              "questions": [
                {
                  "questionId": 530201,
                  "question": "State Hoisting nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "State'i silme",
                    "State'i child'dan parent'a taşıma",
                    "State'i database'e kaydetme",
                    "State oluşturma"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "State Hoisting, state'i child Composable'dan parent'a taşıyarak child'ı stateless ve reusable hale getirmektir.",
                  "tags": ["state_hoisting", "pattern"]
                },
                {
                  "questionId": 530202,
                  "question": "State Hoisting'in amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece performans",
                    "Composable'ı stateless, reusable ve testable yapmak",
                    "Sadece görsel",
                    "Hiçbir amacı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "State Hoisting'in amacı: Composable'ı stateless (kendi state'i yok), reusable (farklı yerlerde kullanılabilir) ve testable (test kolay) yapmaktır.",
                  "tags": ["state_hoisting", "benefits"]
                },
                {
                  "questionId": 530203,
                  "question": "State Hoisting'de child Composable ne alır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir şey almaz",
                    "State değeri (parametre) ve state değiştirme callback'i",
                    "Sadece state değeri",
                    "Sadece callback"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "State Hoisting'de child, state değerini parametre olarak alır ve state'i değiştirmek için callback (lambda) alır. Böylece stateless olur.",
                  "tags": ["state_hoisting", "parameters"]
                },
                {
                  "questionId": 530204,
                  "question": "Unidirectional Data Flow nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Çift yönlü data akışı",
                    "Tek yönlü veri akışı: State aşağı (↓), Event yukarı (↑)",
                    "Sadece event akışı",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Unidirectional Data Flow: State parent'tan child'a aşağı iner (↓), event (tıklama vb.) child'dan parent'a yukarı çıkar (↑). Bu, State Hoisting'in sağladığı pattern'dir.",
                  "tags": ["state_hoisting", "udf", "pattern"]
                },
                {
                  "questionId": 530205,
                  "question": "Aşağıdaki Counter stateless mi?",
                  "questionType": "multiple_choice",
                  "code": "@Composable\nfun Counter(count: Int, onIncrement: () -> Unit) {\n    Button(onClick = onIncrement) {\n        Text(\"Count: $count\")\n    }\n}",
                  "difficulty": "medium",
                  "options": [
                    "Hayır, stateful",
                    "Evet, stateless (state dışarıdan geliyor)",
                    "Belirsiz",
                    "Hatalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu Counter stateless'tir çünkü kendi state'i yok. count ve onIncrement parametre olarak geliyor. State parent'ta yönetilir.",
                  "tags": ["state_hoisting", "stateless", "example"]
                }
              ]
            },
            {
              "topicId": 5303,
              "title": "rememberSaveable",
              "summary": "rememberSaveable, state'i configuration change'lerde (ekran döndürme) korur. remember'dan farkı budur.",
              "content": "## rememberSaveable\n\nConfiguration change'lerde state'i korur.\n\nremember ekran döndürmede state'i kaybeder.\n\nrememberSaveable Bundle'a kaydeder.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "rememberSaveable Kullanımı",
                  "code": "var text by rememberSaveable { mutableStateOf(\"\") }\nTextField(value = text, onValueChange = { text = it })",
                  "explanation": "Ekran döndürmede text korunur."
                }
              ],
              "keyPoints": [
                "Configuration change'lerde korur",
                "remember'dan daha güçlü",
                "Bundle'a kaydeder",
                "Parcelable/Serializable destekler"
              ],
              "questions": [
                {
                  "questionId": 530301,
                  "question": "rememberSaveable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "remember ile aynı",
                    "Configuration change'lerde (ekran döndürme) state'i korur",
                    "Sadece performans için",
                    "Database'e kaydeder"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "rememberSaveable, configuration change'lerde (ekran döndürme, dil değiştirme) state'i korur. remember ekran döndürmede state'i kaybeder.",
                  "tags": ["remembersaveable", "configuration"]
                },
                {
                  "questionId": 530302,
                  "question": "remember ve rememberSaveable arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir fark yok",
                    "rememberSaveable configuration change'lerde korur, remember korumaz",
                    "remember daha güçlü",
                    "rememberSaveable kullanımdan kalkmış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "remember sadece recomposition'da korur, configuration change'de kaybolur. rememberSaveable Bundle'a kaydederek configuration change'lerde de korur.",
                  "tags": ["remember", "remembersaveable", "difference"]
                },
                {
                  "questionId": 530303,
                  "question": "rememberSaveable nasıl çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Memory'de tutar",
                    "Bundle'a kaydeder (Activity'nin onSaveInstanceState gibi)",
                    "Database'e kaydeder",
                    "SharedPreferences'a kaydeder"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "rememberSaveable, state'i Bundle'a kaydeder (Activity'nin onSaveInstanceState mekanizması gibi). Bu nedenle Parcelable/Serializable tiplerle çalışır.",
                  "tags": ["remembersaveable", "bundle"]
                },
                {
                  "questionId": 530304,
                  "question": "TextField gibi user input için hangi remember tercih edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "remember",
                    "rememberSaveable (ekran döndürmede kullanıcı girdisi kaybolmamalı)",
                    "Fark etmez",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "TextField gibi user input için rememberSaveable tercih edilir. Böylece ekran döndürüldüğünde kullanıcının yazdığı text kaybolmaz.",
                  "tags": ["remembersaveable", "textfield", "use_case"]
                }
              ]
            },
            {
              "topicId": 5304,
              "title": "derivedStateOf",
              "summary": "derivedStateOf, başka state'lerden türetilen state oluşturur ve gereksiz recomposition'ları önler.",
              "content": "## derivedStateOf\n\nBaşka state'lerden türetilen state.\n\nGereksiz recomposition önler.\n\nHesaplama sonucu state için kullanılır.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "derivedStateOf Örneği",
                  "code": "val listState = rememberLazyListState()\nval showButton by remember {\n    derivedStateOf { listState.firstVisibleItemIndex > 0 }\n}",
                  "explanation": "Scroll durumuna göre türetilen state."
                }
              ],
              "keyPoints": [
                "Türetilmiş state oluşturur",
                "Performance optimizasyonu",
                "Gereksiz recomposition önler",
                "Hesaplama sonucu için ideal"
              ],
              "questions": [
                {
                  "questionId": 530401,
                  "question": "derivedStateOf ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Yeni state oluşturur",
                    "Başka state'lerden türetilen state oluşturur, gereksiz recomposition önler",
                    "State'i siler",
                    "Sadece performans ölçer"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "derivedStateOf, başka state'lerden türetilen (derived) state oluşturur ve gereksiz recomposition'ları önleyerek performans optimizasyonu sağlar.",
                  "tags": ["derivedstateof", "optimization"]
                },
                {
                  "questionId": 530402,
                  "question": "derivedStateOf neden kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece görsel",
                    "Hesaplama sonucu state için, gereksiz recomposition önlemek",
                    "Her zaman kullanılmalı",
                    "Hiçbir nedeni yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "derivedStateOf, hesaplama sonucu (derived) state için kullanılır. Sadece sonuç değiştiğinde recomposition tetikler, ara hesaplamalar recomposition tetiklemez.",
                  "tags": ["derivedstateof", "use_case"]
                },
                {
                  "questionId": 530403,
                  "question": "derivedStateOf performans optimizasyonunu nasıl sağlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece hız artışı",
                    "Sadece sonuç değiştiğinde recomposition tetikler, ara değişiklikler tetiklemez",
                    "Tüm recomposition'ı engeller",
                    "Hiçbir optimizasyon sağlamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "derivedStateOf, sadece türetilmiş state'in sonucu değiştiğinde recomposition tetikler. Kaynak state'ler değişse bile sonuç aynıysa recomposition olmaz.",
                  "tags": ["derivedstateof", "performance"]
                },
                {
                  "questionId": 530404,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val listState = rememberLazyListState()\nval showButton by remember {\n    derivedStateOf { listState.firstVisibleItemIndex > 0 }\n}",
                  "difficulty": "hard",
                  "options": [
                    "Hata verir",
                    "Scroll durumuna göre showButton state'ini türetir",
                    "Sadece ilk item'ı gösterir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, LazyList scroll durumuna göre showButton state'ini türetir. firstVisibleItemIndex 0'dan büyükse (scroll yapıldıysa) true, değilse false döner.",
                  "tags": ["derivedstateof", "example", "scroll"]
                }
              ]
            },
            {
              "topicId": 5305,
              "title": "Side Effects (LaunchedEffect, DisposableEffect)",
              "summary": "Side effect'ler, Composable dışındaki dünyayla (API, database) etkileşim için kullanılır. LaunchedEffect, DisposableEffect gibi API'lar vardır.",
              "content": "## Side Effects\n\nLaunchedEffect: Coroutine başlatır\nDisposableEffect: Cleanup gerektiğinde\nSideEffect: Her recomposition'da\n\nComposable'ın dış dünya ile etkileşimi.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "LaunchedEffect Örneği",
                  "code": "LaunchedEffect(key1 = userId) {\n    val user = repository.getUser(userId)\n    // state güncelle\n}",
                  "explanation": "userId değişince API çağrısı."
                }
              ],
              "keyPoints": [
                "Dış dünya ile etkileşim",
                "LaunchedEffect coroutine başlatır",
                "DisposableEffect cleanup için",
                "Key değişince yeniden çalışır"
              ],
              "questions": [
                {
                  "questionId": 530501,
                  "question": "Side Effect nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece UI çizme",
                    "Composable dışındaki dünya ile etkileşim (API, database, analytics)",
                    "State oluşturma",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Side Effect, Composable dışındaki dünya ile etkileşimdir: API çağrısı, database işlemi, analytics event gönderme, timer başlatma vb.",
                  "tags": ["side_effect", "temel"]
                },
                {
                  "questionId": 530502,
                  "question": "LaunchedEffect ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece state oluşturur",
                    "Coroutine başlatır, key değişince yeniden çalışır",
                    "Sadece animasyon",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LaunchedEffect, coroutine başlatır ve side effect yapar. key parametresi değiştiğinde önceki coroutine iptal edilir ve yeni coroutine başlatılır.",
                  "tags": ["launchedeffect", "coroutine"]
                },
                {
                  "questionId": 530503,
                  "question": "DisposableEffect ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her zaman",
                    "Cleanup gerektiren side effect'ler için (listener ekleme/çıkarma)",
                    "Sadece API çağrısı",
                    "Kullanılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "DisposableEffect, cleanup gerektiren side effect'ler için kullanılır: listener ekleme/çıkarma, subscription başlatma/durdurma. onDispose bloğunda cleanup yapılır.",
                  "tags": ["disposableeffect", "cleanup"]
                },
                {
                  "questionId": 530504,
                  "question": "LaunchedEffect'te key parametresi neden önemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece görsel",
                    "key değişince önceki coroutine iptal edilip yeni başlatılır",
                    "Zorunlu değil",
                    "Sadece performans"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "key parametresi, LaunchedEffect'in ne zaman yeniden çalışacağını belirler. key değişince önceki coroutine iptal edilir ve yeni coroutine başlatılır. key = Unit ise sadece bir kez çalışır.",
                  "tags": ["launchedeffect", "key"]
                },
                {
                  "questionId": 530505,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "LaunchedEffect(key1 = userId) {\n    val user = repository.getUser(userId)\n    // state güncelle\n}",
                  "difficulty": "medium",
                  "options": [
                    "Hata verir",
                    "userId değiştiğinde API çağrısı yapar",
                    "Sadece ilk render'da çalışır",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "userId key olduğu için, userId değiştiğinde LaunchedEffect yeniden çalışır ve yeni user bilgisi fetch edilir. userId aynı kalırsa tekrar çalışmaz.",
                  "tags": ["launchedeffect", "example", "api"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 530001,
              "question": "Recomposition nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "İlk composition",
                "State değiştiğinde Composable'ın yeniden çizilmesi",
                "Activity yeniden başlatma",
                "Layout inflation"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Recomposition, state değiştiğinde Compose'un o state'i kullanan Composable'ları yeniden çizmesidir. Declarative UI'ın temelidir.",
              "tags": ["recomposition", "state"]
            },
            {
              "questionId": 530002,
              "question": "Smart recomposition nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Tüm UI yeniden çizilir",
                "Sadece değişen state'i kullanan Composable'lar recompose olur",
                "Hiçbir şey recompose olmaz",
                "Sadece parent recompose olur"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Smart recomposition: Compose, sadece değişen state'i kullanan Composable'ları recompose eder. Tüm UI yeniden çizilmez, bu performans optimizasyonudur.",
              "tags": ["recomposition", "smart", "optimization"]
            },
            {
              "questionId": 530003,
              "question": "Single Source of Truth ne demektir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Birden fazla state kopyası",
                "State'in tek bir yerde tutulması (genellikle ViewModel veya parent)",
                "Sadece child'da state",
                "Database"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Single Source of Truth: State'in tek bir yerde (genellikle ViewModel veya parent) tutulması. Birden fazla kopya tutulmaz, bu tutarsızlık önler.",
              "tags": ["ssot", "pattern"]
            },
            {
              "questionId": 530004,
              "question": "SideEffect (not LaunchedEffect, ama SideEffect API) ne zaman kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Coroutine başlatmak için",
                "Her successful recomposition'da çalışması gereken kod için",
                "Cleanup için",
                "Hiçbir zaman"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SideEffect API, her successful recomposition'da çalışması gereken kod için kullanılır. Örneğin, analytics event gönderme. Coroutine başlatmaz, direkt çalışır.",
              "tags": ["sideeffect", "api"]
            },
            {
              "questionId": 530005,
              "question": "produceState ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece state oluşturur",
                "Suspend fonksiyondan State<T> oluşturur (örn: Flow'dan State)",
                "State siler",
                "Kullanılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "produceState, suspend fonksiyon veya Flow'dan State<T> oluşturur. Örneğin, Flow<List<User>>'ı State<List<User>>'a çevirir.",
              "tags": ["producestate", "flow"]
            },
            {
              "questionId": 530006,
              "question": "snapshotFlow ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "State'den Flow oluşturur",
                "State<T>'den Flow<T> oluşturur",
                "Sadece screenshot alır",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "snapshotFlow, State<T>'den Flow<T> oluşturur. State değişikliklerini Flow olarak izlemenizi sağlar.",
              "tags": ["snapshotflow", "flow"]
            },
            {
              "questionId": 530007,
              "question": "remember ile oluşturulan state configuration change'de ne olur?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Korunur",
                "Kaybolur (sıfırlanır)",
                "Database'e kaydedilir",
                "Hiçbir şey olmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "remember ile oluşturulan state, configuration change'de (ekran döndürme) kaybolur. Configuration change'de korumak için rememberSaveable kullanılmalıdır.",
              "tags": ["remember", "configuration"]
            },
            {
              "questionId": 530008,
              "question": "Stateful Composable nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Stateless",
                "Kendi internal state'i olan Composable",
                "State kullanmayan",
                "Hatalı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Stateful Composable, kendi internal state'i olan (remember, mutableStateOf kullanan) Composable'dır. Reusability azalır ama bazı durumlarda uygundur.",
              "tags": ["stateful", "composable"]
            },
            {
              "questionId": 530009,
              "question": "Stateless Composable nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Kendi state'i olan",
                "Kendi state'i olmayan, state dışarıdan parametre olarak alan Composable",
                "State kullanmayan",
                "Hatalı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Stateless Composable, kendi internal state'i olmayan, tüm state'i parametre olarak alan Composable'dır. Reusable ve testable'dır.",
              "tags": ["stateless", "composable"]
            },
            {
              "questionId": 530010,
              "question": "rememberCoroutineScope ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "State oluşturur",
                "Composable'ın lifecycle'ına bağlı CoroutineScope döner",
                "Sadece animasyon",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "rememberCoroutineScope, Composable'ın lifecycle'ına bağlı CoroutineScope döner. onClick gibi event handler'larda coroutine başlatmak için kullanılır (LaunchedEffect composable scope dışında çağrılamaz).",
              "tags": ["remembercoroutinescope", "coroutine"]
            }
          ]
        },
        {
          "sectionId": 5400,
          "sectionTitle": "Navigation",
          "sectionDescription": "Compose'da Navigation Component kullanarak ekranlar arası geçiş yönetimi",
          "order": 4,
          "topics": [
            {
              "topicId": 5401,
              "title": "Navigation Component",
              "summary": "Navigation Component, Compose'da ekranlar arası geçişi yönetmek için kullanılan resmi Jetpack kütüphanesidir.",
              "content": "## Navigation Component\n\nCompose için özel Navigation kütüphanesi vardır.\n\nNavHost ve NavController kullanılır.\n\nType-safe navigation sağlar.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Navigation Setup",
                  "code": "val navController = rememberNavController()\nNavHost(navController, startDestination = \"home\") {\n    composable(\"home\") { HomeScreen() }\n    composable(\"profile\") { ProfileScreen() }\n}",
                  "explanation": "Temel navigation yapısı."
                }
              ],
              "keyPoints": [
                "Jetpack Navigation for Compose",
                "NavHost ve NavController kullanır",
                "Declarative navigation",
                "Type-safe route desteği"
              ],
              "questions": [
                {
                  "questionId": 540101,
                  "question": "Navigation Component nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI kütüphanesi",
                    "Compose'da ekranlar arası geçişi yönetmek için Jetpack kütüphanesi",
                    "Veritabanı kütüphanesi",
                    "Network kütüphanesi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Navigation Component, Compose'da ekranlar arası geçişi (navigation) yönetmek için kullanılan resmi Jetpack kütüphanesidir.",
                  "tags": ["navigation", "jetpack"]
                },
                {
                  "questionId": 540102,
                  "question": "Compose Navigation'ın XML Navigation'a göre avantajı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Declarative, type-safe, Kotlin DSL ile tanımlama",
                    "Sadece daha hızlı",
                    "XML daha iyi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose Navigation, declarative yaklaşım, type-safe route'lar ve Kotlin DSL ile tanımlama avantajları sunar. XML dosyası gerekmez.",
                  "tags": ["navigation", "compose", "advantages"]
                },
                {
                  "questionId": 540103,
                  "question": "Navigation Component hangi dependency ile eklenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "androidx.compose.ui",
                    "androidx.navigation:navigation-compose",
                    "androidx.compose.navigation",
                    "com.google.navigation"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Navigation Component, androidx.navigation:navigation-compose dependency'si ile eklenir.",
                  "tags": ["navigation", "dependency"]
                },
                {
                  "questionId": 540104,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val navController = rememberNavController()\nNavHost(navController, startDestination = \"home\") {\n    composable(\"home\") { HomeScreen() }\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "Navigation yapısını kurar, başlangıç ekranı home",
                    "Sadece controller oluşturur",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, navigation yapısını kurar. rememberNavController ile controller, NavHost ile navigation graph oluşturulur. Başlangıç ekranı \"home\" route'udur.",
                  "tags": ["navigation", "navhost", "example"]
                }
              ]
            },
            {
              "topicId": 5402,
              "title": "NavHost & NavController",
              "summary": "NavHost navigation graph'ı tanımlar, NavController ise navigation işlemlerini yönetir.",
              "content": "## NavHost & NavController\n\nNavController: Navigation işlemlerini yönetir\nNavHost: Navigation graph'ı (rotaları) tanımlar\n\nrememberNavController ile oluşturulur.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "NavController Kullanımı",
                  "code": "navController.navigate(\"profile\")\nnavController.popBackStack()",
                  "explanation": "Ekran geçişi ve geri gitme."
                }
              ],
              "keyPoints": [
                "NavController navigation yönetir",
                "NavHost rotaları tanımlar",
                "rememberNavController kullanılır",
                "Lifecycle-aware'dır"
              ],
              "questions": [
                {
                  "questionId": 540201,
                  "question": "NavController ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "UI çizer",
                    "Navigation işlemlerini yönetir (navigate, popBackStack)",
                    "State tutar",
                    "Layout oluşturur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "NavController, navigation işlemlerini yönetir: ekran geçişi (navigate), geri gitme (popBackStack), current route bilgisi vb.",
                  "tags": ["navcontroller", "navigation"]
                },
                {
                  "questionId": 540202,
                  "question": "NavHost ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Controller oluşturur",
                    "Navigation graph'ı (rotaları) tanımlar",
                    "Sadece animasyon",
                    "Veritabanı yönetir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "NavHost, navigation graph'ı tanımlar. Her route için hangi Composable'ın gösterileceğini belirler.",
                  "tags": ["navhost", "navigation"]
                },
                {
                  "questionId": 540203,
                  "question": "rememberNavController ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her recomposition'da yeni controller",
                    "NavController'ı recomposition'larda korur",
                    "State oluşturur",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "rememberNavController, NavController'ı recomposition'larda korur. remember kullanarak navigation state kaybolmaz.",
                  "tags": ["remembernavcontroller", "navigation"]
                },
                {
                  "questionId": 540204,
                  "question": "navController.navigate(\"profile\") ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Geri gider",
                    "\"profile\" route'una gider",
                    "Uygulamayı kapatır",
                    "Hata verir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "navController.navigate(\"profile\"), \"profile\" route'una gider. Profile ekranı gösterilir.",
                  "tags": ["navigate", "navcontroller"]
                },
                {
                  "questionId": 540205,
                  "question": "navController.popBackStack() ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "İleri gider",
                    "Geri gider (back button gibi)",
                    "Uygulamayı kapatır",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "navController.popBackStack(), back stack'ten bir ekran geri gider. Android back button davranışı ile aynıdır.",
                  "tags": ["popbackstack", "navcontroller"]
                }
              ]
            },
            {
              "topicId": 5403,
              "title": "Route & Arguments",
              "summary": "Route, her ekranın unique adresini tanımlar. Arguments ile ekranlar arası veri aktarılır.",
              "content": "## Route & Arguments\n\nRoute: String tabanlı adres (örn: \"profile/{userId}\")\nArguments: URL parameter gibi veri geçişi\n\nType-safe arguments önerilir.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Arguments ile Navigation",
                  "code": "composable(\"profile/{userId}\") { backStackEntry ->\n    val userId = backStackEntry.arguments?.getString(\"userId\")\n    ProfileScreen(userId)\n}\nnavController.navigate(\"profile/123\")",
                  "explanation": "Route ile veri geçişi."
                }
              ],
              "keyPoints": [
                "Route ekranın adresi",
                "Arguments veri geçişi sağlar",
                "Path parameter destekler",
                "Optional argument mümkün"
              ],
              "questions": [
                {
                  "questionId": 540301,
                  "question": "Route nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı tablosu",
                    "Her ekranın unique string adresi (örn: 'home', 'profile')",
                    "Network endpoint",
                    "UI bileşeni"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Route, her ekranın unique string adresidir. URL path gibi çalışır (örn: \"home\", \"profile\", \"detail/{id}\").",
                  "tags": ["route", "navigation"]
                },
                {
                  "questionId": 540302,
                  "question": "Route ile veri nasıl geçirilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece Intent",
                    "Path parameter (örn: 'profile/{userId}') veya query parameter",
                    "Sadece Bundle",
                    "Veri geçirilemez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Route ile veri, path parameter (\"profile/{userId}\") veya query parameter (\"search?query=abc\") ile geçirilir. URL mantığı gibi.",
                  "tags": ["route", "arguments", "navigation"]
                },
                {
                  "questionId": 540303,
                  "question": "BackStackEntry nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece route",
                    "Back stack'teki her entry, arguments ve savedStateHandle içerir",
                    "Sadece UI",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "BackStackEntry, back stack'teki her entry'yi temsil eder. arguments (route parameters), savedStateHandle ve lifecycle içerir.",
                  "tags": ["backstackentry", "navigation"]
                },
                {
                  "questionId": 540304,
                  "question": "Optional argument nasıl tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Tanımlanamaz",
                    "composable() içinde arguments parametresi ile navArgument tanımlanır",
                    "Sadece required",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Optional argument, composable() içinde arguments parametresi ile navArgument { defaultValue, nullable } şeklinde tanımlanır.",
                  "tags": ["arguments", "optional", "navigation"]
                },
                {
                  "questionId": 540305,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "composable(\"profile/{userId}\") { backStackEntry ->\n    val userId = backStackEntry.arguments?.getString(\"userId\")\n    ProfileScreen(userId)\n}",
                  "difficulty": "medium",
                  "options": [
                    "Hata verir",
                    "Route'tan userId alır ve ProfileScreen'e geçirir",
                    "Sadece route tanımlar",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, \"profile/{userId}\" route'undan userId parametresini alır ve ProfileScreen'e geçirir. backStackEntry.arguments ile argument'lara erişilir.",
                  "tags": ["route", "arguments", "example"]
                }
              ]
            },
            {
              "topicId": 5404,
              "title": "Bottom Navigation",
              "summary": "Bottom Navigation, alt kısımda sabit navigation bar ile ana ekranlar arasında geçiş sağlar.",
              "content": "## Bottom Navigation\n\nAlt navigation bar için kullanılır.\n\nNavigationBar ve NavigationBarItem kullanılır.\n\nHer item bir route'a karşılık gelir.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Bottom Navigation Örneği",
                  "code": "NavigationBar {\n    items.forEach { item ->\n        NavigationBarItem(\n            selected = currentRoute == item.route,\n            onClick = { navController.navigate(item.route) },\n            icon = { Icon(item.icon) }\n        )\n    }\n}",
                  "explanation": "Bottom navigation bar."
                }
              ],
              "keyPoints": [
                "Alt navigation bar",
                "Ana ekranlar arası geçiş",
                "Material 3 komponenti",
                "Selected state yönetimi"
              ],
              "questions": [
                {
                  "questionId": 540401,
                  "question": "Bottom Navigation ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Top bar",
                    "Alt kısımda sabit navigation bar ile ana ekranlar arası geçiş",
                    "Sadece drawer",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bottom Navigation, alt kısımda sabit navigation bar ile ana ekranlar (Home, Profile, Settings vb.) arasında hızlı geçiş sağlar.",
                  "tags": ["bottom_navigation", "ui"]
                },
                {
                  "questionId": 540402,
                  "question": "Bottom Navigation'da hangi Composable kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "BottomBar",
                    "NavigationBar ve NavigationBarItem (Material 3)",
                    "TabRow",
                    "Menu"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3'te NavigationBar (container) ve NavigationBarItem (her item) kullanılır. Material 2'de BottomNavigation kullanılırdı.",
                  "tags": ["bottom_navigation", "navigationbar"]
                },
                {
                  "questionId": 540403,
                  "question": "Bottom Navigation'da selected state nasıl yönetilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Otomatik",
                    "currentRoute ile karşılaştırılır, manuel yönetilir",
                    "Sadece tıklama",
                    "State gerekmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Selected state, currentRoute ile her item'ın route'u karşılaştırılarak manuel yönetilir. navController.currentDestination kullanılır.",
                  "tags": ["bottom_navigation", "selected_state"]
                },
                {
                  "questionId": 540404,
                  "question": "Bottom Navigation kaç item olmalıdır (Material Design guideline)?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "2",
                    "3-5 item",
                    "10 item",
                    "Sınır yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material Design guideline'a göre Bottom Navigation 3-5 item olmalıdır. Daha fazla item için Navigation Drawer tercih edilir.",
                  "tags": ["bottom_navigation", "material_design"]
                }
              ]
            },
            {
              "topicId": 5405,
              "title": "Deep Links",
              "summary": "Deep Link, uygulamanın belirli bir ekranına doğrudan URL ile erişim sağlar.",
              "content": "## Deep Links\n\nURL ile belirli ekrana erişim.\n\nWeb link veya app link kullanılabilir.\n\nAndroidManifest'te tanımlanır.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Deep Link Tanımlama",
                  "code": "composable(\n    route = \"profile/{userId}\",\n    deepLinks = listOf(navDeepLink { uriPattern = \"myapp://profile/{userId}\" })\n) { ProfileScreen() }",
                  "explanation": "Deep link ile navigation."
                }
              ],
              "keyPoints": [
                "URL ile ekran açma",
                "Web ve app link desteği",
                "AndroidManifest gerektirir",
                "Modüller arası navigation için ideal"
              ],
              "questions": [
                {
                  "questionId": 540501,
                  "question": "Deep Link nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece web link",
                    "URL ile uygulamanın belirli bir ekranına doğrudan erişim",
                    "Sadece email link",
                    "Navigation component"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Deep Link, URL ile uygulamanın belirli bir ekranına doğrudan erişim sağlar. Web'den, email'den veya başka app'ten açılabilir.",
                  "tags": ["deep_link", "navigation"]
                },
                {
                  "questionId": 540502,
                  "question": "Deep Link nasıl tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece kod",
                    "composable() içinde deepLinks parametresi + AndroidManifest intent-filter",
                    "Sadece Manifest",
                    "Tanımlanamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Deep Link, composable() içinde deepLinks parametresi ile tanımlanır ve AndroidManifest'te intent-filter eklenir.",
                  "tags": ["deep_link", "setup"]
                },
                {
                  "questionId": 540503,
                  "question": "Deep Link ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece UI",
                    "Web/email'den app açma, notification'dan ekran açma, modüler navigation",
                    "Sadece performans",
                    "Hiçbir işe yaramaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Deep Link kullanım alanları: Web/email'den app'in belirli ekranını açma, notification'dan direkt ekran açma, multi-module projede modüller arası navigation.",
                  "tags": ["deep_link", "use_case"]
                },
                {
                  "questionId": 540504,
                  "question": "Aşağıdaki deep link ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "deepLinks = listOf(navDeepLink { uriPattern = \"myapp://profile/{userId}\" })",
                  "difficulty": "medium",
                  "options": [
                    "Hata verir",
                    "myapp://profile/123 URL'i profile ekranını açar, userId=123",
                    "Sadece web link",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu deep link, myapp://profile/123 gibi bir URL geldiğinde profile ekranını açar ve userId parametresini 123 olarak geçirir.",
                  "tags": ["deep_link", "example"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 540001,
              "question": "Navigation back stack nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece son ekran",
                "Ziyaret edilen ekranların sıralı listesi (stack)",
                "Veritabanı",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Back stack, ziyaret edilen ekranların sıralı listesidir (LIFO - Last In First Out). Back button ile stack'ten pop edilir.",
              "tags": ["navigation", "backstack"]
            },
            {
              "questionId": 540002,
              "question": "NavController'a nereden erişilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece Activity'den",
                "NavHost'ta remember edilen controller, child Composable'lara parametre olarak geçilir",
                "Global singleton",
                "Otomatik erişim"
              ],
              "correctAnswerIndex": 1,
              "explanation": "NavController, NavHost'ta rememberNavController ile oluşturulur ve child Composable'lara parametre olarak geçilir. Global state tutmak anti-pattern'dir.",
              "tags": ["navcontroller", "access"]
            },
            {
              "questionId": 540003,
              "question": "popUpTo ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece animasyon",
                "Navigate ederken back stack'i belirli bir route'a kadar temizler",
                "Sadece UI",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "popUpTo, navigate ederken back stack'i belirli bir route'a kadar temizler. Örneğin login sonrası splash'e geri dönülmemesi için kullanılır.",
              "tags": ["navigation", "popupto"]
            },
            {
              "questionId": 540004,
              "question": "launchSingleTop ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey yapmaz",
                "Aynı route tekrar navigate edilirse yeni instance oluşturmaz",
                "Sadece ilk ekran",
                "Sadece animasyon"
              ],
              "correctAnswerIndex": 1,
              "explanation": "launchSingleTop = true, aynı route'a tekrar navigate edilirse back stack'te yeni instance oluşturmaz. Mevcut instance kullanılır (Android launchMode singleTop gibi).",
              "tags": ["navigation", "launchsingletop"]
            },
            {
              "questionId": 540005,
              "question": "Navigation animation nasıl eklenir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Otomatik",
                "composable() içinde enterTransition, exitTransition vb. parametreleri",
                "Sadece XML",
                "Eklenemez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Navigation animation, composable() içinde enterTransition, exitTransition, popEnterTransition, popExitTransition parametreleri ile eklenir.",
              "tags": ["navigation", "animation"]
            },
            {
              "questionId": 540006,
              "question": "Type-safe navigation ne demektir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece String route",
                "Route ve arguments'ın compile-time'da type-safe olması (Kotlin Serialization ile)",
                "Sadece Int",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Type-safe navigation (Compose 2.8+), route ve arguments'ın compile-time'da type-safe olmasını sağlar. Kotlin Serialization ile data class route kullanılır, String yerine.",
              "tags": ["navigation", "type_safe"]
            },
            {
              "questionId": 540007,
              "question": "Nested navigation nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece tek seviye",
                "Navigation graph içinde başka navigation graph (nested NavHost)",
                "Sadece bottom nav",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Nested navigation, navigation graph içinde başka navigation graph'lar barındırır. Örneğin, Bottom Nav her tab'ı için ayrı nested navigation.",
              "tags": ["navigation", "nested"]
            },
            {
              "questionId": 540008,
              "question": "currentBackStackEntryAsState() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece route",
                "Current destination'ı State olarak döner, recomposition tetikler",
                "Sadece log",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "currentBackStackEntryAsState(), current destination'ı State olarak döner. Destination değiştiğinde recomposition tetikler. Bottom Nav'da selected state için kullanılır.",
              "tags": ["navigation", "state"]
            },
            {
              "questionId": 540009,
              "question": "SavedStateHandle navigation ile nasıl çalışır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Çalışmaz",
                "Route arguments otomatik olarak SavedStateHandle'a eklenir, ViewModel'de erişilebilir",
                "Sadece manuel",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Navigation, route arguments'ları otomatik olarak SavedStateHandle'a ekler. ViewModel constructor'ında SavedStateHandle alarak route arguments'lara erişebilirsiniz.",
              "tags": ["navigation", "savedstatehandle", "viewmodel"]
            },
            {
              "questionId": 540010,
              "question": "Navigation için ViewModel paylaşımı nasıl yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece global",
                "viewModel(navController.getBackStackEntry(route)) ile parent route'un ViewModel'i paylaşılır",
                "Paylaşılamaz",
                "Sadece Activity scoped"
              ],
              "correctAnswerIndex": 1,
              "explanation": "viewModel(navController.getBackStackEntry(parentRoute)) kullanarak child ekranlar parent route'un ViewModel'ini paylaşabilir. Multi-step flow'larda kullanılır.",
              "tags": ["navigation", "viewmodel", "sharing"]
            }
          ]
        },
        {
          "sectionId": 5500,
          "sectionTitle": "ViewModel & Lifecycle",
          "sectionDescription": "Compose'da ViewModel kullanımı, lifecycle yönetimi ve state akışı",
          "order": 5,
          "topics": [
            {
              "topicId": 5501,
              "title": "ViewModel ile Compose",
              "summary": "ViewModel, Compose'da business logic ve state'i UI'dan ayırarak MVVM pattern'i uygular. Configuration change'lerde hayatta kalır.",
              "content": "## ViewModel ile Compose\n\nViewModel business logic ve state tutar.\n\nComposable UI katmanıdır.\n\nConfiguration change'lerde ViewModel korunur.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "ViewModel Kullanımı",
                  "code": "@Composable\nfun MyScreen(viewModel: MyViewModel = viewModel()) {\n    val state by viewModel.uiState.collectAsState()\n    // UI\n}",
                  "explanation": "ViewModel'den state alma."
                }
              ],
              "keyPoints": [
                "Business logic tutar",
                "Configuration change'de korunur",
                "UI'dan bağımsızdır",
                "MVVM pattern'in temelidir"
              ],
              "questions": [
                {
                  "questionId": 550101,
                  "question": "ViewModel'in Compose'daki görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece UI çizer",
                    "Business logic ve state'i tutar, UI'dan ayırır",
                    "Sadece navigation",
                    "Database yönetir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewModel, business logic ve state'i tutar, UI'dan (Composable) ayırır. MVVM pattern'in temel bileşenidir.",
                  "tags": ["viewmodel", "mvvm"]
                },
                {
                  "questionId": 550102,
                  "question": "ViewModel configuration change'de ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Yok olur",
                    "Hayatta kalır (destroyed olmaz)",
                    "Yeniden oluşturulur",
                    "Sadece state korunur"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewModel, configuration change'lerde (ekran döndürme) hayatta kalır (destroyed olmaz). Bu nedenle state korunur ve UI yeniden veri çekmek zorunda kalmaz.",
                  "tags": ["viewmodel", "configuration_change"]
                },
                {
                  "questionId": 550103,
                  "question": "Compose'da ViewModel nasıl alınır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "new ViewModel()",
                    "viewModel() fonksiyonu ile",
                    "ViewModel.create()",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose'da viewModel() fonksiyonu ile ViewModel alınır. Bu fonksiyon, androidx.lifecycle:lifecycle-viewmodel-compose dependency'sinden gelir.",
                  "tags": ["viewmodel", "compose"]
                },
                {
                  "questionId": 550104,
                  "question": "ViewModel'de Composable referansı tutulmalı mı?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Evet, her zaman",
                    "Hayır, memory leak riski yaratır",
                    "Fark etmez",
                    "Sadece State"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ViewModel'de Composable, Context, View referansı tutulmamalıdır. ViewModel, UI'dan daha uzun yaşar, memory leak riski yaratır. Sadece business logic ve state tutulmalı.",
                  "tags": ["viewmodel", "memory_leak", "best_practice"]
                },
                {
                  "questionId": 550105,
                  "question": "Aşağıdaki kullanım doğru mu?",
                  "questionType": "multiple_choice",
                  "code": "@Composable\nfun MyScreen(viewModel: MyViewModel = viewModel()) {\n    val state by viewModel.uiState.collectAsState()\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, doğru kullanım",
                    "viewModel parametre olmamalı",
                    "collectAsState yanlış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru kullanımdır. viewModel() ile ViewModel alınır, default parameter olarak verilir (test için inject edilebilir). uiState Flow'u collectAsState ile State'e çevrilir.",
                  "tags": ["viewmodel", "example", "best_practice"]
                }
              ]
            },
            {
              "topicId": 5502,
              "title": "collectAsState & collectAsStateWithLifecycle",
              "summary": "Flow'dan State'e dönüşüm için kullanılır. collectAsStateWithLifecycle lifecycle-aware'dır ve memory leak önler.",
              "content": "## collectAsState vs collectAsStateWithLifecycle\n\ncollectAsState: Flow'u State'e çevirir\ncollectAsStateWithLifecycle: Lifecycle-aware, app background'dayken collect durur\n\ncollectAsStateWithLifecycle önerilir.",
              "difficulty": "hard",
              "order": 2,
              "codeExamples": [
                {
                  "title": "collectAsStateWithLifecycle",
                  "code": "val state by viewModel.uiState.collectAsStateWithLifecycle()",
                  "explanation": "Lifecycle-aware state collection."
                }
              ],
              "keyPoints": [
                "Flow'dan State'e dönüşüm",
                "collectAsStateWithLifecycle lifecycle-aware",
                "App background'da collect durur",
                "Memory leak önler"
              ],
              "questions": [
                {
                  "questionId": 550201,
                  "question": "collectAsState() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "State oluşturur",
                    "Flow'u State'e çevirir (Flow → State)",
                    "Sadece collect eder",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collectAsState(), Flow'u Compose State'ine çevirir. Flow emit ettiğinde State güncellenir ve recomposition tetiklenir.",
                  "tags": ["collectasstate", "flow"]
                },
                {
                  "questionId": 550202,
                  "question": "collectAsStateWithLifecycle() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "collectAsState ile aynı",
                    "Lifecycle-aware, app background'dayken collect durur",
                    "Sadece hız artışı",
                    "Kullanımdan kalkmış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collectAsStateWithLifecycle(), lifecycle-aware'dır. App background'a gittiğinde (onStop) collect durur, foreground'a dönünce (onStart) devam eder. Bu, memory ve battery optimizasyonu sağlar.",
                  "tags": ["collectasstatewithlifecycle", "lifecycle"]
                },
                {
                  "questionId": 550203,
                  "question": "collectAsState ve collectAsStateWithLifecycle arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir fark yok",
                    "collectAsStateWithLifecycle lifecycle-aware, background'da durur",
                    "collectAsState daha hızlı",
                    "collectAsStateWithLifecycle deprecated"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collectAsState her zaman collect eder. collectAsStateWithLifecycle ise app background'dayken collect durur, gereksiz güncelleme ve kaynak kullanımını önler.",
                  "tags": ["collectasstate", "collectasstatewithlifecycle", "difference"]
                },
                {
                  "questionId": 550204,
                  "question": "Hangisi önerilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "collectAsState",
                    "collectAsStateWithLifecycle (önerilir)",
                    "Fark etmez",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collectAsStateWithLifecycle önerilir çünkü lifecycle-aware'dır, memory leak riskini azaltır ve battery optimization sağlar. Google'ın resmi önerisidir.",
                  "tags": ["collectasstatewithlifecycle", "best_practice"]
                },
                {
                  "questionId": 550205,
                  "question": "collectAsStateWithLifecycle hangi dependency'den gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "androidx.compose.ui",
                    "androidx.lifecycle:lifecycle-runtime-compose",
                    "androidx.lifecycle:lifecycle-viewmodel",
                    "androidx.compose.runtime"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "collectAsStateWithLifecycle, androidx.lifecycle:lifecycle-runtime-compose dependency'sinden gelir.",
                  "tags": ["collectasstatewithlifecycle", "dependency"]
                }
              ]
            },
            {
              "topicId": 5503,
              "title": "StateFlow & LiveData Entegrasyonu",
              "summary": "ViewModel'de StateFlow veya LiveData kullanılabilir. StateFlow modern yaklaşımdır.",
              "content": "## StateFlow vs LiveData\n\nStateFlow: Coroutine tabanlı, modern tercih\nLiveData: Lifecycle-aware, XML uyumlu\n\nStateFlow tercih edilir.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "StateFlow Kullanımı",
                  "code": "class MyViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState())\n    val uiState: StateFlow<UiState> = _uiState.asStateFlow()\n}",
                  "explanation": "ViewModel'de StateFlow pattern."
                }
              ],
              "keyPoints": [
                "StateFlow modern yaklaşım",
                "LiveData hala desteklenir",
                "StateFlow coroutine tabanlı",
                "asStateFlow() encapsulation sağlar"
              ],
              "questions": [
                {
                  "questionId": 550301,
                  "question": "ViewModel'de StateFlow mi LiveData mı tercih edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "LiveData",
                    "StateFlow (modern tercih)",
                    "Her ikisi de eşit",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "StateFlow modern yaklaşımdır ve Compose ile daha iyi entegrasyon sağlar. Coroutine tabanlıdır ve daha fazla operatör (map, filter) sunar.",
                  "tags": ["stateflow", "livedata", "comparison"]
                },
                {
                  "questionId": 550302,
                  "question": "LiveData Compose'da nasıl kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Kullanılamaz",
                    "observeAsState() ile State'e çevrilir",
                    "Sadece XML'de",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LiveData, observeAsState() fonksiyonu ile Compose State'ine çevrilir. Ancak StateFlow tercih edilir.",
                  "tags": ["livedata", "observeasstate", "compose"]
                },
                {
                  "questionId": 550303,
                  "question": "asStateFlow() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "State oluşturur",
                    "MutableStateFlow'u read-only StateFlow'a çevirir (encapsulation)",
                    "Flow başlatır",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "asStateFlow(), MutableStateFlow'u read-only StateFlow'a çevirir. Bu, encapsulation sağlar: ViewModel dışından state değiştirilemez, sadece okunabilir.",
                  "tags": ["stateflow", "asstateflow", "encapsulation"]
                },
                {
                  "questionId": 550304,
                  "question": "Aşağıdaki pattern doğru mu?",
                  "questionType": "multiple_choice",
                  "code": "private val _uiState = MutableStateFlow(UiState())\nval uiState: StateFlow<UiState> = _uiState.asStateFlow()",
                  "difficulty": "medium",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, doğru encapsulation pattern",
                    "Private gereksiz",
                    "asStateFlow gereksiz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru encapsulation pattern'dir. _uiState private ve mutable, uiState public ve read-only. ViewModel dışından sadece okuma yapılabilir, değiştiremez.",
                  "tags": ["stateflow", "pattern", "encapsulation"]
                }
              ]
            },
            {
              "topicId": 5504,
              "title": "Hilt ile ViewModel Injection",
              "summary": "Hilt, ViewModel'e dependency injection yapar. @HiltViewModel ile otomatik injection sağlanır.",
              "content": "## Hilt + ViewModel\n\n@HiltViewModel annotation ile ViewModel inject edilir.\n\nConstructor injection kullanılır.\n\nBoilerplate kod azalır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Hilt ViewModel",
                  "code": "@HiltViewModel\nclass MyViewModel @Inject constructor(\n    private val repository: Repository\n) : ViewModel()",
                  "explanation": "Hilt ile ViewModel injection."
                }
              ],
              "keyPoints": [
                "@HiltViewModel annotation",
                "Constructor injection",
                "ViewModelProvider.Factory gerekmez",
                "Test edilebilirlik artar"
              ],
              "questions": [
                {
                  "questionId": 550401,
                  "question": "@HiltViewModel annotation'ı ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece görsel",
                    "ViewModel'i Hilt'e tanıtır, otomatik injection sağlar",
                    "Test için",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@HiltViewModel, ViewModel'i Hilt'e tanıtır. Bağımlılıklar otomatik inject edilir, ViewModelProvider.Factory gerekmez.",
                  "tags": ["hilt", "viewmodel", "annotation"]
                },
                {
                  "questionId": 550402,
                  "question": "Hilt ile ViewModel'e dependency nasıl inject edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Manuel injection",
                    "Constructor injection (@Inject constructor)",
                    "Field injection",
                    "Method injection"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt ile ViewModel'e constructor injection yapılır: @Inject constructor(private val repo: Repository). Bağımlılıklar otomatik sağlanır.",
                  "tags": ["hilt", "constructor_injection"]
                },
                {
                  "questionId": 550403,
                  "question": "Hilt olmadan ViewModel dependency injection nasıl yapılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Yapılamaz",
                    "ViewModelProvider.Factory implement edilir (boilerplate)",
                    "Otomatik",
                    "Sadece Hilt"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Hilt olmadan ViewModelProvider.Factory implement edilir ve manuel injection yapılır. Bu, boilerplate kod gerektirir. Hilt bu karmaşıklığı ortadan kaldırır.",
                  "tags": ["viewmodel", "factory", "hilt"]
                },
                {
                  "questionId": 550404,
                  "question": "Aşağıdaki Hilt ViewModel doğru mu?",
                  "questionType": "multiple_choice",
                  "code": "@HiltViewModel\nclass MyViewModel @Inject constructor(\n    private val repository: Repository\n) : ViewModel()",
                  "difficulty": "easy",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, doğru Hilt ViewModel",
                    "@Inject gereksiz",
                    "@HiltViewModel gereksiz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru Hilt ViewModel pattern'idir. @HiltViewModel ve @Inject constructor ile repository otomatik inject edilir.",
                  "tags": ["hilt", "viewmodel", "example"]
                }
              ]
            },
            {
              "topicId": 5505,
              "title": "Lifecycle-aware Composables",
              "summary": "Compose, lifecycle-aware'dır. DisposableEffect ve LaunchedEffect ile lifecycle olayları yönetilir.",
              "content": "## Lifecycle in Compose\n\nCompose otomatik lifecycle-aware'dır.\n\nDisposableEffect lifecycle olaylarını dinler.\n\nApp background/foreground yönetimi.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Lifecycle Observer",
                  "code": "DisposableEffect(Unit) {\n    val observer = LifecycleEventObserver { _, event ->\n        if (event == Lifecycle.Event.ON_RESUME) { }\n    }\n    lifecycle.addObserver(observer)\n    onDispose { lifecycle.removeObserver(observer) }\n}",
                  "explanation": "Lifecycle event'lerini dinleme."
                }
              ],
              "keyPoints": [
                "Compose lifecycle-aware",
                "DisposableEffect için cleanup",
                "Background/foreground yönetimi",
                "Memory leak önleme"
              ],
              "questions": [
                {
                  "questionId": 550501,
                  "question": "Compose otomatik lifecycle-aware mıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hayır, manuel yönetim gerekir",
                    "Evet, Composable otomatik lifecycle-aware'dır",
                    "Sadece ViewModel",
                    "Sadece Activity"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Evet, Compose otomatik lifecycle-aware'dır. Composable, composition'a girdiğinde başlar, çıktığında temizlenir. LaunchedEffect, DisposableEffect gibi API'lar lifecycle olaylarını yönetir.",
                  "tags": ["lifecycle", "compose"]
                },
                {
                  "questionId": 550502,
                  "question": "DisposableEffect ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her zaman",
                    "Cleanup gerektiren lifecycle-aware işlemler için (listener add/remove)",
                    "Sadece API çağrısı",
                    "Kullanılmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "DisposableEffect, cleanup gerektiren lifecycle-aware işlemler için kullanılır: listener ekleme/çıkarma, subscription başlatma/durdurma. onDispose bloğu cleanup yapar.",
                  "tags": ["disposableeffect", "lifecycle"]
                },
                {
                  "questionId": 550503,
                  "question": "LocalLifecycleOwner ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece state",
                    "Composable içinden lifecycle'a erişim sağlar",
                    "ViewModel oluşturur",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LocalLifecycleOwner, Composable içinden mevcut lifecycle'a erişim sağlar. DisposableEffect ile birlikte kullanılarak lifecycle event'leri dinlenebilir.",
                  "tags": ["locallifecycleowner", "lifecycle"]
                },
                {
                  "questionId": 550504,
                  "question": "App background'a gittiğinde Composable ne olur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Yok olur",
                    "Composition kalır ama inactive olur (onStop)",
                    "Yeniden oluşturulur",
                    "Hiçbir şey olmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "App background'a gittiğinde Composable composition'da kalır ama inactive olur (onStop çağrılır). Foreground'a dönünce active olur (onStart). collectAsStateWithLifecycle bu durumu handle eder.",
                  "tags": ["lifecycle", "background"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 550001,
              "question": "ViewModel'in lifecycle'ı ne kadardır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Composable ile aynı",
                "Activity/Fragment finish olana kadar (configuration change'de hayatta kalır)",
                "Sadece bir recomposition",
                "Uygulama kapanana kadar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ViewModel'in lifecycle'ı, Activity/Fragment finish olana kadar devam eder. Configuration change'de (ekran döndürme) hayatta kalır. onCleared() çağrıldığında temizlenir.",
              "tags": ["viewmodel", "lifecycle"]
            },
            {
              "questionId": 550002,
              "question": "ViewModel.onCleared() ne zaman çağrılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Her recomposition",
                "ViewModel yok edildiğinde (Activity/Fragment finish)",
                "App background'a gittiğinde",
                "Hiçbir zaman"
              ],
              "correctAnswerIndex": 1,
              "explanation": "onCleared(), ViewModel yok edildiğinde (Activity/Fragment finish) çağrılır. Cleanup işlemleri (coroutine iptal, listener çıkarma) burada yapılır.",
              "tags": ["viewmodel", "oncleared"]
            },
            {
              "questionId": 550003,
              "question": "viewModelScope nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Global scope",
                "ViewModel'e bağlı CoroutineScope, onCleared'da iptal edilir",
                "Activity scope",
                "Manuel scope"
              ],
              "correctAnswerIndex": 1,
              "explanation": "viewModelScope, ViewModel'e bağlı CoroutineScope'tur. ViewModel onCleared() çağrıldığında otomatik olarak iptal edilir. Memory leak önler.",
              "tags": ["viewmodelscope", "coroutine"]
            },
            {
              "questionId": 550004,
              "question": "UI State pattern nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece state",
                "Tüm UI state'ini tek bir data class'ta toplama (UiState)",
                "Sadece LiveData",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "UI State pattern, tüm UI state'ini tek bir data class'ta toplar (örn: data class UiState(loading, error, data)). Single source of truth ve kollay state management sağlar.",
              "tags": ["ui_state", "pattern"]
            },
            {
              "questionId": 550005,
              "question": "Shared ViewModel nasıl kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Kullanılamaz",
                "viewModel(viewModelStoreOwner = ...) ile parent Activity/Navigation graph ViewModel'i paylaşılır",
                "Sadece global",
                "Her zaman ayrı"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Shared ViewModel, viewModel(viewModelStoreOwner = LocalContext.current as ComponentActivity) veya Navigation graph ile parent'ın ViewModel'i paylaşılır. Fragment'lar arası veri paylaşımında kullanılır.",
              "tags": ["viewmodel", "shared"]
            },
            {
              "questionId": 550006,
              "question": "SavedStateHandle ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece state",
                "Process death'de state'i korur (Bundle'a kaydeder)",
                "Configuration change için",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SavedStateHandle, process death (sistem tarafından app kill) durumunda state'i korur. Bundle'a kaydeder. Configuration change'de ViewModel korunur ama process death'de SavedStateHandle gerekir.",
              "tags": ["savedstatehandle", "process_death"]
            },
            {
              "questionId": 550007,
              "question": "ViewModel test ederken ne yapılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Test edilemez",
                "Dependency'ler mock edilir, ViewModel Unit Test yapılır",
                "Sadece UI test",
                "Sadece manuel test"
              ],
              "correctAnswerIndex": 1,
              "explanation": "ViewModel Unit Test yapılır. Dependency'ler (Repository) mock edilir (Mockito/MockK), business logic ve state transformation test edilir. UI'dan bağımsız, hızlı test.",
              "tags": ["viewmodel", "testing"]
            },
            {
              "questionId": 550008,
              "question": "repeatOnLifecycle ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece bir kez",
                "Lifecycle belirli state'e geldiğinde coroutine başlatır, çıktığında iptal eder",
                "Sadece repeat",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "repeatOnLifecycle, lifecycle belirli state'e (örn: STARTED) geldiğinde coroutine başlatır, state'den çıktığında (örn: STOPPED) iptal eder. collectAsStateWithLifecycle içinde kullanılır.",
              "tags": ["repeatonlifecycle", "lifecycle"]
            },
            {
              "questionId": 550009,
              "question": "Compose'da lifecycle event'leri nasıl dinlenir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Dinlenemez",
                "DisposableEffect + LifecycleEventObserver ile",
                "Sadece ViewModel",
                "Otomatik"
              ],
              "correctAnswerIndex": 1,
              "explanation": "DisposableEffect içinde LifecycleEventObserver kullanarak lifecycle event'leri (onCreate, onStart, onResume, onPause, onStop, onDestroy) dinlenebilir.",
              "tags": ["lifecycle", "event", "disposableeffect"]
            },
            {
              "questionId": 550010,
              "question": "Lifecycle.State.STARTED ve RESUMED farkı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "STARTED: visible but not interactive, RESUMED: visible and interactive",
                "RESUMED daha önce",
                "Aynı şey"
              ],
              "correctAnswerIndex": 1,
              "explanation": "STARTED: ekran görünür ama interactive değil (örn: dialog üstte). RESUMED: ekran görünür ve interactive. collectAsStateWithLifecycle varsayılan olarak STARTED kullanır (battery için).",
              "tags": ["lifecycle", "state", "started", "resumed"]
            }
          ]
        },
        {
          "sectionId": 5600,
          "sectionTitle": "Material Design 3",
          "sectionDescription": "Material Design 3 (Material You) ile modern, dinamik ve erişilebilir UI tasarımı",
          "order": 6,
          "topics": [
            {
              "topicId": 5601,
              "title": "Material 3 Components",
              "summary": "Material 3, Button, Card, TextField gibi modern UI bileşenleri sunar. Material 2'den farklı görsel tasarıma sahiptir.",
              "content": "## Material 3 Components\n\nMaterial 3 (Material You) güncel Material Design'dır.\n\nButton, Card, TextField, TopAppBar gibi bileşenler içerir.\n\nDaha yuvarlak köşeler ve dinamik renk sistemi.",
              "difficulty": "easy",
              "order": 1,
              "codeExamples": [
                {
                  "title": "Material 3 Button",
                  "code": "Button(onClick = { }) {\n    Text(\"Material 3 Button\")\n}",
                  "explanation": "Material 3 Button varsayılan olarak gelir."
                }
              ],
              "keyPoints": [
                "Material You olarak da bilinir",
                "Modern UI bileşenleri",
                "Dinamik renk desteği",
                "Material 2'den farklı görsel"
              ],
              "questions": [
                {
                  "questionId": 560101,
                  "question": "Material 3 nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Veritabanı",
                    "Google'ın güncel Material Design versiyonu (Material You)",
                    "Network kütüphanesi",
                    "Test framework'ü"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3 (Material You), Google'ın güncel Material Design versiyonudur. Compose ile birlikte geliştirilmiştir.",
                  "tags": ["material3", "design"]
                },
                {
                  "questionId": 560102,
                  "question": "Material 3 hangi dependency ile eklenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "androidx.compose.material",
                    "androidx.compose.material3:material3",
                    "com.google.material3",
                    "androidx.material3"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3, androidx.compose.material3:material3 dependency'si ile eklenir. Material 2 ise androidx.compose.material'dır.",
                  "tags": ["material3", "dependency"]
                },
                {
                  "questionId": 560103,
                  "question": "Material 3 ve Material 2 arasındaki fark nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Hiçbir fark yok",
                    "Material 3 daha yuvarlak köşeler, dinamik renk, modern görsel",
                    "Material 2 daha modern",
                    "Sadece renk farkı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3, daha yuvarlak köşeler, dinamik renk sistemi (Android 12+), modern görsel tasarım ve yeni bileşenler sunar.",
                  "tags": ["material3", "material2", "difference"]
                },
                {
                  "questionId": 560104,
                  "question": "Material 3 Button ile Material 2 Button aynı mı?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Evet, tamamen aynı",
                    "Hayır, görsel tasarım ve default style farklı",
                    "Sadece renk farkı",
                    "Material 2 daha iyi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3 Button, Material 2'den farklı görsel tasarıma sahiptir: daha yuvarlak köşeler, farklı elevation, farklı padding ve renk kullanımı.",
                  "tags": ["material3", "button", "components"]
                }
              ]
            },
            {
              "topicId": 5602,
              "title": "Theme & Color System",
              "summary": "Material 3 dinamik renk sistemi sunar. Primary, Secondary, Tertiary color scheme kullanılır.",
              "content": "## Theme & Color System\n\nMaterialTheme Composable tema tanımlar.\n\nPrimary, Secondary, Tertiary renk şemaları.\n\nDinamik renk desteği (Android 12+).",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "MaterialTheme Kullanımı",
                  "code": "MaterialTheme(\n    colorScheme = lightColorScheme(\n        primary = Color(0xFF6200EE)\n    )\n) {\n    // App content\n}",
                  "explanation": "Custom renk şeması tanımlama."
                }
              ],
              "keyPoints": [
                "MaterialTheme tema sağlar",
                "ColorScheme renk şeması",
                "Dinamik renk (wallpaper bazlı)",
                "Light ve Dark scheme"
              ],
              "questions": [
                {
                  "questionId": 560201,
                  "question": "MaterialTheme ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece renk",
                    "Tema sağlar (renk, tipografi, shape)",
                    "Sadece font",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MaterialTheme, uygulamanın temasını sağlar: ColorScheme (renk), Typography (tipografi), Shapes (şekil). Tüm Material bileşenleri bu temayı kullanır.",
                  "tags": ["materialtheme", "theme"]
                },
                {
                  "questionId": 560202,
                  "question": "Material 3'te kaç ana renk kategorisi vardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "1 (sadece primary)",
                    "3 (Primary, Secondary, Tertiary)",
                    "2 (Primary, Secondary)",
                    "5"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3'te 3 ana renk kategorisi vardır: Primary (ana renk), Secondary (ikincil renk), Tertiary (üçüncül renk). Her biri farklı varyantlara sahiptir.",
                  "tags": ["material3", "color", "scheme"]
                },
                {
                  "questionId": 560203,
                  "question": "Dinamik renk (Dynamic Color) nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece animasyon",
                    "Wallpaper'dan renk çıkararak tema oluşturma (Android 12+)",
                    "Manuel renk seçimi",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dinamik renk, Android 12+ cihazlarda wallpaper'dan renk çıkararak otomatik tema oluşturur. dynamicLightColorScheme() ve dynamicDarkColorScheme() ile kullanılır.",
                  "tags": ["material3", "dynamic_color"]
                },
                {
                  "questionId": 560204,
                  "question": "MaterialTheme.colorScheme.primary ne döner?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "String",
                    "Color (Primary renk)",
                    "Int",
                    "Theme"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MaterialTheme.colorScheme.primary, mevcut temanın primary rengini (Color) döner. Composable'larda tema renklerine erişim için kullanılır.",
                  "tags": ["materialtheme", "colorscheme", "primary"]
                },
                {
                  "questionId": 560205,
                  "question": "lightColorScheme() ve darkColorScheme() ne yapar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece renk atar",
                    "Light ve Dark tema için ColorScheme oluşturur",
                    "Otomatik tema",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "lightColorScheme() ve darkColorScheme(), sırasıyla light ve dark tema için ColorScheme oluşturur. Her biri farklı renk palette'i tanımlar.",
                  "tags": ["colorscheme", "light", "dark"]
                }
              ]
            },
            {
              "topicId": 5603,
              "title": "Typography & Shapes",
              "summary": "Material 3 Typography ve Shape sistemi ile tutarlı tipografi ve şekil kullanımı sağlanır.",
              "content": "## Typography & Shapes\n\nTypography: Font, boyut, ağırlık tanımlar\nShapes: Köşe yuvarlaklığı tanımlar\n\nMaterialTheme.typography ve shapes erişim sağlar.",
              "difficulty": "medium",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Typography Kullanımı",
                  "code": "Text(\n    text = \"Başlık\",\n    style = MaterialTheme.typography.headlineLarge\n)",
                  "explanation": "Material 3 tipografi kullanımı."
                }
              ],
              "keyPoints": [
                "Typography font sistemi",
                "Shapes köşe yuvarlaklığı",
                "displayLarge, headlineMedium vb.",
                "Tutarlı tasarım dili"
              ],
              "questions": [
                {
                  "questionId": 560301,
                  "question": "Typography nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece renk",
                    "Font, boyut, ağırlık sistemi",
                    "Sadece layout",
                    "Shape sistemi"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Typography, uygulamanın font, font boyutu, font ağırlığı (weight), line height gibi tipografi özelliklerini tanımlayan sistemdir.",
                  "tags": ["typography", "material3"]
                },
                {
                  "questionId": 560302,
                  "question": "Material 3'te hangi Typography style'lar vardır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece 1 style",
                    "displayLarge, headlineMedium, bodySmall gibi çeşitli style'lar",
                    "Sadece bold ve normal",
                    "Custom tanımlanamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material 3, displayLarge/Medium/Small, headlineLarge/Medium/Small, titleLarge/Medium/Small, bodyLarge/Medium/Small, labelLarge/Medium/Small gibi önceden tanımlı style'lar sunar.",
                  "tags": ["typography", "styles"]
                },
                {
                  "questionId": 560303,
                  "question": "Shapes ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece renk",
                    "Bileşenlerin köşe yuvarlaklığını (corner radius) tanımlar",
                    "Sadece boyut",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Shapes, Material bileşenlerinin köşe yuvarlaklığını (corner radius) tanımlar. small, medium, large kategorileri vardır.",
                  "tags": ["shapes", "material3"]
                },
                {
                  "questionId": 560304,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "Text(\n    text = \"Başlık\",\n    style = MaterialTheme.typography.headlineLarge\n)",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "Material 3 headlineLarge tipografi style'ı ile text gösterir",
                    "Sadece renk değişir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, Material 3'ün headlineLarge tipografi style'ını (büyük başlık için font, boyut, ağırlık) kullanarak text gösterir.",
                  "tags": ["typography", "example", "text"]
                }
              ]
            },
            {
              "topicId": 5604,
              "title": "Dark Mode",
              "summary": "Material 3 Light ve Dark Mode desteği sunar. Otomatik tema değişimi yapılabilir.",
              "content": "## Dark Mode\n\nLight ve Dark ColorScheme tanımlanır.\n\nisSystemInDarkTheme() sistem teması tespit eder.\n\nOtomatik tema değişimi sağlanır.",
              "difficulty": "medium",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Dark Mode Desteği",
                  "code": "val darkTheme = isSystemInDarkTheme()\nval colorScheme = if (darkTheme) darkColorScheme() else lightColorScheme()\nMaterialTheme(colorScheme = colorScheme) { }",
                  "explanation": "Otomatik tema değişimi."
                }
              ],
              "keyPoints": [
                "Light ve Dark scheme",
                "isSystemInDarkTheme() tespit",
                "Otomatik tema geçişi",
                "Göz sağlığı ve battery tasarrufu"
              ],
              "questions": [
                {
                  "questionId": 560401,
                  "question": "Dark Mode neden önemlidir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece görsel",
                    "Göz sağlığı, battery tasarrufu (OLED), kullanıcı tercihi",
                    "Sadece trend",
                    "Hiçbir önemi yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dark Mode, göz sağlığı (özellikle düşük ışıkta), battery tasarrufu (OLED ekranlarda), kullanıcı tercihi ve erişilebilirlik için önemlidir.",
                  "tags": ["dark_mode", "importance"]
                },
                {
                  "questionId": 560402,
                  "question": "isSystemInDarkTheme() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Dark mode'u zorlar",
                    "Sistem dark mode durumunu tespit eder (Boolean döner)",
                    "Tema değiştirir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "isSystemInDarkTheme(), cihazın sistem temasının dark mode'da olup olmadığını tespit eder. true veya false döner.",
                  "tags": ["dark_mode", "issystemindarktheme"]
                },
                {
                  "questionId": 560403,
                  "question": "Otomatik tema değişimi nasıl yapılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Manuel switch",
                    "isSystemInDarkTheme() ile ColorScheme seçilir",
                    "Otomatik yapılamaz",
                    "Sadece manuel"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Otomatik tema değişimi için: val darkTheme = isSystemInDarkTheme(); val colorScheme = if (darkTheme) darkColorScheme() else lightColorScheme()",
                  "tags": ["dark_mode", "automatic"]
                },
                {
                  "questionId": 560404,
                  "question": "Dark Mode'da hangi renkler kullanılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Aynı renkler",
                    "Daha yumuşak, düşük contrast renkler (göz yorgunluğu azaltmak için)",
                    "Daha parlak renkler",
                    "Fark etmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Dark Mode'da daha yumuşak, düşük contrast renkler kullanılmalıdır. Çok parlak beyaz yerine biraz mat beyaz, saf siyah yerine koyu gri tercih edilir (Material Design guideline).",
                  "tags": ["dark_mode", "colors", "best_practice"]
                }
              ]
            },
            {
              "topicId": 5605,
              "title": "Custom Theme",
              "summary": "Material 3 tema özelleştirilebilir. Custom ColorScheme, Typography ve Shapes tanımlanabilir.",
              "content": "## Custom Theme\n\nCustom ColorScheme oluşturulabilir.\n\nTypography ve Shapes özelleştirilebilir.\n\nBrand identity için kullanılır.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "Custom Theme",
                  "code": "val MyColorScheme = lightColorScheme(\n    primary = Color(0xFF6200EE),\n    secondary = Color(0xFF03DAC6)\n)\n@Composable\nfun MyAppTheme(content: @Composable () -> Unit) {\n    MaterialTheme(colorScheme = MyColorScheme, content = content)\n}",
                  "explanation": "Custom tema oluşturma."
                }
              ],
              "keyPoints": [
                "Custom ColorScheme tanımlama",
                "Typography özelleştirme",
                "Shapes özelleştirme",
                "Brand identity sağlar"
              ],
              "questions": [
                {
                  "questionId": 560501,
                  "question": "Custom Theme neden oluşturulur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece eğlence",
                    "Brand identity, şirket renkleri, unique tasarım için",
                    "Zorunlu",
                    "Hiçbir nedeni yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Custom Theme, brand identity (marka kimliği), şirket renkleri kullanma ve unique tasarım oluşturmak için kullanılır.",
                  "tags": ["custom_theme", "branding"]
                },
                {
                  "questionId": 560502,
                  "question": "Custom ColorScheme nasıl oluşturulur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Otomatik",
                    "lightColorScheme() / darkColorScheme() ile custom renkler tanımlanır",
                    "XML'de",
                    "Oluşturulamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Custom ColorScheme, lightColorScheme() / darkColorScheme() fonksiyonları ile custom primary, secondary, tertiary vb. renkler tanımlanarak oluşturulur.",
                  "tags": ["custom_theme", "colorscheme"]
                },
                {
                  "questionId": 560503,
                  "question": "Material Theme Builder nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Kod editörü",
                    "Google'ın resmi Material 3 tema oluşturma aracı (web tool)",
                    "Android Studio plugin",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Material Theme Builder, Google'ın resmi web aracıdır. Custom ColorScheme oluşturur ve Compose kodunu export eder (m3.material.io/theme-builder).",
                  "tags": ["theme_builder", "tool"]
                },
                {
                  "questionId": 560504,
                  "question": "Custom Typography nasıl tanımlanır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Tanımlanamaz",
                    "Typography() ile custom font, boyut, ağırlık tanımlanır",
                    "Sadece XML",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Custom Typography, Typography() ile oluşturulur. displayLarge, headlineMedium vb. için custom TextStyle (fontFamily, fontSize, fontWeight) tanımlanır.",
                  "tags": ["custom_theme", "typography"]
                },
                {
                  "questionId": 560505,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "@Composable\nfun MyAppTheme(content: @Composable () -> Unit) {\n    MaterialTheme(\n        colorScheme = MyColorScheme,\n        content = content\n    )\n}",
                  "difficulty": "medium",
                  "options": [
                    "Hata verir",
                    "Custom tema wrapper Composable oluşturur",
                    "Sadece renk değiştirir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu, custom tema wrapper Composable'ıdır. Uygulamanın root'unda MyAppTheme { } kullanılarak tüm app custom tema ile sarılır. Best practice pattern'dir.",
                  "tags": ["custom_theme", "wrapper", "example"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 560001,
              "question": "MaterialTheme'den renk, tipografi ve shape'e nasıl erişilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Global değişken",
                "MaterialTheme.colorScheme, MaterialTheme.typography, MaterialTheme.shapes",
                "Sadece parametre",
                "Context üzerinden"
              ],
              "correctAnswerIndex": 1,
              "explanation": "MaterialTheme.colorScheme (renk), MaterialTheme.typography (tipografi), MaterialTheme.shapes (şekil) ile tema değerlerine erişilir. Composable içinde kullanılır.",
              "tags": ["materialtheme", "access"]
            },
            {
              "questionId": 560002,
              "question": "Surface Composable ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece padding",
                "Material container, tema renklerini uygular, elevation sağlar",
                "Sadece layout",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Surface, Material Design container'ıdır. Tema renklerini (background, content color) uygular, elevation (gölge) sağlar ve shape kullanır.",
              "tags": ["surface", "material"]
            },
            {
              "questionId": 560003,
              "question": "contentColor nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece background",
                "Container'ın background'ına uygun içerik rengi (örn: Text rengi)",
                "Sadece border",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "contentColor, container'ın background'ına uygun içerik rengidir (genellikle Text, Icon rengi). Material bileşenleri otomatik olarak doğru contentColor kullanır.",
              "tags": ["contentcolor", "material"]
            },
            {
              "questionId": 560004,
              "question": "Material 3 Icons nasıl kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Sadece drawable",
                "Icon Composable + Icons.Default.* / Icons.Outlined.* / Icons.Filled.*",
                "Sadece asset",
                "Kullanılamaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Material 3 Icons, Icon Composable ile kullanılır. Icons.Default.*, Icons.Outlined.*, Icons.Filled.* ile 1000+ Material icon mevcuttur. androidx.compose.material.icons dependency gerekir.",
              "tags": ["icons", "material3"]
            },
            {
              "questionId": 560005,
              "question": "Scaffold Composable ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece layout",
                "Material app layout yapısı (TopBar, BottomBar, FAB, content)",
                "Sadece padding",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Scaffold, Material app layout yapısını sağlar: TopAppBar, BottomAppBar, FloatingActionButton, Drawer ve content slot'ları. Otomatik padding yönetimi yapar.",
              "tags": ["scaffold", "material", "layout"]
            },
            {
              "questionId": 560006,
              "question": "FloatingActionButton (FAB) ne için kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "easy",
              "options": [
                "Sadece navigation",
                "Primary action (ör: yeni item ekleme) için yuvarlak button",
                "Sadece menu",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "FloatingActionButton (FAB), ekranın primary action'ı (örn: yeni item ekleme, mesaj yazma) için kullanılan prominent, yuvarlak button'dur.",
              "tags": ["fab", "material"]
            },
            {
              "questionId": 560007,
              "question": "TopAppBar (Material 3) kaç variant'a sahiptir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "1",
                "3 (TopAppBar, MediumTopAppBar, LargeTopAppBar)",
                "2",
                "Sadece TopAppBar"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Material 3'te 3 TopAppBar variant vardır: TopAppBar (small), MediumTopAppBar, LargeTopAppBar. Her biri farklı yüksekliğe sahiptir.",
              "tags": ["topappbar", "material3"]
            },
            {
              "questionId": 560008,
              "question": "Material 3'te Snackbar nasıl gösterilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Direkt çağrılır",
                "SnackbarHost + SnackbarHostState kullanılır",
                "Otomatik gösterilir",
                "Gösterilemez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Snackbar, SnackbarHost (Scaffold içinde) + SnackbarHostState ile gösterilir. snackbarHostState.showSnackbar() suspend fonksiyondur.",
              "tags": ["snackbar", "material3"]
            },
            {
              "questionId": 560009,
              "question": "Material 3'te TextField variant'ları nelerdir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadek TextField",
                "TextField (filled) ve OutlinedTextField",
                "Sadece OutlinedTextField",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Material 3'te 2 TextField variant vardır: TextField (filled style, background ile) ve OutlinedTextField (outline border ile).",
              "tags": ["textfield", "material3"]
            },
            {
              "questionId": 560010,
              "question": "Material 3 tema migration stratejisi nasıl olmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hemen tüm app değişmeli",
                "Aşamalı migration: Material 2 ve 3 birlikte kullanılabilir",
                "Migration yapılamaz",
                "Sadece yeni projeler"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Material 2'den 3'e aşamalı migration yapılabilir. Her iki kütüphane de birlikte kullanılabilir (farklı import'lar). Önce tema, sonra bileşenler aşamalı güncellenir.",
              "tags": ["migration", "material3", "strategy"]
            }
          ]
        },
        {
          "sectionId": 5700,
          "sectionTitle": "Advanced UI",
          "sectionDescription": "Compose'da animasyonlar, custom layout, Canvas ile çizim ve gesture yönetimi",
          "order": 7,
          "topics": [
            {
              "topicId": 5701,
              "title": "Animations (animate*AsState, AnimatedVisibility)",
              "summary": "Compose'da animations için animate*AsState, AnimatedVisibility gibi high-level API'lar vardır. Declarative animation sağlar.",
              "content": "## Animations\n\nanimate*AsState: State değişimini animate eder\nAnimatedVisibility: Visibility değişimini animate eder\n\nDeclarative ve kolay kullanım.",
              "difficulty": "medium",
              "order": 1,
              "codeExamples": [
                {
                  "title": "animateFloatAsState Örneği",
                  "code": "val alpha by animateFloatAsState(if (visible) 1f else 0f)\nBox(modifier = Modifier.alpha(alpha))",
                  "explanation": "Visibility değişiminde alpha animasyonu."
                }
              ],
              "keyPoints": [
                "Declarative animation",
                "animate*AsState family",
                "AnimatedVisibility enter/exit",
                "Otomatik interruption handling"
              ],
              "questions": [
                {
                  "questionId": 570101,
                  "question": "animate*AsState ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece state oluşturur",
                    "State değişimini otomatik animate eder (declarative animation)",
                    "Manuel animasyon",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "animate*AsState (animateFloatAsState, animateDpAsState vb.), target state değiştiğinde otomatik olarak mevcut değerden yeni değere animasyon yapar. Declarative animation API'dır.",
                  "tags": ["animation", "animate_as_state"]
                },
                {
                  "questionId": 570102,
                  "question": "AnimatedVisibility ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece visibility değiştirir",
                    "Visibility değişimini enter/exit animasyonu ile yapar",
                    "Sadece fade",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "AnimatedVisibility, Composable'ın görünürlüğünü (visibility) değiştirirken enter ve exit animasyonu yapar. fadeIn, slideIn, expandIn gibi efektler kullanılabilir.",
                  "tags": ["animation", "animatedvisibility"]
                },
                {
                  "questionId": 570103,
                  "question": "Compose animation'ları nasıl çalışır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Manuel frame update",
                    "Declarative: Target state belirtilir, Compose otomatik animate eder",
                    "Sadece XML",
                    "Çalışmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose animation'ları declarative'dir. Target state belirtilir (örn: if (visible) 1f else 0f), Compose otomatik olarak current state'ten target state'e animate eder. Interruption otomatik handle edilir.",
                  "tags": ["animation", "declarative"]
                },
                {
                  "questionId": 570104,
                  "question": "updateTransition ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece state değiştirir",
                    "Birden fazla değeri aynı anda animate etmek için transition oluşturur",
                    "Sadece renk",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "updateTransition, birden fazla değeri (renk, boyut, konum vb.) aynı state değişikliğine bağlı olarak koordine şekilde animate etmek için kullanılır.",
                  "tags": ["animation", "updatetransition"]
                },
                {
                  "questionId": 570105,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "val alpha by animateFloatAsState(if (visible) 1f else 0f)\nBox(modifier = Modifier.alpha(alpha))",
                  "difficulty": "medium",
                  "options": [
                    "Hata verir",
                    "visible değiştiğinde alpha 0-1 arası animate olur (fade in/out)",
                    "Sadece hemen değişir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "visible true olunca alpha 0'dan 1'e, false olunca 1'den 0'a smooth animasyon ile değişir. Fade in/out efekti yaratır.",
                  "tags": ["animation", "example", "alpha"]
                }
              ]
            },
            {
              "topicId": 5702,
              "title": "Custom Layout (Layout Composable)",
              "summary": "Custom Layout ile kendi layout mantığınızı yazabilirsiniz. Measure ve placement'ı kontrol edersiniz.",
              "content": "## Custom Layout\n\nLayout Composable ile custom layout.\n\nMeasure ve placement kontrolü.\n\nPerformance optimizasyonu için kullanılır.",
              "difficulty": "hard",
              "order": 2,
              "codeExamples": [
                {
                  "title": "Custom Layout Örneği",
                  "code": "@Composable\nfun CustomLayout(content: @Composable () -> Unit) {\n    Layout(content) { measurables, constraints ->\n        // measure ve place\n    }\n}",
                  "explanation": "Basit custom layout template."
                }
              ],
              "keyPoints": [
                "Tam layout kontrolü",
                "Measure ve placement",
                "Performance için kullanılır",
                "Advanced use case"
              ],
              "questions": [
                {
                  "questionId": 570201,
                  "question": "Custom Layout ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her zaman",
                    "Row/Column/Box yeterli olmadığında, custom layout mantığı gerektiğinde",
                    "Sadece test için",
                    "Hiçbir zaman"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Custom Layout, Row/Column/Box gibi built-in layout'lar yeterli olmadığında veya custom layout mantığı (özel measure/placement) gerektiğinde kullanılır. Performance optimization için de kullanılabilir.",
                  "tags": ["custom_layout", "use_case"]
                },
                {
                  "questionId": 570202,
                  "question": "Layout Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece UI çizer",
                    "Custom layout oluşturur, measure ve placement kontrolü sağlar",
                    "Sadece modifier",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Layout Composable, custom layout oluşturmak için kullanılır. measurables (child'lar) ve constraints alır, her child'ı measure eder ve place eder.",
                  "tags": ["layout", "composable"]
                },
                {
                  "questionId": 570203,
                  "question": "Measure ve Placement nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece boyut",
                    "Measure: Child boyutunu belirleme, Placement: Child'ı konumlandırma",
                    "Sadece konum",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Measure: Child Composable'ın boyutunu (width, height) belirleme. Placement: Child'ı parent içinde konumlandırma (x, y koordinatı). Layout'un iki temel aşamasıdır.",
                  "tags": ["measure", "placement", "layout"]
                },
                {
                  "questionId": 570204,
                  "question": "Custom Layout performans açısından ne sağlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir şey",
                    "Gereksiz recomposition ve measure'ı önleyerek optimize layout",
                    "Sadece görsel",
                    "Her zaman yavaşlatır"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "İyi yazılmış Custom Layout, gereksiz recomposition ve measure'ı önleyerek performans optimizasyonu sağlayabilir. Özellikle complex nested layout yerine tek custom layout kullanmak faydalıdır.",
                  "tags": ["custom_layout", "performance"]
                }
              ]
            },
            {
              "topicId": 5703,
              "title": "Canvas & Drawing",
              "summary": "Canvas ile custom çizim yapılır. Shape, path, text çizme gibi low-level drawing API'ları sunar.",
              "content": "## Canvas & Drawing\n\nCanvas Composable low-level drawing.\n\ndrawLine, drawCircle, drawPath vb.\n\nCustom grafik ve chart için kullanılır.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "Canvas Örneği",
                  "code": "Canvas(modifier = Modifier.size(100.dp)) {\n    drawCircle(color = Color.Red, radius = 50f)\n}",
                  "explanation": "Kırmızı daire çizme."
                }
              ],
              "keyPoints": [
                "Low-level drawing API",
                "Custom shape çizimi",
                "Chart ve grafik için",
                "DrawScope kullanır"
              ],
              "questions": [
                {
                  "questionId": 570301,
                  "question": "Canvas Composable ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece layout",
                    "Low-level drawing API, custom çizim (shape, path, text)",
                    "Sadece image gösterir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Canvas, low-level drawing API sağlar. drawCircle, drawRect, drawLine, drawPath gibi fonksiyonlarla custom çizim yapılır.",
                  "tags": ["canvas", "drawing"]
                },
                {
                  "questionId": 570302,
                  "question": "DrawScope nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece state",
                    "Canvas içinde drawing yapılan scope, draw* fonksiyonları sunar",
                    "Layout scope",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "DrawScope, Canvas lambda içinde kullanılan scope'tur. drawCircle, drawRect, drawPath gibi drawing fonksiyonları ve size, center gibi property'ler sunar.",
                  "tags": ["drawscope", "canvas"]
                },
                {
                  "questionId": 570303,
                  "question": "Canvas ne için kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece text",
                    "Custom grafik, chart, drawing, game rendering",
                    "Sadece layout",
                    "Hiçbir şey için"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Canvas, custom grafik çizimi, chart ve graph oluşturma, drawing app, game rendering gibi low-level çizim gerektiren use case'ler için kullanılır.",
                  "tags": ["canvas", "use_case"]
                },
                {
                  "questionId": 570304,
                  "question": "drawPath() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece çizgi",
                    "Karmaşık shape'ler çizmek için path (bezier curve, arc vb.)",
                    "Sadece dikdörtgen",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "drawPath(), karmaşık shape'ler çizmek için Path kullanır. moveTo, lineTo, cubicTo (bezier curve), arcTo gibi komutlarla custom shape oluşturulur.",
                  "tags": ["canvas", "drawpath"]
                },
                {
                  "questionId": 570305,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "Canvas(modifier = Modifier.size(100.dp)) {\n    drawCircle(color = Color.Red, radius = 50f)\n}",
                  "difficulty": "easy",
                  "options": [
                    "Hata verir",
                    "100dp boyutunda canvas'ta kırmızı daire çizer",
                    "Sadece layout oluşturur",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, 100dp×100dp boyutunda bir Canvas içinde 50f radius'lu kırmızı daire çizer.",
                  "tags": ["canvas", "example", "circle"]
                }
              ]
            },
            {
              "topicId": 5704,
              "title": "Gestures (clickable, draggable, swipeable)",
              "summary": "Compose'da gesture detection için Modifier.clickable, draggable, swipeable gibi API'lar vardır.",
              "content": "## Gestures\n\nModifier.clickable: Tıklama\nModifier.draggable: Sürükleme\nModifier.swipeable: Swipe\n\npointerInput ile custom gesture.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "Draggable Örneği",
                  "code": "var offsetX by remember { mutableStateOf(0f) }\nBox(\n    modifier = Modifier.draggable(\n        state = rememberDraggableState { offsetX += it },\n        orientation = Orientation.Horizontal\n    )\n)",
                  "explanation": "Yatay sürüklenebilir Box."
                }
              ],
              "keyPoints": [
                "Touch event handling",
                "clickable, draggable, swipeable",
                "pointerInput custom gesture",
                "Multi-touch desteği"
              ],
              "questions": [
                {
                  "questionId": 570401,
                  "question": "Modifier.clickable() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "easy",
                  "options": [
                    "Sadece görsel",
                    "Composable'ı tıklanabilir yapar, ripple effect ekler",
                    "Sadece layout",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier.clickable(), Composable'ı tıklanabilir yapar. onClick lambda alır ve Material ripple effect otomatik ekler.",
                  "tags": ["gesture", "clickable"]
                },
                {
                  "questionId": 570402,
                  "question": "Modifier.draggable() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece tıklama",
                    "Tek yönde (horizontal/vertical) sürüklenebilir yapar",
                    "Multi-directional sürükleme",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Modifier.draggable(), tek yönde (Orientation.Horizontal veya Vertical) sürüklenebilir yapar. DraggableState ile offset alınır.",
                  "tags": ["gesture", "draggable"]
                },
                {
                  "questionId": 570403,
                  "question": "pointerInput ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece clickable",
                    "Custom gesture detection, low-level touch event handling",
                    "Sadece drag",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "pointerInput, custom gesture detection için low-level touch event handling sağlar. detectTapGestures, detectDragGestures, detectTransformGestures gibi helper'lar vardır.",
                  "tags": ["gesture", "pointerinput"]
                },
                {
                  "questionId": 570404,
                  "question": "detectTransformGestures ne sağlar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece tıklama",
                    "Pan, zoom, rotate gesture detection (multi-touch)",
                    "Sadece drag",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "detectTransformGestures (pointerInput içinde), pan (kaydırma), zoom (pinch), rotate gesture'larını detect eder. Multi-touch için kullanılır.",
                  "tags": ["gesture", "transform", "multi_touch"]
                },
                {
                  "questionId": 570405,
                  "question": "Aşağıdaki kod ne yapar?",
                  "questionType": "multiple_choice",
                  "code": "var offsetX by remember { mutableStateOf(0f) }\nBox(\n    modifier = Modifier.draggable(\n        state = rememberDraggableState { offsetX += it },\n        orientation = Orientation.Horizontal\n    )\n)",
                  "difficulty": "medium",
                  "options": [
                    "Hata verir",
                    "Yatay sürüklenebilir Box, offsetX güncellenir",
                    "Sadece tıklanabilir",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu kod, Box'ı yatay sürüklenebilir yapar. Sürükleme sırasında delta (it) offsetX'e eklenir. offsetX ile Box'ın konumu güncellenebilir.",
                  "tags": ["gesture", "draggable", "example"]
                }
              ]
            },
            {
              "topicId": 5705,
              "title": "ConstraintLayout Compose",
              "summary": "ConstraintLayout, Compose'da complex layout'lar için kullanılır. XML ConstraintLayout'un Compose versiyonudur.",
              "content": "## ConstraintLayout Compose\n\nComplex layout için kullanılır.\n\nRow/Column/Box yeterli değilse.\n\nandroidx.constraintlayout:constraintlayout-compose",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "ConstraintLayout Basit Örnek",
                  "code": "ConstraintLayout {\n    val (button, text) = createRefs()\n    Button(modifier = Modifier.constrainAs(button) { })\n    Text(modifier = Modifier.constrainAs(text) { })\n}",
                  "explanation": "Constraint ile layout."
                }
              ],
              "keyPoints": [
                "Complex layout için",
                "Constraint ilişkileri",
                "createRefs() ile referans",
                "Chain, barrier, guideline desteği"
              ],
              "questions": [
                {
                  "questionId": 570501,
                  "question": "ConstraintLayout Compose ne zaman kullanılır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Her zaman",
                    "Complex layout, Row/Column/Box yeterli olmadığında",
                    "Sadece basit layout",
                    "Hiçbir zaman"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout, complex layout'lar için kullanılır. Çoğu durumda Row/Column/Box yeterlidir ama karmaşık constraint ilişkileri gerektiğinde ConstraintLayout tercih edilir.",
                  "tags": ["constraintlayout", "use_case"]
                },
                {
                  "questionId": 570502,
                  "question": "ConstraintLayout'ta createRefs() ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece state",
                    "Child Composable'lara referans oluşturur (constraint tanımlama için)",
                    "Layout oluşturur",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "createRefs(), child Composable'lara referans oluşturur. Bu referanslar ile constraint'ler (top, start, end, bottom) tanımlanır.",
                  "tags": ["constraintlayout", "createrefs"]
                },
                {
                  "questionId": 570503,
                  "question": "ConstraintLayout Compose hangi dependency'den gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "androidx.compose.ui",
                    "androidx.constraintlayout:constraintlayout-compose",
                    "androidx.compose.foundation",
                    "Built-in"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "ConstraintLayout Compose, androidx.constraintlayout:constraintlayout-compose dependency'sinden gelir. Ayrı kütüphane olarak eklenir.",
                  "tags": ["constraintlayout", "dependency"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 570001,
              "question": "Compose animation interruption nasıl handle edilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Manuel handling gerekir",
                "Otomatik handle edilir, yeni target'a smooth geçiş yapar",
                "Crash olur",
                "Animasyon durur"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose animation'ları interruption'ı otomatik handle eder. Animasyon sırasında target state değişirse, current state'ten yeni target'a smooth geçiş yapar.",
              "tags": ["animation", "interruption"]
            },
            {
              "questionId": 570002,
              "question": "animationSpec ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece duration",
                "Animation'ın timing, easing, duration vb. özelliklerini belirler",
                "Sadece renk",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "animationSpec, animation'ın timing curve (easing), duration, delay gibi özelliklerini belirler. tween, spring, keyframes gibi spec'ler vardır.",
              "tags": ["animation", "animationspec"]
            },
            {
              "questionId": 570003,
              "question": "Modifier.offset() ve Modifier.graphicsLayer() farkı nedir (animation için)?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "graphicsLayer GPU accelerated, performanslı; offset layout phase'de çalışır",
                "offset daha hızlı",
                "Aynı şey"
              ],
              "correctAnswerIndex": 1,
              "explanation": "graphicsLayer, GPU accelerated ve performanslıdır, layout phase'i tekrarlatmaz (translation, rotation, scale için). offset ise layout phase'de çalışır, daha yavaştır. Animation için graphicsLayer tercih edilir.",
              "tags": ["animation", "performance", "graphicslayer"]
            },
            {
              "questionId": 570004,
              "question": "InfiniteTransition ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece bir kez",
                "Sonsuz döngüde çalışan animation (loading indicator vb.)",
                "Hiçbir şey yapmaz",
                "Sadece test"
              ],
              "correctAnswerIndex": 1,
              "explanation": "InfiniteTransition (rememberInfiniteTransition), sonsuz döngüde çalışan animation için kullanılır. Loading indicator, pulse effect gibi durumlarda kullanılır.",
              "tags": ["animation", "infinite"]
            },
            {
              "questionId": 570005,
              "question": "Modifier.semantics ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece görsel",
                "Accessibility ve test için semantic bilgi ekler",
                "Layout için",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.semantics, accessibility (TalkBack) ve test için semantic bilgi ekler. contentDescription, role, state gibi bilgiler tanımlanır.",
              "tags": ["accessibility", "semantics", "testing"]
            },
            {
              "questionId": 570006,
              "question": "Compose'da blur effect nasıl eklenir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Eklenemez",
                "Modifier.blur() (Android 12+)",
                "Sadece Canvas",
                "Sadece Image"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.blur() ile blur effect eklenir (Android 12+). radiusX, radiusY parametreleri alır.",
              "tags": ["effect", "blur"]
            },
            {
              "questionId": 570007,
              "question": "SubcomposeLayout ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece layout",
                "Child'ları measure ettikten sonra başka child'lar ekleyebilme (dynamic composition)",
                "Sadece state",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "SubcomposeLayout, child'ları measure ettikten sonra sonuca göre başka child'lar ekleyebilme (dynamic composition) sağlar. Advanced use case'ler için kullanılır.",
              "tags": ["layout", "subcompose"]
            },
            {
              "questionId": 570008,
              "question": "Modifier.zIndex() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece boyut",
                "Child'ların çizim sırasını (z-order) belirler",
                "Sadece layout",
                "Hiçbir şey yapmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.zIndex(), child'ların çizim sırasını (z-order) belirler. Yüksek zIndex önde çizilir. Box içinde overlap durumlarda kullanılır.",
              "tags": ["layout", "zindex"]
            },
            {
              "questionId": 570009,
              "question": "Modifier.border() ve Modifier.drawBehind() farkı nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir fark yok",
                "border high-level API, drawBehind low-level custom drawing",
                "Aynı şey",
                "border daha yavaş"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.border() high-level border API'dir. Modifier.drawBehind() ise low-level custom drawing yapmak için kullanılır (DrawScope ile).",
              "tags": ["drawing", "border", "drawbehind"]
            },
            {
              "questionId": 570010,
              "question": "Compose'da performanslı shadow ekleme yolu nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece drawBehind",
                "Modifier.shadow() (GPU accelerated)",
                "Sadece Canvas",
                "Shadow eklenemez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.shadow(), GPU accelerated shadow ekler. elevation ve shape parametreleri alır. drawBehind ile de shadow çizilebilir ama shadow() daha performanslıdır.",
              "tags": ["shadow", "performance"]
            }
          ]
        },
        {
          "sectionId": 5800,
          "sectionTitle": "Compose Architecture & Best Practices",
          "sectionDescription": "Compose'da mimari pattern'ler, performans optimizasyonu ve best practice'ler",
          "order": 8,
          "topics": [
            {
              "topicId": 5801,
              "title": "Unidirectional Data Flow (UDF)",
              "summary": "UDF, state'in yukarıdan aşağı (↓), event'lerin aşağıdan yukarı (↑) tek yönlü akışını sağlar. Compose'un temel prensibidir.",
              "content": "## Unidirectional Data Flow\n\nState yukarıdan aşağı iner (parent → child)\nEvent aşağıdan yukarı çıkar (child → parent)\n\nPredictable ve maintainable kod sağlar.",
              "difficulty": "hard",
              "order": 1,
              "codeExamples": [
                {
                  "title": "UDF Örneği",
                  "code": "@Composable\nfun Screen(state: UiState, onEvent: (Event) -> Unit) {\n    // State aşağı, Event yukarı\n}",
                  "explanation": "UDF pattern ile Composable."
                }
              ],
              "keyPoints": [
                "State aşağı iner (↓)",
                "Event yukarı çıkar (↑)",
                "Single source of truth",
                "Predictable state management"
              ],
              "questions": [
                {
                  "questionId": 580101,
                  "question": "Unidirectional Data Flow (UDF) nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Çift yönlü data akışı",
                    "State yukarıdan aşağı (↓), Event aşağıdan yukarı (↑) tek yönlü akış",
                    "Sadece state akışı",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UDF, state'in parent'tan child'a aşağı indiği (↓), event'lerin child'dan parent'a yukarı çıktığı (↑) tek yönlü veri akışıdır. Compose'un temel prensibidir.",
                  "tags": ["udf", "architecture"]
                },
                {
                  "questionId": 580102,
                  "question": "UDF'nin avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha hızlı",
                    "Predictable state, kolay debug, testable, single source of truth",
                    "Sadece daha az kod",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UDF avantajları: Predictable state management, kolay debug (state flow takip edilebilir), test edilebilir, single source of truth.",
                  "tags": ["udf", "advantages"]
                },
                {
                  "questionId": 580103,
                  "question": "UDF'de state nereden gelir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Child'dan",
                    "Parent'tan (ViewModel veya parent Composable)",
                    "Global state",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UDF'de state, parent'tan (genellikle ViewModel veya parent Composable) child'a parametre olarak gelir. Child state değiştiremez, sadece event gönderir.",
                  "tags": ["udf", "state"]
                },
                {
                  "questionId": 580104,
                  "question": "UDF'de event nasıl handle edilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Child direkt state değiştirir",
                    "Child event gönderir (callback), parent state günceller",
                    "Event gönderilmez",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UDF'de child, event gönderir (lambda callback ile). Parent bu event'i handle eder ve state'i günceller. Güncellenmiş state tekrar child'a iner.",
                  "tags": ["udf", "event"]
                },
                {
                  "questionId": 580105,
                  "question": "Aşağıdaki kod UDF'yi doğru uygular mı?",
                  "questionType": "multiple_choice",
                  "code": "@Composable\nfun Screen(state: UiState, onEvent: (Event) -> Unit) {\n    Button(onClick = { onEvent(Event.Click) })\n}",
                  "difficulty": "medium",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, state aşağı, event yukarı gidiyor",
                    "State eksik",
                    "Event yanlış"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru UDF pattern'idir. state parametre olarak geliyor (↓), event onEvent callback ile yukarı gönderiliyor (↑).",
                  "tags": ["udf", "example"]
                }
              ]
            },
            {
              "topicId": 5802,
              "title": "UI State Pattern",
              "summary": "UI State Pattern, tüm UI state'ini tek bir data class'ta toplar. Loading, Error, Success state'lerini yönetir.",
              "content": "## UI State Pattern\n\nTüm UI state tek data class:\ndata class UiState(loading, error, data)\n\nSingle source of truth sağlar.",
              "difficulty": "medium",
              "order": 2,
              "codeExamples": [
                {
                  "title": "UI State Örneği",
                  "code": "data class UiState(\n    val isLoading: Boolean = false,\n    val error: String? = null,\n    val data: List<Item> = emptyList()\n)",
                  "explanation": "UI State pattern."
                }
              ],
              "keyPoints": [
                "Tek data class tüm state",
                "Loading, Error, Success",
                "Single source of truth",
                "Kolayca test edilebilir"
              ],
              "questions": [
                {
                  "questionId": 580201,
                  "question": "UI State Pattern nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Birden fazla state değişkeni",
                    "Tüm UI state'ini tek bir data class'ta toplama",
                    "Sadece loading state",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UI State Pattern, tüm UI state'ini (loading, error, data vb.) tek bir data class'ta toplar. Single source of truth ve kolayca yönetilebilir state sağlar.",
                  "tags": ["ui_state", "pattern"]
                },
                {
                  "questionId": 580202,
                  "question": "UI State Pattern'in avantajları nelerdir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece daha az kod",
                    "Single source of truth, kolay test, snapshot alınabilir, time-travel debug",
                    "Sadece performans",
                    "Hiçbir avantajı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "UI State Pattern avantajları: Single source of truth, kolay test (state'in snapshot'ı alınır), state history tutulabilir (time-travel debug), consistent UI.",
                  "tags": ["ui_state", "advantages"]
                },
                {
                  "questionId": 580203,
                  "question": "Loading, Error, Success state'leri nasıl yönetilir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Ayrı değişkenler",
                    "Tek UiState data class içinde (isLoading, error, data)",
                    "Sadece data",
                    "Yönetilmez"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Loading, Error, Success state'leri tek UiState data class içinde yönetilir: data class UiState(isLoading, error, data). UI bu state'e göre render edilir.",
                  "tags": ["ui_state", "loading_error_success"]
                },
                {
                  "questionId": 580204,
                  "question": "Aşağıdaki UI State Pattern doğru mu?",
                  "questionType": "multiple_choice",
                  "code": "data class UiState(\n    val isLoading: Boolean = false,\n    val error: String? = null,\n    val data: List<Item> = emptyList()\n)",
                  "difficulty": "easy",
                  "options": [
                    "Hayır, hatalı",
                    "Evet, doğru UI State pattern",
                    "Default değerler gereksiz",
                    "data nullable olmalı"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Bu doğru UI State pattern'idir. isLoading (loading state), error (error message), data (success data) tek data class'ta. Default değerler initial state'i sağlar.",
                  "tags": ["ui_state", "example"]
                }
              ]
            },
            {
              "topicId": 5803,
              "title": "Compose + MVVM/MVI",
              "summary": "Compose, MVVM ve MVI pattern'leri ile mükemmel uyum sağlar. ViewModel, StateFlow/State ile UI katmanını besler.",
              "content": "## MVVM/MVI ile Compose\n\nMVVM: Model-View-ViewModel\nMVI: Model-View-Intent\n\nHer ikisi de Compose ile uyumlu.",
              "difficulty": "hard",
              "order": 3,
              "codeExamples": [
                {
                  "title": "MVVM Örneği",
                  "code": "@Composable\nfun Screen(viewModel: MyViewModel = viewModel()) {\n    val state by viewModel.uiState.collectAsState()\n    // UI based on state\n}",
                  "explanation": "MVVM pattern ile Compose."
                }
              ],
              "keyPoints": [
                "MVVM ve MVI uyumlu",
                "ViewModel + StateFlow",
                "UDF prensibi",
                "Separation of concerns"
              ],
              "questions": [
                {
                  "questionId": 580301,
                  "question": "MVVM pattern'de ViewModel'in görevi nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "UI çizer",
                    "Business logic ve UI state yönetir, View'dan bağımsızdır",
                    "Sadece navigation",
                    "Database yönetir"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MVVM'de ViewModel, business logic ve UI state'i yönetir. View (Composable)'dan bağımsızdır, configuration change'de hayatta kalır.",
                  "tags": ["mvvm", "viewmodel"]
                },
                {
                  "questionId": 580302,
                  "question": "MVI pattern'de Intent nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Android Intent",
                    "User action/event (örn: ButtonClicked, TextChanged)",
                    "Sadece navigation",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "MVI'da Intent, user action/event'tir (örn: ButtonClicked, TextChanged). ViewModel Intent alır, state günceller. Compose'da event callback'leri Intent olarak kullanılır.",
                  "tags": ["mvi", "intent"]
                },
                {
                  "questionId": 580303,
                  "question": "Compose hangi pattern'lerle uyumludur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece MVVM",
                    "MVVM, MVI, MVP gibi birçok pattern ile uyumlu",
                    "Sadece MVI",
                    "Pattern kullanılamaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose, MVVM, MVI, MVP, Clean Architecture gibi birçok pattern ile uyumludur. Declarative nature sayesinde farklı architecture'larla kolayca entegre olur.",
                  "tags": ["compose", "patterns", "architecture"]
                },
                {
                  "questionId": 580304,
                  "question": "MVVM + Compose'da data binding gerekir mi?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Evet, şart",
                    "Hayır, Compose zaten reactive (StateFlow.collectAsState)",
                    "Sadece XML'de",
                    "Her zaman"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Compose'da XML Data Binding gerekmez. Compose zaten reactive'dir. StateFlow.collectAsState() ile state değiştiğinde UI otomatik güncellenir.",
                  "tags": ["mvvm", "compose", "data_binding"]
                }
              ]
            },
            {
              "topicId": 5804,
              "title": "Recomposition & Performance",
              "summary": "Recomposition optimizasyonu için stable types, remember, derivedStateOf, key kullanılır. Gereksiz recomposition önlenir.",
              "content": "## Recomposition Optimization\n\nStable types kullan\nremember, derivedStateOf\nkey ile liste optimization\n\nPerformans için kritik.",
              "difficulty": "hard",
              "order": 4,
              "codeExamples": [
                {
                  "title": "key ile Optimization",
                  "code": "LazyColumn {\n    items(list, key = { it.id }) { item ->\n        ItemRow(item)\n    }\n}",
                  "explanation": "key ile recomposition optimizasyonu."
                }
              ],
              "keyPoints": [
                "Stable types önemli",
                "remember ile hesaplama cache",
                "key ile liste optimization",
                "Gereksiz recomposition önle"
              ],
              "questions": [
                {
                  "questionId": 580401,
                  "question": "Stable type nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Değişmeyen tip",
                    "Compose'un equals() ile değişikliği tespit edebildiği tip",
                    "Sadece immutable",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Stable type, Compose'un equals() ile değişikliği tespit edebildiği tiptir. Primitive types, String, immutable data class'lar stable'dır. Stable type, smart recomposition sağlar.",
                  "tags": ["recomposition", "stable_type"]
                },
                {
                  "questionId": 580402,
                  "question": "remember ile hesaplama neden cache'lenir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Sadece görsel",
                    "Her recomposition'da tekrar hesaplama önlenir, performance artar",
                    "Zorunlu",
                    "Hiçbir nedeni yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "remember, hesaplamayı cache'ler. Her recomposition'da tekrar hesaplama yapılmaz (pahalı işlem varsa önemli), bu da performance artışı sağlar.",
                  "tags": ["remember", "performance", "cache"]
                },
                {
                  "questionId": 580403,
                  "question": "LazyColumn'da key kullanmanın amacı nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece görsel",
                    "Item'ları unique tanımlar, recomposition ve reorder optimizasyonu",
                    "Zorunludur",
                    "Hiçbir amacı yok"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "key, her item'ı unique tanımlar. Liste değiştiğinde (ekleme, silme, reorder) Compose hangi item'ın değiştiğini bilir, gereksiz recomposition önler. Performance kritik.",
                  "tags": ["lazycolumn", "key", "performance"]
                },
                {
                  "questionId": 580404,
                  "question": "@Stable annotation ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Hiçbir şey yapmaz",
                    "Compose'a bir type'ın stable olduğunu bildirir (manual hint)",
                    "Sadece görsel",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "@Stable annotation, Compose compiler'a bir type'ın stable olduğunu manuel olarak bildirir. Compose otomatik tespit edemediği durumlarda kullanılır.",
                  "tags": ["stable", "annotation", "performance"]
                },
                {
                  "questionId": 580405,
                  "question": "Recomposition scope nedir?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Tüm UI recompose olur",
                    "Sadece değişen state'i kullanan en küçük Composable scope recompose olur",
                    "Sadece parent",
                    "Hiçbiri"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Recomposition scope: Sadece değişen state'i kullanan en küçük Composable scope recompose olur (smart recomposition). Tüm UI yeniden çizilmez, performans optimizasyonudur.",
                  "tags": ["recomposition", "scope", "performance"]
                }
              ]
            },
            {
              "topicId": 5805,
              "title": "CompositionLocal",
              "summary": "CompositionLocal, implicit dependency injection sağlar. Theme, context gibi değerleri composition tree'de paylaşır.",
              "content": "## CompositionLocal\n\nImplicit dependency injection\nTree boyunca değer paylaşma\n\nLocalContext, LocalConfiguration vb.",
              "difficulty": "hard",
              "order": 5,
              "codeExamples": [
                {
                  "title": "CompositionLocal Kullanımı",
                  "code": "val context = LocalContext.current\nval configuration = LocalConfiguration.current",
                  "explanation": "Built-in CompositionLocal kullanımı."
                }
              ],
              "keyPoints": [
                "Implicit dependency injection",
                "Tree-wide value sharing",
                "Built-in: LocalContext vb.",
                "Custom CompositionLocal oluşturulabilir"
              ],
              "questions": [
                {
                  "questionId": 580501,
                  "question": "CompositionLocal ne işe yarar?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Sadece state",
                    "Implicit dependency injection, composition tree boyunca değer paylaşma",
                    "Sadece theme",
                    "Hiçbir şey yapmaz"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "CompositionLocal, implicit dependency injection sağlar. Değer composition tree'de (parent'tan child'lara) otomatik olarak iletilir, her Composable'a parametre geçmek gerekmez.",
                  "tags": ["compositionlocal", "dependency_injection"]
                },
                {
                  "questionId": 580502,
                  "question": "LocalContext.current ne döner?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "medium",
                  "options": [
                    "Application Context",
                    "Current composition'ın Context'i",
                    "Null",
                    "Activity"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "LocalContext.current, mevcut composition'ın Context'ini döner. Composable içinde Context'e erişmek için kullanılır.",
                  "tags": ["compositionlocal", "localcontext"]
                },
                {
                  "questionId": 580503,
                  "question": "Custom CompositionLocal nasıl oluşturulur?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Oluşturulamaz",
                    "compositionLocalOf() veya staticCompositionLocalOf() ile",
                    "Sadece built-in",
                    "Otomatik"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "Custom CompositionLocal, compositionLocalOf() (dynamic) veya staticCompositionLocalOf() (static) ile oluşturulur. CompositionLocalProvider ile değer sağlanır.",
                  "tags": ["compositionlocal", "custom"]
                },
                {
                  "questionId": 580504,
                  "question": "CompositionLocal ne zaman kullanılmalıdır?",
                  "questionType": "multiple_choice",
                  "code": null,
                  "difficulty": "hard",
                  "options": [
                    "Her zaman",
                    "Tree-wide shared değerler için (theme, context, configuration), dikkatli kullanılmalı",
                    "Hiçbir zaman",
                    "Sadece theme"
                  ],
                  "correctAnswerIndex": 1,
                  "explanation": "CompositionLocal, tree-wide shared değerler için (theme, context, configuration) kullanılmalıdır. Overuse edilmemeli, explicit parameter passing tercih edilmeli (testability için).",
                  "tags": ["compositionlocal", "best_practice"]
                }
              ]
            }
          ],
          "sectionMixedQuestions": [
            {
              "questionId": 580001,
              "question": "Side-effect free Composable nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Her zaman side-effect var",
                "Aynı input'ta her zaman aynı output, side-effect yok (idempotent)",
                "Sadece pure function",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Side-effect free Composable, aynı input'ta her zaman aynı output üretir, dış dünyayı etkilemez (idempotent). Recomposition safe'dir. LaunchedEffect gibi API'larla side-effect kontrollü yapılır.",
              "tags": ["composable", "side_effect", "best_practice"]
            },
            {
              "questionId": 580002,
              "question": "Compose'da dependency injection için hangi yaklaşım tercih edilir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "CompositionLocal her yerde",
                "Hilt (constructor injection) + explicit parameters, CompositionLocal dikkatli",
                "Sadece global state",
                "DI kullanılmaz"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Best practice: Hilt ile ViewModel'e constructor injection + Composable'lara explicit parameter passing. CompositionLocal sadece tree-wide shared değerler için (theme, context). Testability için önemli.",
              "tags": ["dependency_injection", "best_practice"]
            },
            {
              "questionId": 580003,
              "question": "Composable naming convention nedir?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "camelCase",
                "PascalCase (Capital letter ile başlar)",
                "snake_case",
                "Fark etmez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Composable fonksiyonlar PascalCase ile (Capital letter ile başlayarak) isimlendirilir. Bu, UI bileşeni olduğunu gösterir ve Kotlin convention'ıdır.",
              "tags": ["naming", "convention"]
            },
            {
              "questionId": 580004,
              "question": "Stateless vs Stateful Composable tercihi nasıl olmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Her zaman stateful",
                "Stateless tercih edilir (reusable, testable), stateful wrapper pattern",
                "Her zaman stateless",
                "Fark etmez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Best practice: Stateless Composable tercih edilir (reusable, testable). Stateful wrapper pattern kullanılır: stateful wrapper, internal state'i yönetir ve stateless Composable'ı çağırır.",
              "tags": ["stateless", "stateful", "best_practice"]
            },
            {
              "questionId": 580005,
              "question": "@Preview Composable production kodunda kullanılabilir mi?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, sorun yok",
                "Hayır, @Preview sadece preview için, production Composable ayrı olmalı",
                "Her zaman kullanılmalı",
                "Fark etmez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Best practice: @Preview fonksiyonu sadece preview için olmalı, production Composable'ı çağırmalı. Preview fonksiyonu production'da çağrılmamalı (hardcoded data içerir).",
              "tags": ["preview", "best_practice"]
            },
            {
              "questionId": 580006,
              "question": "Compose'da ViewBinding kullanılmalı mı?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Evet, her zaman",
                "Hayır, Compose'da ViewBinding gerekmez (findViewById de yok)",
                "Zorunlu",
                "Sadece Activity'de"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose'da ViewBinding gerekmez. XML kullanılmaz, findViewById yoktur. State ile direkt erişim vardır.",
              "tags": ["viewbinding", "compose"]
            },
            {
              "questionId": 580007,
              "question": "Modifier.then() ne işe yarar?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey yapmaz",
                "Conditional modifier eklemek için (if/else ile modifier chain)",
                "Sadece animasyon",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Modifier.then(), conditional modifier eklemek için kullanılır: Modifier.then(if (condition) Modifier.padding(16.dp) else Modifier). Modifier chain'de conditional logic sağlar.",
              "tags": ["modifier", "then", "conditional"]
            },
            {
              "questionId": 580008,
              "question": "Compose'da memory leak'ten kaçınmak için ne yapılmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Hiçbir şey gerekmez",
                "Lifecycle-aware scope (viewModelScope, lifecycleScope), DisposableEffect cleanup",
                "Sadece remember",
                "Global state kullan"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Memory leak önlemek için: Lifecycle-aware scope kullan (viewModelScope, lifecycleScope), DisposableEffect ile cleanup yap, CompositionLocal overuse etme, ViewModel'de Context tutma.",
              "tags": ["memory_leak", "best_practice"]
            },
            {
              "questionId": 580009,
              "question": "Compose performance profiling için hangi tool kullanılır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "medium",
              "options": [
                "Sadece log",
                "Android Studio Layout Inspector, Recomposition Count overlay",
                "Sadece emülatör",
                "Hiçbiri"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Compose performance profiling için: Android Studio Layout Inspector (recomposition count, composition tree), Recomposition Count overlay (developer options), Systrace kullanılır.",
              "tags": ["performance", "profiling", "tools"]
            },
            {
              "questionId": 580010,
              "question": "Production Compose app checklist'inde ne olmalıdır?",
              "questionType": "multiple_choice",
              "code": null,
              "difficulty": "hard",
              "options": [
                "Sadece kod yaz",
                "ProGuard/R8, performance test, accessibility, dark mode, memory leak check",
                "Sadece test",
                "Hiçbir şey gerekmez"
              ],
              "correctAnswerIndex": 1,
              "explanation": "Production checklist: ProGuard/R8 enable, performance test (recomposition), accessibility (contentDescription, semantics), dark mode support, memory leak check, large screen support.",
              "tags": ["production", "checklist", "best_practice"]
            }
          ]
        }
      ],
      "interviewQuestions": [
        {
          "questionId": 590001,
          "question": "@Composable fonksiyon nedir ve nasıl çalışır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Normal fonksiyon",
            "UI bileşeni oluşturan, Compose compiler tarafından özel işlenen fonksiyon",
            "Sadece annotation",
            "Hiçbiri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "@Composable, fonksiyonu UI bileşeni yapar. Compose compiler bu fonksiyonları özel şekilde işler, recomposition mekanizmasını ekler. Sadece başka @Composable içinden çağrılabilir.",
          "tags": ["composable", "fundamentals"]
        },
        {
          "questionId": 590002,
          "question": "Recomposition nedir ve ne zaman tetiklenir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "İlk composition",
            "State değiştiğinde Composable'ın yeniden çizilmesi",
            "Activity restart",
            "Manuel çağrı"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Recomposition, state değiştiğinde Compose'un o state'i kullanan Composable'ları yeniden çizmesidir. Smart recomposition ile sadece değişen state'i kullanan en küçük scope recompose olur.",
          "tags": ["recomposition", "state"]
        },
        {
          "questionId": 590003,
          "question": "remember ve rememberSaveable arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Hiçbir fark yok",
            "rememberSaveable configuration change'lerde korur, remember korumaz",
            "remember daha güçlü",
            "rememberSaveable kullanımdan kalkmış"
          ],
          "correctAnswerIndex": 1,
          "explanation": "remember sadece recomposition'da korur. rememberSaveable, configuration change (ekran döndürme) ve process death'de state'i korur (Bundle'a kaydeder).",
          "tags": ["remember", "remembersaveable", "state"]
        },
        {
          "questionId": 590004,
          "question": "State Hoisting nedir ve neden önemlidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "State silme",
            "State'i child'dan parent'a taşıyarak stateless, reusable Composable oluşturma",
            "State oluşturma",
            "Hiçbiri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "State Hoisting, state'i child'dan parent'a taşıyarak child'ı stateless ve reusable yapar. Unidirectional Data Flow, testability ve single source of truth sağlar.",
          "tags": ["state_hoisting", "architecture"]
        },
        {
          "questionId": 590005,
          "question": "LaunchedEffect ve DisposableEffect arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiçbir fark yok",
            "LaunchedEffect coroutine başlatır, DisposableEffect cleanup gerektiğinde kullanılır",
            "Aynı şey",
            "LaunchedEffect deprecated"
          ],
          "correctAnswerIndex": 1,
          "explanation": "LaunchedEffect, coroutine başlatır ve side-effect yapar. DisposableEffect, cleanup gerektiren side-effect'ler için kullanılır (listener add/remove). onDispose bloğu cleanup yapar.",
          "tags": ["side_effect", "launchedeffect", "disposableeffect"]
        },
        {
          "questionId": 590006,
          "question": "collectAsState ve collectAsStateWithLifecycle arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiçbir fark yok",
            "collectAsStateWithLifecycle lifecycle-aware, app background'da collect durur",
            "collectAsState daha hızlı",
            "Aynı şey"
          ],
          "correctAnswerIndex": 1,
          "explanation": "collectAsStateWithLifecycle, lifecycle-aware'dır. App background'a gittiğinde (onStop) collect durur, memory ve battery optimizasyonu sağlar. collectAsState her zaman collect eder.",
          "tags": ["flow", "collectasstate", "lifecycle"]
        },
        {
          "questionId": 590007,
          "question": "Modifier sıralaması neden önemlidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Hiç önemli değil",
            "Modifier'lar soldan sağa uygulanır, sıralama sonucu değiştirir",
            "Sadece performans",
            "Her zaman aynı"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Modifier sıralaması çok önemlidir. Soldan sağa uygulanır. Örneğin: padding sonra background farklı, background sonra padding farklı görsel sonuç verir.",
          "tags": ["modifier", "order"]
        },
        {
          "questionId": 590008,
          "question": "LazyColumn ve Column arasındaki fark nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Hiçbir fark yok",
            "LazyColumn lazy loading yapar (sadece görünen item'lar), Column tüm child'ları render eder",
            "Column daha performanslı",
            "LazyColumn deprecated"
          ],
          "correctAnswerIndex": 1,
          "explanation": "LazyColumn, lazy loading yapar (RecyclerView gibi). Sadece görünen item'lar render edilir, performanslıdır. Column tüm child'ları baştan render eder, büyük listelerde performans sorunu yaratır.",
          "tags": ["lazycolumn", "column", "performance"]
        },
        {
          "questionId": 590009,
          "question": "Material 3 (Material You) nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "easy",
          "options": [
            "Veritabanı",
            "Google'ın güncel Material Design versiyonu, dinamik renk desteği",
            "Network library",
            "Test framework"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Material 3 (Material You), Google'ın güncel Material Design versiyonudur. Dinamik renk (wallpaper bazlı), modern UI bileşenleri ve yuvarlak köşeler sunar.",
          "tags": ["material3", "design"]
        },
        {
          "questionId": 590010,
          "question": "Navigation Component'ta route nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Veritabanı tablosu",
            "Her ekranın unique string adresi (örn: 'home', 'profile/{id}')",
            "Network endpoint",
            "UI bileşeni"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Route, Navigation Component'ta her ekranın unique string adresidir. URL path gibi çalışır ve path parameter ile veri geçişi yapılabilir.",
          "tags": ["navigation", "route"]
        },
        {
          "questionId": 590011,
          "question": "ViewModel Compose'da neden kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece UI çizer",
            "Business logic ve state yönetir, configuration change'de hayatta kalır",
            "Sadece navigation",
            "Hiçbiri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "ViewModel, business logic ve UI state'i yönetir. Configuration change (ekran döndürme)'de hayatta kalır, UI'dan (Composable) bağımsızdır. MVVM pattern'in temelidir.",
          "tags": ["viewmodel", "mvvm"]
        },
        {
          "questionId": 590012,
          "question": "derivedStateOf ne işe yarar?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "State oluşturur",
            "Başka state'lerden türetilen state oluşturur, gereksiz recomposition önler",
            "State siler",
            "Hiçbir şey yapmaz"
          ],
          "correctAnswerIndex": 1,
          "explanation": "derivedStateOf, başka state'lerden türetilen state oluşturur. Sadece sonuç değiştiğinde recomposition tetikler, ara hesaplamalar tetiklemez. Performance optimizasyonu sağlar.",
          "tags": ["derivedstateof", "performance"]
        },
        {
          "questionId": 590013,
          "question": "Canvas Composable ne için kullanılır?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece layout",
            "Custom çizim, grafik, chart oluşturma (low-level drawing)",
            "Sadece image",
            "Hiçbiri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Canvas, low-level drawing API sağlar. Custom grafik, chart, drawing app, game rendering gibi use case'ler için kullanılır. drawCircle, drawRect, drawPath gibi fonksiyonlar sunar.",
          "tags": ["canvas", "drawing"]
        },
        {
          "questionId": 590014,
          "question": "Unidirectional Data Flow (UDF) ne demektir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Çift yönlü akış",
            "State yukarıdan aşağı (↓), Event aşağıdan yukarı (↑) tek yönlü akış",
            "Sadece state",
            "Hiçbiri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "UDF, state'in parent'tan child'a aşağı indiği (↓), event'lerin child'dan parent'a yukarı çıktığı (↑) tek yönlü veri akışıdır. Predictable state management sağlar.",
          "tags": ["udf", "architecture"]
        },
        {
          "questionId": 590015,
          "question": "CompositionLocal ne işe yarar?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Sadece state",
            "Implicit dependency injection, composition tree boyunca değer paylaşma",
            "Sadece theme",
            "Hiçbir şey yapmaz"
          ],
          "correctAnswerIndex": 1,
          "explanation": "CompositionLocal, implicit dependency injection sağlar. Theme, context, configuration gibi tree-wide shared değerleri composition tree boyunca paylaşır. LocalContext, LocalConfiguration vb.",
          "tags": ["compositionlocal", "dependency_injection"]
        },
        {
          "questionId": 590016,
          "question": "Stable type nedir ve neden önemlidir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Sadece immutable",
            "Compose'un equals() ile değişikliği tespit edebildiği tip, smart recomposition sağlar",
            "Her tip stable",
            "Hiçbiri"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Stable type, Compose'un equals() ile değişikliği tespit edebildiği tiptir. Primitive types, String, immutable data class stable'dır. Smart recomposition ve performance için kritiktir.",
          "tags": ["stable_type", "performance"]
        },
        {
          "questionId": 590017,
          "question": "animate*AsState ne işe yarar?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Sadece state",
            "State değişimini otomatik animate eder (declarative animation)",
            "Manuel animasyon",
            "Hiçbir şey yapmaz"
          ],
          "correctAnswerIndex": 1,
          "explanation": "animate*AsState (animateFloatAsState, animateDpAsState vb.), target state değiştiğinde otomatik olarak smooth animasyon yapar. Declarative animation API'dır.",
          "tags": ["animation", "animate_as_state"]
        },
        {
          "questionId": 590018,
          "question": "pointerInput ne işe yarar?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Sadece clickable",
            "Custom gesture detection, low-level touch event handling",
            "Sadece drag",
            "Hiçbir şey yapmaz"
          ],
          "correctAnswerIndex": 1,
          "explanation": "pointerInput, custom gesture detection için low-level touch event handling sağlar. detectTapGestures, detectDragGestures, detectTransformGestures gibi helper'lar vardır.",
          "tags": ["gesture", "pointerinput"]
        },
        {
          "questionId": 590019,
          "question": "Compose ve XML birlikte kullanılabilir mi?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "medium",
          "options": [
            "Hayır, sadece Compose veya XML",
            "Evet, ComposeView ve AndroidView ile interoperability mümkün",
            "Sadece yeni projelerde",
            "Kullanılamaz"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Evet, Compose ve XML birlikte kullanılabilir (interoperability). ComposeView ile XML'de Compose, AndroidView ile Compose'da XML kullanılır. Migration aşamalı yapılabilir.",
          "tags": ["interoperability", "xml", "compose"]
        },
        {
          "questionId": 590020,
          "question": "Compose'da performance optimize etmek için en önemli 3 yaklaşım nedir?",
          "questionType": "multiple_choice",
          "code": null,
          "difficulty": "hard",
          "options": [
            "Sadece remember kullan",
            "Stable types, remember/derivedStateOf, key kullanımı",
            "Sadece key kullan",
            "Optimization gerekmez"
          ],
          "correctAnswerIndex": 1,
          "explanation": "Compose performance için: 1) Stable types kullan (immutable data class), 2) remember/derivedStateOf ile gereksiz hesaplama önle, 3) LazyColumn'da key kullan. Bu 3 yaklaşım en kritik optimizasyonlardır.",
          "tags": ["performance", "optimization", "best_practice"]
        }
      ]
    }
  ]
}
